[
  {
    "id": "openai-gpt-5-2-for-science-and-math",
    "source": "OpenAI",
    "source_url": "https://openai.com/index/gpt-5-2-for-science-and-math/",
    "title": "Advancing science and math with GPT-5.2",
    "author": "OpenAI",
    "published_date": "2025-12-11T00:00:00Z",
    "scraped_at": 1765646993208,
    "status": "published",
    "content": {
      "original_html": "",
      "text": "Quick read\n- GPT-5.2 Pro and GPT-5.2 Thinking target math and science work, with top scores on GPQA Diamond and FrontierMath.\n- Emphasis on precise, multi-step reasoning for reliable scientific workflows like coding, data analysis, and experimental design.\n- Case study: GPT-5.2 Pro produced a proof resolving an open COLT learning-curve monotonicity problem for maximum likelihood estimators; humans verified and extended the result.\n- Outlook: frontier models can accelerate research exploration, but human judgment and verification remain essential.\n\nGPT-5.2 is positioned as OpenAI's strongest model yet for scientific and mathematical tasks. The release highlights improvements in precise multi-step reasoning that reduce errors across simulations, statistics, forecasting, and modeling. OpenAI argues these advances represent broader, transferable reasoning ability relevant to AGI.\n\nOn GPQA Diamond, a graduate-level science benchmark without tool use, GPT-5.2 Pro scores 93.2% and GPT-5.2 Thinking 92.4%. On FrontierMath (Tier 1–3), GPT-5.2 Thinking sets a new state of the art, solving 40.3% of expert-level math problems with code tools enabled.\n\nA detailed case study describes how GPT-5.2 Pro solved an open problem about whether learning curves for maximum likelihood estimators stay monotonic as more data is added. The model produced a full proof, which human experts verified and extended to higher-dimensional settings and other statistical models. Humans focused on validation and clear exposition rather than supplying proof scaffolding.\n\nThe article frames GPT-5.2 as a research assistant that can propose detailed arguments and hypotheses, while humans retain responsibility for checking assumptions, correctness, and domain context. The piece suggests workflows that combine model-generated reasoning with rigorous human oversight to accelerate theoretical and scientific progress.",
      "images": [
        "https://images.ctfassets.net/kftzwdyauwt9/1Tc0kBv3H0HRXf7SsizFfA/1a8b076fa71453ac7e822e30756fc066/5.2-Blog-1x1.png?w=3840&q=90&fm=webp"
      ]
    },
    "translations": {
      "es": {
        "title": "GPT-5.2 para ciencia y matemáticas",
        "content": "Lectura rápida\n- GPT-5.2 Pro y GPT-5.2 Thinking están orientados al trabajo en matemáticas y ciencia, con puntuaciones líderes en GPQA Diamond y FrontierMath.\n- El enfoque está en el razonamiento preciso y de múltiples pasos para flujos de trabajo científicos fiables como programación, análisis de datos y diseño experimental.\n- Caso de estudio: GPT-5.2 Pro generó una prueba que resolvió un problema abierto sobre la monotonía de las curvas de aprendizaje en estimadores de máxima verosimilitud; expertos humanos verificaron y ampliaron el resultado.\n- Perspectiva: los modelos de frontera pueden acelerar la exploración científica, pero el juicio y la verificación humana siguen siendo esenciales.\n\nGPT-5.2 se presenta como el modelo más sólido de OpenAI hasta la fecha para tareas científicas y matemáticas. El lanzamiento destaca mejoras en el razonamiento preciso de múltiples pasos que reducen errores en simulaciones, estadística, predicción y modelado. OpenAI sostiene que estos avances reflejan una capacidad de razonamiento más amplia y transferible, relevante para el progreso hacia la AGI.\n\nEn GPQA Diamond, un benchmark de ciencia a nivel de posgrado sin uso de herramientas, GPT-5.2 Pro alcanza un 93.2% y GPT-5.2 Thinking un 92.4%. En FrontierMath (niveles 1–3), GPT-5.2 Thinking establece un nuevo estado del arte al resolver el 40.3% de los problemas matemáticos de nivel experto con herramientas de código habilitadas.\n\nUn caso de estudio detallado describe cómo GPT-5.2 Pro resolvió un problema abierto sobre si las curvas de aprendizaje de los estimadores de máxima verosimilitud permanecen monótonas al añadir más datos. El modelo produjo una demostración completa, que expertos humanos verificaron y extendieron a configuraciones de mayor dimensión y otros modelos estadísticos. Los humanos se centraron en la validación y la claridad de la exposición, más que en proporcionar la estructura de la prueba.\n\nEl artículo presenta a GPT-5.2 como un asistente de investigación capaz de proponer argumentos e hipótesis detalladas, mientras que los humanos mantienen la responsabilidad de comprobar supuestos, corrección y contexto del dominio. Se proponen flujos de trabajo que combinan el razonamiento generado por el modelo con una supervisión humana rigurosa para acelerar el progreso teórico y científico.",
        "edited": false
      },
      "ukr": {
        "title": "GPT-5.2 для науки та математики",
        "content": "Коротко\n- GPT-5.2 Pro та GPT-5.2 Thinking орієнтовані на математичні й наукові задачі та демонструють провідні результати на GPQA Diamond і FrontierMath.\n- Основний акцент зроблено на точному багатокроковому міркуванні для надійних наукових workflow, зокрема програмування, аналізу даних і експериментального дизайну.\n- Кейс: GPT-5.2 Pro побудував доведення, яке розв’язало відкрите питання про монотонність кривих навчання для оцінок максимальної правдоподібності; люди перевірили й розширили результат.\n- Перспектива: frontier-моделі можуть прискорювати дослідницький пошук, але людське судження та перевірка залишаються критично важливими.\n\nGPT-5.2 позиціонується як найсильніша модель OpenAI для наукових і математичних задач на сьогодні. У релізі підкреслюються покращення в точному багатокроковому міркуванні, що зменшує кількість помилок у симуляціях, статистиці, прогнозуванні та моделюванні. OpenAI вважає, що ці досягнення свідчать про ширшу та переносну здатність до міркування, релевантну для прогресу до AGI.\n\nНа GPQA Diamond — науковому бенчмарку рівня магістратури та PhD без використання інструментів — GPT-5.2 Pro набирає 93.2%, а GPT-5.2 Thinking — 92.4%. На FrontierMath (рівні 1–3) GPT-5.2 Thinking встановлює новий state of the art, розв’язуючи 40.3% математичних задач експертного рівня з увімкненими код-інструментами.\n\nДетальний кейс описує, як GPT-5.2 Pro розв’язав відкрите питання про те, чи залишаються криві навчання для оцінок максимальної правдоподібності монотонними зі збільшенням обсягу даних. Модель згенерувала повне доведення, яке експерти-люди перевірили та узагальнили на багатовимірні випадки й інші статистичні моделі. Люди зосередилися на перевірці коректності та чіткому викладі, а не на побудові каркасу доведення.\n\nСтаття подає GPT-5.2 як дослідницького асистента, здатного пропонувати детальні аргументи й гіпотези, водночас залишаючи за людьми відповідальність за перевірку припущень, коректності та контексту предметної області. Пропонуються workflow, що поєднують міркування, згенеровані моделлю, з суворим людським контролем для прискорення теоретичного й наукового прогресу.",
        "edited": false
      },
      "pt": {
        "title": "Advancing science and math with GPT-5.2",
        "content": "Quick read\n- GPT-5.2 Pro and GPT-5.2 Thinking target math and science work, with top scores on GPQA Diamond and FrontierMath.\n- Emphasis on precise, multi-step reasoning for reliable scientific workflows like coding, data analysis, and experimental design.\n- Case study: GPT-5.2 Pro produced a proof resolving an open COLT learning-curve monotonicity problem for maximum likelihood estimators; humans verified and extended the result.\n- Outlook: frontier models can accelerate research exploration, but human judgment and verification remain essential.\n\nGPT-5.2 is positioned as OpenAI's strongest model yet for scientific and mathematical tasks. The release highlights improvements in precise multi-step reasoning that reduce errors across simulations, statistics, forecasting, and modeling. OpenAI argues these advances represent broader, transferable reasoning ability relevant to AGI.\n\nOn GPQA Diamond, a graduate-level science benchmark without tool use, GPT-5.2 Pro scores 93.2% and GPT-5.2 Thinking 92.4%. On FrontierMath (Tier 1–3), GPT-5.2 Thinking sets a new state of the art, solving 40.3% of expert-level math problems with code tools enabled.\n\nA detailed case study describes how GPT-5.2 Pro solved an open problem about whether learning curves for maximum likelihood estimators stay monotonic as more data is added. The model produced a full proof, which human experts verified and extended to higher-dimensional settings and other statistical models. Humans focused on validation and clear exposition rather than supplying proof scaffolding.\n\nThe article frames GPT-5.2 as a research assistant that can propose detailed arguments and hypotheses, while humans retain responsibility for checking assumptions, correctness, and domain context. The piece suggests workflows that combine model-generated reasoning with rigorous human oversight to accelerate theoretical and scientific progress.",
        "edited": false
      },
      "zh": {
        "title": "Advancing science and math with GPT-5.2",
        "content": "Quick read\n- GPT-5.2 Pro and GPT-5.2 Thinking target math and science work, with top scores on GPQA Diamond and FrontierMath.\n- Emphasis on precise, multi-step reasoning for reliable scientific workflows like coding, data analysis, and experimental design.\n- Case study: GPT-5.2 Pro produced a proof resolving an open COLT learning-curve monotonicity problem for maximum likelihood estimators; humans verified and extended the result.\n- Outlook: frontier models can accelerate research exploration, but human judgment and verification remain essential.\n\nGPT-5.2 is positioned as OpenAI's strongest model yet for scientific and mathematical tasks. The release highlights improvements in precise multi-step reasoning that reduce errors across simulations, statistics, forecasting, and modeling. OpenAI argues these advances represent broader, transferable reasoning ability relevant to AGI.\n\nOn GPQA Diamond, a graduate-level science benchmark without tool use, GPT-5.2 Pro scores 93.2% and GPT-5.2 Thinking 92.4%. On FrontierMath (Tier 1–3), GPT-5.2 Thinking sets a new state of the art, solving 40.3% of expert-level math problems with code tools enabled.\n\nA detailed case study describes how GPT-5.2 Pro solved an open problem about whether learning curves for maximum likelihood estimators stay monotonic as more data is added. The model produced a full proof, which human experts verified and extended to higher-dimensional settings and other statistical models. Humans focused on validation and clear exposition rather than supplying proof scaffolding.\n\nThe article frames GPT-5.2 as a research assistant that can propose detailed arguments and hypotheses, while humans retain responsibility for checking assumptions, correctness, and domain context. The piece suggests workflows that combine model-generated reasoning with rigorous human oversight to accelerate theoretical and scientific progress.",
        "edited": false
      },
      "hi": {
        "title": "Advancing science and math with GPT-5.2",
        "content": "Quick read\n- GPT-5.2 Pro and GPT-5.2 Thinking target math and science work, with top scores on GPQA Diamond and FrontierMath.\n- Emphasis on precise, multi-step reasoning for reliable scientific workflows like coding, data analysis, and experimental design.\n- Case study: GPT-5.2 Pro produced a proof resolving an open COLT learning-curve monotonicity problem for maximum likelihood estimators; humans verified and extended the result.\n- Outlook: frontier models can accelerate research exploration, but human judgment and verification remain essential.\n\nGPT-5.2 is positioned as OpenAI's strongest model yet for scientific and mathematical tasks. The release highlights improvements in precise multi-step reasoning that reduce errors across simulations, statistics, forecasting, and modeling. OpenAI argues these advances represent broader, transferable reasoning ability relevant to AGI.\n\nOn GPQA Diamond, a graduate-level science benchmark without tool use, GPT-5.2 Pro scores 93.2% and GPT-5.2 Thinking 92.4%. On FrontierMath (Tier 1–3), GPT-5.2 Thinking sets a new state of the art, solving 40.3% of expert-level math problems with code tools enabled.\n\nA detailed case study describes how GPT-5.2 Pro solved an open problem about whether learning curves for maximum likelihood estimators stay monotonic as more data is added. The model produced a full proof, which human experts verified and extended to higher-dimensional settings and other statistical models. Humans focused on validation and clear exposition rather than supplying proof scaffolding.\n\nThe article frames GPT-5.2 as a research assistant that can propose detailed arguments and hypotheses, while humans retain responsibility for checking assumptions, correctness, and domain context. The piece suggests workflows that combine model-generated reasoning with rigorous human oversight to accelerate theoretical and scientific progress.",
        "edited": false
      }
    },
    "metadata": {
      "tags": [
        "OpenAI",
        "GPT-5.2",
        "Science",
        "Math"
      ]
    }
  },
  {
    "id": "sample-anthropic-advanced-tool-use",
    "source": "Anthropic",
    "source_url": "https://www.anthropic.com/engineering/advanced-tool-use",
    "title": "Introducing advanced tool use on the Claude Developer Platform",
    "author": "Anthropic Engineering",
    "published_date": "2025-11-24T00:00:00Z",
    "scraped_at": 1733203200000,
    "status": "published",
    "content": {
      "original_html": "",
      "text": "The future of AI agents is one where models work seamlessly across hundreds or thousands of tools. An IDE assistant that integrates git operations, file manipulation, package managers, testing frameworks, and deployment pipelines. An operations coordinator that connects Slack, GitHub, Google Drive, Jira, company databases, and dozens of MCP servers simultaneously.\n\nTo build effective agents , they need to work with unlimited tool libraries without stuffing every definition into context upfront. Our blog article on using code execution with MCP discussed how tool results and definitions can sometimes consume 50,000+ tokens before an agent reads a request. Agents should discover and load tools on-demand, keeping only what's relevant for the current task.\n\nAgents also need the ability to call tools from code. When using natural language tool calling, each invocation requires a full inference pass, and intermediate results pile up in context whether they're useful or not. Code is a natural fit for orchestration logic, such as loops, conditionals, and data transformations. Agents need the flexibility to choose between code execution and inference based on the task at hand.\n\nAgents also need to learn correct tool usage from examples, not just schema definitions. JSON schemas define what's structurally valid, but can't express usage patterns: when to include optional parameters, which combinations make sense, or what conventions your API expects.\n\nToday, we're releasing three features that make this possible:\n\n- Tool Search Tool, which allows Claude to use search tools to access thousands of tools without consuming its context window\n\n- Programmatic Tool Calling , which allows Claude to invoke tools in a code execution environment reducing the impact on the model's context window\n\n- Tool Use Examples , which provides a universal standard for demonstrating how to effectively use a given tool\n\nIn internal testing, we've found these features have helped us build things that wouldn't have been possible with conventional tool use patterns. For example, Claude for Excel uses Programmatic Tool Calling to read and modify spreadsheets with thousands of rows without overloading the model's context window.\n\nBased on our experience, we believe these features open up new possibilities for what you can build with Claude.\n\nTool Search Tool\n\nThe challenge\n\nMCP tool definitions provide important context, but as more servers connect, those tokens can add up. Consider a five-server setup:\n\n- GitHub: 35 tools (~26K tokens)\n\n- Slack: 11 tools (~21K tokens)\n\n- Sentry: 5 tools (~3K tokens)\n\n- Grafana: 5 tools (~3K tokens)\n\n- Splunk: 2 tools (~2K tokens)\n\nThat's 58 tools consuming approximately 55K tokens before the conversation even starts. Add more servers like Jira (which alone uses ~17K tokens) and you're quickly approaching 100K+ token overhead. At Anthropic, we've seen tool definitions consume 134K tokens before optimization.\n\nBut token cost isn't the only issue. The most common failures are wrong tool selection and incorrect parameters, especially when tools have similar names like notification-send-user vs. notification-send-channel .\n\nOur solution\n\nInstead of loading all tool definitions upfront, the Tool Search Tool discovers tools on-demand. Claude only sees the tools it actually needs for the current task.\n\n[[IMAGE_1|Tool Search Tool preserves 191,300 tokens of context compared to 122,800 with Claude's traditional approach.]]\n\nTraditional approach:\n\n- All tool definitions loaded upfront (~72K tokens for 50+ MCP tools)\n\n- Conversation history and system prompt compete for remaining space\n\n- Total context consumption: ~77K tokens before any work begins\n\nWith the Tool Search Tool:\n\n- Only the Tool Search Tool loaded upfront (~500 tokens)\n\n- Tools discovered on-demand as needed (3-5 relevant tools, ~3K tokens)\n\n- Total context consumption: ~8.7K tokens, preserving 95% of context window\n\nThis represents an 85% reduction in token usage while maintaining access to your full tool library. Internal testing showed significant accuracy improvements on MCP evaluations when working with large tool libraries. Opus 4 improved from 49% to 74%, and Opus 4.5 improved from 79.5% to 88.1% with Tool Search Tool enabled.\n\nHow the Tool Search Tool works\n\nThe Tool Search Tool lets Claude dynamically discover tools instead of loading all definitions upfront. You provide all your tool definitions to the API, but mark tools with defer_loading: true to make them discoverable on-demand. Deferred tools aren't loaded into Claude's context initially. Claude only sees the Tool Search Tool itself plus any tools with defer_loading: false (your most critical, frequently-used tools).\n\nWhen Claude needs specific capabilities, it searches for relevant tools. The Tool Search Tool returns references to matching tools, which get expanded into full definitions in Claude's context.\n\nFor example, if Claude needs to interact with GitHub, it searches for \"github,\" and only github.createPullRequest and github.listIssues get loaded-not your other 50+ tools from Slack, Jira, and Google Drive.\n\nThis way, Claude has access to your full tool library while only paying the token cost for tools it actually needs.\n\nPrompt caching note: Tool Search Tool doesn't break prompt caching because deferred tools are excluded from the initial prompt entirely. They're only added to context after Claude searches for them, so your system prompt and core tool definitions remain cacheable.\n\nImplementation:\n\n```\n{\n  \"tools\": [\n    // Include a tool search tool (regex, BM25, or custom)\n    {\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n\n    // Mark tools for on-demand discovery\n    {\n      \"name\": \"github.createPullRequest\",\n      \"description\": \"Create a pull request\",\n      \"input_schema\": {...},\n      \"defer_loading\": true\n    }\n    // ... hundreds more deferred tools with defer_loading: true\n  ]\n}\n```\n\nFor MCP servers, you can defer loading entire servers while keeping specific high-use tools loaded:\n\n```\n{\n  \"type\": \"mcp_toolset\",\n  \"mcp_server_name\": \"google-drive\",\n  \"default_config\": {\"defer_loading\": true}, # defer loading the entire server\n  \"configs\": {\n    \"search_files\": {\n\"defer_loading\": false\n    }  // Keep most used tool loaded\n  }\n}\n```\n\nThe Claude Developer Platform provides regex-based and BM25-based search tools out of the box, but you can also implement custom search tools using embeddings or other strategies.\n\nWhen to use the Tool Search Tool\n\nLike any architectural decision, enabling the Tool Search Tool involves trade-offs. The feature adds a search step before tool invocation, so it delivers the best ROI when the context savings and accuracy improvements outweigh additional latency.\n\nUse it when:\n\n- Tool definitions consuming >10K tokens\n\n- Experiencing tool selection accuracy issues\n\n- Building MCP-powered systems with multiple servers\n\n- 10+ tools available\n\nLess beneficial when:\n\n- Small tool library (<10 tools)\n\n- All tools used frequently in every session\n\n- Tool definitions are compact\n\nProgrammatic Tool Calling\n\nThe challenge\n\nTraditional tool calling creates two fundamental problems as workflows become more complex:\n\n- Context pollution from intermediate results : When Claude analyzes a 10MB log file for error patterns, the entire file enters its context window, even though Claude only needs a summary of error frequencies. When fetching customer data across multiple tables, every record accumulates in context regardless of relevance. These intermediate results consume massive token budgets and can push important information out of the context window entirely.\n\n- Inference overhead and manual synthesis : Each tool call requires a full model inference pass. After receiving results, Claude must \"eyeball\" the data to extract relevant information, reason about how pieces fit together, and decide what to do next-all through natural language processing. A five tool workflow means five inference passes plus Claude parsing each result, comparing values, and synthesizing conclusions. This is both slow and error-prone.\n\nOur solution\n\nProgrammatic Tool Calling enables Claude to orchestrate tools through code rather than through individual API round-trips. Instead of Claude requesting tools one at a time with each result being returned to its context, Claude writes code that calls multiple tools, processes their outputs, and controls what information actually enters its context window.\n\nClaude excels at writing code and by letting it express orchestration logic in Python rather than through natural language tool invocations, you get more reliable, precise control flow. Loops, conditionals, data transformations, and error handling are all explicit in code rather than implicit in Claude's reasoning.\n\nExample: Budget compliance check\n\nConsider a common business task: \"Which team members exceeded their Q3 travel budget?\"\n\nYou have three tools available:\n\n- get_team_members(department) - Returns team member list with IDs and levels\n\n- get_expenses(user_id, quarter) - Returns expense line items for a user\n\n- get_budget_by_level(level) - Returns budget limits for an employee level\n\nTraditional approach :\n\n- Fetch team members 20 people\n\n- For each person, fetch their Q3 expenses 20 tool calls, each returning 50-100 line items (flights, hotels, meals, receipts)\n\n- Fetch budget limits by employee level\n\n- All of this enters Claude's context: 2,000+ expense line items (50 KB+)\n\n- Claude manually sums each person's expenses, looks up their budget, compares expenses against budget limits\n\n- More round-trips to the model, significant context consumption\n\nWith Programmatic Tool Calling :\n\nInstead of each tool result returning to Claude, Claude writes a Python script that orchestrates the entire workflow. The script runs in the Code Execution tool (a sandboxed environment), pausing when it needs results from your tools. When you return tool results via the API, they're processed by the script rather than consumed by the model. The script continues executing, and Claude only sees the final output.\n\n[[IMAGE_2|Programmatic Tool Calling enables Claude to orchestrate tools through code rather than through individual API round-trips, allowing for parallel tool execution.]]\n\nHere's what Claude's orchestration code looks like for the budget compliance task:\n\n```\nteam = await get_team_members(\"engineering\")\n\n# Fetch budgets for each unique level\nlevels = list(set(m[\"level\"] for m in team))\nbudget_results = await asyncio.gather(*[\n    get_budget_by_level(level) for level in levels\n])\n\n# Create a lookup dictionary: {\"junior\": budget1, \"senior\": budget2, ...}\nbudgets = {level: budget for level, budget in zip(levels, budget_results)}\n\n# Fetch all expenses in parallel\nexpenses = await asyncio.gather(*[\n    get_expenses(m[\"id\"], \"Q3\") for m in team\n])\n\n# Find employees who exceeded their travel budget\nexceeded = []\nfor member, exp in zip(team, expenses):\n    budget = budgets[member[\"level\"]]\n    total = sum(e[\"amount\"] for e in exp)\n    if total > budget[\"travel_limit\"]:\n        exceeded.append({\n            \"name\": member[\"name\"],\n            \"spent\": total,\n            \"limit\": budget[\"travel_limit\"]\n        })\n\nprint(json.dumps(exceeded))\n```\n\nClaude's context receives only the final result: the two to three people who exceeded their budget. The 2,000+ line items, the intermediate sums, and the budget lookups do not affect Claude's context, reducing consumption from 200KB of raw expense data to just 1KB of results.\n\nThe efficiency gains are substantial:\n\n- Token savings : By keeping intermediate results out of Claude's context, PTC dramatically reduces token consumption. Average usage dropped from 43,588 to 27,297 tokens, a 37% reduction on complex research tasks.\n\n- Reduced latency : Each API round-trip requires model inference (hundreds of milliseconds to seconds). When Claude orchestrates 20+ tool calls in a single code block, you eliminate 19+ inference passes. The API handles tool execution without returning to the model each time.\n\n- Improved accuracy : By writing explicit orchestration logic, Claude makes fewer errors than when juggling multiple tool results in natural language. Internal knowledge retrieval improved from 25.6% to 28.5%; GIA benchmarks from 46.5% to 51.2%.\n\nProduction workflows involve messy data, conditional logic, and operations that need to scale. Programmatic Tool Calling lets Claude handle that complexity programmatically while keeping its focus on actionable results rather than raw data processing.\n\nHow Programmatic Tool Calling works\n\n1. Mark tools as callable from code\n\nAdd code_execution to tools, and set allowed_callers to opt-in tools for programmatic execution:\n\n```\n{\n  \"tools\": [\n    {\n      \"type\": \"code_execution_20250825\",\n      \"name\": \"code_execution\"\n    },\n    {\n      \"name\": \"get_team_members\",\n      \"description\": \"Get all members of a department...\",\n      \"input_schema\": {...},\n      \"allowed_callers\": [\"code_execution_20250825\"] # opt-in to programmatic tool calling\n    },\n    {\n      \"name\": \"get_expenses\",\n \t...\n    },\n    {\n      \"name\": \"get_budget_by_level\",\n\t...\n    }\n  ]\n}\n```\n\nThe API converts these tool definitions into Python functions that Claude can call.\n\n2. Claude writes orchestration code\n\nInstead of requesting tools one at a time, Claude generates Python code:\n\n```\n{\n  \"type\": \"server_tool_use\",\n  \"id\": \"srvtoolu_abc\",\n  \"name\": \"code_execution\",\n  \"input\": {\n    \"code\": \"team = get_team_members('engineering')\\n...\" # the code example above\n  }\n}\n```\n\n3. Tools execute without hitting Claude's context\n\nWhen the code calls get_expenses(), you receive a tool request with a caller field:\n\n```\n{\n  \"type\": \"tool_use\",\n  \"id\": \"toolu_xyz\",\n  \"name\": \"get_expenses\",\n  \"input\": {\"user_id\": \"emp_123\", \"quarter\": \"Q3\"},\n  \"caller\": {\n    \"type\": \"code_execution_20250825\",\n    \"tool_id\": \"srvtoolu_abc\"\n  }\n}\n```\n\nYou provide the result, which is processed in the Code Execution environment rather than Claude's context. This request-response cycle repeats for each tool call in the code.\n\n4. Only final output enters context\n\nWhen the code finishes running, only the results of the code are returned to Claude:\n\n```\n{\n  \"type\": \"code_execution_tool_result\",\n  \"tool_use_id\": \"srvtoolu_abc\",\n  \"content\": {\n    \"stdout\": \"[{\\\"name\\\": \\\"Alice\\\", \\\"spent\\\": 12500, \\\"limit\\\": 10000}...]\"\n  }\n}\n```\n\nThis is all Claude sees, not the 2000+ expense line items processed along the way.\n\nWhen to use Programmatic Tool Calling\n\nProgrammatic Tool Calling adds a code execution step to your workflow. This extra overhead pays off when the token savings, latency improvements, and accuracy gains are substantial.\n\nMost beneficial when:\n\n- Processing large datasets where you only need aggregates or summaries\n\n- Running multi-step workflows with three or more dependent tool calls\n\n- Filtering, sorting, or transforming tool results before Claude sees them\n\n- Handling tasks where intermediate data shouldn't influence Claude's reasoning\n\n- Running parallel operations across many items (checking 50 endpoints, for example)\n\nLess beneficial when:\n\n- Making simple single-tool invocations\n\n- Working on tasks where Claude should see and reason about all intermediate results\n\n- Running quick lookups with small responses\n\nTool Use Examples\n\nThe challenge\n\nJSON Schema excels at defining structure-types, required fields, allowed enums-but it can't express usage patterns: when to include optional parameters, which combinations make sense, or what conventions your API expects.\n\nConsider a support ticket API:\n\n```\n{\n  \"name\": \"create_ticket\",\n  \"input_schema\": {\n    \"properties\": {\n      \"title\": {\"type\": \"string\"},\n      \"priority\": {\"enum\": [\"low\", \"medium\", \"high\", \"critical\"]},\n      \"labels\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n      \"reporter\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\"type\": \"string\"},\n          \"name\": {\"type\": \"string\"},\n          \"contact\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"email\": {\"type\": \"string\"},\n              \"phone\": {\"type\": \"string\"}\n            }\n          }\n        }\n      },\n      \"due_date\": {\"type\": \"string\"},\n      \"escalation\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"level\": {\"type\": \"integer\"},\n          \"notify_manager\": {\"type\": \"boolean\"},\n          \"sla_hours\": {\"type\": \"integer\"}\n        }\n      }\n    },\n    \"required\": [\"title\"]\n  }\n}\n```\n\nThe schema defines what's valid, but leaves critical questions unanswered:\n\n- Format ambiguity: Should due_date use \"2024-11-06\", \"Nov 6, 2024\", or \"2024-11-06T00:00:00Z\"?\n\n- ID conventions: Is reporter.id a UUID, \"USR-12345\", or just \"12345\"?\n\n- Nested structure usage: When should Claude populate reporter.contact ?\n\n- Parameter correlations: How do escalation.level and escalation.sla_hours relate to priority?\n\nThese ambiguities can lead to malformed tool calls and inconsistent parameter usage.\n\nOur solution\n\nTool Use Examples let you provide sample tool calls directly in your tool definitions. Instead of relying on schema alone, you show Claude concrete usage patterns:\n\n```\n{\n    \"name\": \"create_ticket\",\n    \"input_schema\": { /* same schema as above */ },\n    \"input_examples\": [\n      {\n        \"title\": \"Login page returns 500 error\",\n        \"priority\": \"critical\",\n        \"labels\": [\"bug\", \"authentication\", \"production\"],\n        \"reporter\": {\n          \"id\": \"USR-12345\",\n          \"name\": \"Jane Smith\",\n          \"contact\": {\n            \"email\": \"jane@acme.com\",\n            \"phone\": \"+1-555-0123\"\n          }\n        },\n        \"due_date\": \"2024-11-06\",\n        \"escalation\": {\n          \"level\": 2,\n          \"notify_manager\": true,\n          \"sla_hours\": 4\n        }\n      },\n      {\n        \"title\": \"Add dark mode support\",\n        \"labels\": [\"feature-request\", \"ui\"],\n        \"reporter\": {\n          \"id\": \"USR-67890\",\n          \"name\": \"Alex Chen\"\n        }\n      },\n      {\n        \"title\": \"Update API documentation\"\n      }\n    ]\n  }\n```\n\nFrom these three examples, Claude learns:\n\n- Format conventions : Dates use YYYY-MM-DD, user IDs follow USR-XXXXX, labels use kebab-case\n\n- Nested structure patterns : How to construct the reporter object with its nested contact object\n\n- Optional parameter correlations : Critical bugs have full contact info + escalation with tight SLAs; feature requests have reporter but no contact/escalation; internal tasks have title only\n\nIn our own internal testing, tool use examples improved accuracy from 72% to 90% on complex parameter handling.\n\nWhen to use Tool Use Examples\n\nTool Use Examples add tokens to your tool definitions, so they're most valuable when accuracy improvements outweigh the additional cost.\n\nMost beneficial when:\n\n- Complex nested structures where valid JSON doesn't imply correct usage\n\n- Tools with many optional parameters and inclusion patterns matter\n\n- APIs with domain-specific conventions not captured in schemas\n\n- Similar tools where examples clarify which one to use (e.g., create_ticket vs create_incident )\n\nLess beneficial when:\n\n- Simple single-parameter tools with obvious usage\n\n- Standard formats like URLs or emails that Claude already understands\n\n- Validation concerns better handled by JSON Schema constraints\n\nBest practices\n\nBuilding agents that take real-world actions means handling scale, complexity, and precision simultaneously. These three features work together to solve different bottlenecks in tool use workflows. Here's how to combine them effectively.\n\nLayer features strategically\n\nNot every agent needs to use all three features for a given task. Start with your biggest bottleneck:\n\n- Context bloat from tool definitions Tool Search Tool\n\n- Large intermediate results polluting context Programmatic Tool Calling\n\n- Parameter errors and malformed calls Tool Use Examples\n\nThis focused approach lets you address the specific constraint limiting your agent's performance, rather than adding complexity upfront.\n\nThen layer additional features as needed. They're complementary: Tool Search Tool ensures the right tools are found, Programmatic Tool Calling ensures efficient execution, and Tool Use Examples ensure correct invocation.\n\nSet up Tool Search Tool for better discovery\n\nTool search matches against names and descriptions, so clear, descriptive definitions improve discovery accuracy.\n\n```\n// Good\n{\n    \"name\": \"search_customer_orders\",\n    \"description\": \"Search for customer orders by date range, status, or total amount. Returns order details including items, shipping, and payment info.\"\n}\n\n// Bad\n{\n    \"name\": \"query_db_orders\",\n    \"description\": \"Execute order query\"\n}\n```\n\nAdd system prompt guidance so Claude knows what's available:\n\n```\nYou have access to tools for Slack messaging, Google Drive file management, \nJira ticket tracking, and GitHub repository operations. Use the tool search \nto find specific capabilities.\n```\n\nKeep your three to five most-used tools always loaded, defer the rest. This balances immediate access for common operations with on-demand discovery for everything else.\n\nSet up Programmatic Tool Calling for correct execution\n\nSince Claude writes code to parse tool outputs, document return formats clearly. This helps Claude write correct parsing logic:\n\n```\n{\n    \"name\": \"get_orders\",\n    \"description\": \"Retrieve orders for a customer.\nReturns:\n    List of order objects, each containing:\n    - id (str): Order identifier\n    - total (float): Order total in USD\n    - status (str): One of 'pending', 'shipped', 'delivered'\n    - items (list): Array of {sku, quantity, price}\n    - created_at (str): ISO 8601 timestamp\"\n}\n```\n\nSee below for opt-in tools that benefit from programmatic orchestration:\n\n- Tools that can run in parallel (independent operations)\n\n- Operations safe to retry (idempotent)\n\nSet up Tool Use Examples for parameter accuracy\n\nCraft examples for behavioral clarity:\n\n- Use realistic data (real city names, plausible prices, not \"string\" or \"value\")\n\n- Show variety with minimal, partial, and full specification patterns\n\n- Keep it concise: 1-5 examples per tool\n\n- Focus on ambiguity (only add examples where correct usage isn't obvious from schema)\n\nGetting started\n\nThese features are available in beta. To enable them, add the beta header and include the tools you need:\n\n```\nclient.beta.messages.create(\n    betas=[\"advanced-tool-use-2025-11-20\"],\n    model=\"claude-sonnet-4-5-20250929\",\n    max_tokens=4096,\n    tools=[\n        {\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n        {\"type\": \"code_execution_20250825\", \"name\": \"code_execution\"},\n        # Your tools with defer_loading, allowed_callers, and input_examples\n    ]\n)\n```\n\nFor detailed API documentation and SDK examples, see our:\n\n- D ocumentation and cookbook for Tool Search Tool\n\n- Documentation and cookbook for Programmatic Tool Calling\n\n- Documentation for Tool Use Examples\n\nThese features move tool use from simple function calling toward intelligent orchestration. As agents tackle more complex workflows spanning dozens of tools and large datasets, dynamic discovery, efficient execution, and reliable invocation become foundational.\n\nWe're excited to see what you build.\n\nAcknowledgements\n\nWritten by Bin Wu, with contributions from Adam Jones, Artur Renault, Henry Tay, Jake Noble, Nathan McCandlish, Noah Picard, Sam Jiang, and the Claude Developer Platform team. This work builds on foundational research by Chris Gorgolewski, Daniel Jiang, Jeremy Fox and Mike Lambert. We also drew inspiration from across the AI ecosystem, including Joel Pobar's LLMVM , Cloudflare's Code Mode and Code Execution as MCP . Special thanks to Andy Schumeister, Hamish Kerr, Keir Bradwell, Matt Bleifer and Molly Vorwerck for their support.",
      "images": [
        "https://www-cdn.anthropic.com/images/4zrzovbb/website/151600be7f9c23247aad8dcb6aacb2e1ab024f44-1000x1000.svg",
        "https://www-cdn.anthropic.com/images/4zrzovbb/website/f359296f770706608901eadaffbff4ca0b67874c-1999x1125.png",
        "https://www-cdn.anthropic.com/images/4zrzovbb/website/65737d69a3290ed5c1f3c3b8dc873645a9dcc2eb-1999x1491.png"
      ]
    },
    "translations": {
      "es": {
        "title": "Presentamos el uso avanzado de herramientas en Claude Developer Platform",
        "content": "El futuro de los agentes de IA es uno en el que los modelos funcionen a la perfección en cientos o miles de herramientas.Un asistente IDE que integra operaciones de git, manipulación de archivos, administradores de paquetes, marcos de prueba y canales de implementación.Un coordinador de operaciones que conecta Slack, GitHub, Google Drive, Jira, bases de datos de la empresa y decenas de servidores MCP simultáneamente.\n\nPara crear agentes eficaces, necesitan trabajar con bibliotecas de herramientas ilimitadas sin meter cada definición en contexto desde el principio.Nuestro artículo de blog sobre el uso de la ejecución de código con MCP analiza cómo los resultados y las definiciones de las herramientas a veces pueden consumir más de 50 000 tokens antes de que un agente lea una solicitud.Los agentes deben descubrir y cargar herramientas según demanda, conservando solo lo que sea relevante para la tarea actual.\n\nLos agentes también necesitan la capacidad de llamar herramientas desde el código.Cuando se utilizan llamadas a herramientas de lenguaje natural, cada invocación requiere un pase de inferencia completo y los resultados intermedios se acumulan en contexto, sean útiles o no.El código es una opción natural para la lógica de orquestación, como bucles, condicionales y transformaciones de datos.Los agentes necesitan flexibilidad para elegir entre ejecución de código e inferencia según la tarea en cuestión.\n\nLos agentes también necesitan aprender el uso correcto de las herramientas a partir de ejemplos, no solo de definiciones de esquemas.Los esquemas JSON definen lo que es estructuralmente válido, pero no pueden expresar patrones de uso: cuándo incluir parámetros opcionales, qué combinaciones tienen sentido o qué convenciones espera su API.\n\nHoy lanzamos tres funciones que lo hacen posible:\n\n- Herramienta de búsqueda de herramientas, que permite a Claude utilizar herramientas de búsqueda para acceder a miles de herramientas sin consumir su ventana contextual.\n\n- Llamada programática a herramientas, que permite a Claude invocar herramientas en un entorno de ejecución de código, lo que reduce el impacto en la ventana contextual del modelo.\n\n- Ejemplos de uso de herramientas, que proporciona un estándar universal para demostrar cómo utilizar eficazmente una herramienta determinada.\n\nEn pruebas internas, descubrimos que estas características nos han ayudado a crear cosas que no hubieran sido posibles con los patrones de uso de herramientas convencionales.Por ejemplo, Claude para Excel utiliza llamadas a herramientas programáticas para leer y modificar hojas de cálculo con miles de filas sin sobrecargar la ventana contextual del modelo.\n\nSegún nuestra experiencia, creemos que estas características abren nuevas posibilidades para lo que puede crear con Claude.\n\nHerramienta de búsqueda de herramientas\n\nEl desafío\n\nLas definiciones de las herramientas MCP proporcionan un contexto importante, pero a medida que se conectan más servidores, esos tokens pueden acumularse.Considere una configuración de cinco servidores:\n\n- GitHub: 35 herramientas (~26.000 tokens)\n\n- Slack: 11 herramientas (~21.000 tokens)\n\n- Sentry: 5 herramientas (~3K tokens)\n\n- Grafana: 5 herramientas (~3K tokens)\n\n- Splunk: 2 herramientas (~2K tokens)\n\nSon 58 herramientas que consumen aproximadamente 55.000 tokens incluso antes de que comience la conversación.Agregue más servidores como Jira (que por sí solo usa ~17.000 tokens) y se acercará rápidamente a una sobrecarga de tokens de más de 100.000.En Anthropic, hemos visto que las definiciones de herramientas consumen 134.000 tokens antes de la optimización.\n\nPero el costo simbólico no es el único problema.Las fallas más comunes son la selección incorrecta de herramientas y parámetros incorrectos, especialmente cuando las herramientas tienen nombres similares como notificación-envío-usuario versus notificación-envío-canal.\n\nNuestra solución\n\nEn lugar de cargar todas las definiciones de herramientas por adelantado, la herramienta de búsqueda de herramientas descubre herramientas a pedido.Claude sólo ve las herramientas que realmente necesita para la tarea actual.\n\n[[IMAGE_1|La herramienta de búsqueda conserva 191.300 tokens de contexto en comparación con los 122.800 del enfoque tradicional de Claude.]]\n\nEnfoque tradicional:\n\n- Todas las definiciones de herramientas cargadas por adelantado (~72.000 tokens para más de 50 herramientas MCP)\n\n- El historial de conversaciones y el mensaje del sistema compiten por el espacio restante\n\n- Consumo total de contexto: ~77.000 tokens antes de que comience cualquier trabajo\n\nCon la herramienta de búsqueda de herramientas:\n\n- Solo la herramienta de búsqueda de herramientas se carga por adelantado (~500 tokens)\n\n- Herramientas descubiertas bajo demanda según sea necesario (3-5 herramientas relevantes, ~3K tokens)\n\n- Consumo total de contexto: ~8.7K tokens, preservando el 95% de la ventana de contexto\n\nEsto representa una reducción del 85 % en el uso de tokens y al mismo tiempo mantiene el acceso a su biblioteca completa de herramientas.Las pruebas internas mostraron mejoras significativas en la precisión de las evaluaciones de MCP cuando se trabaja con grandes bibliotecas de herramientas.Opus 4 mejoró del 49% al 74%, y Opus 4.5 mejoró del 79,5% al ​​88,1% con la herramienta de búsqueda habilitada.\n\nCómo funciona la herramienta de búsqueda de herramientas La herramienta de búsqueda de herramientas le permite a Claude descubrir herramientas dinámicamente en lugar de cargar todas las definiciones por adelantado.Usted proporciona todas las definiciones de sus herramientas a la API, pero marca las herramientas con defer_loading: true para que sean reconocibles bajo demanda.Las herramientas diferidas no se cargan inicialmente en el contexto de Claude.Claude solo ve la herramienta de búsqueda de herramientas más cualquier herramienta con defer_loading: false (sus herramientas más importantes y de uso más frecuente).\n\nCuando Claude necesita capacidades específicas, busca herramientas relevantes.La herramienta de búsqueda de herramientas devuelve referencias a herramientas coincidentes, que se amplían a definiciones completas en el contexto de Claude.\n\nPor ejemplo, si Claude necesita interactuar con GitHub, busca \"github\" y solo se cargan github.createPullRequest y github.listIssues, no las otras más de 50 herramientas de Slack, Jira y Google Drive.\n\nDe esta manera, Claude tiene acceso a su biblioteca completa de herramientas y solo paga el costo simbólico de las herramientas que realmente necesita.\n\nNota sobre el almacenamiento en caché de mensajes: la herramienta de búsqueda de herramientas no interrumpe el almacenamiento en caché de mensajes porque las herramientas diferidas se excluyen por completo del mensaje inicial.Solo se agregan al contexto después de que Claude los busca, por lo que las definiciones de las herramientas principales y del sistema se pueden almacenar en caché.\n\nImplementación:\n\n```\n{\n\"herramientas\": [\n// Incluir una herramienta de búsqueda de herramientas (regex, BM25 o personalizada)\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nombre\": \"tool_search_tool_regex\"},\n\n// Marcar herramientas para descubrimiento bajo demanda\n{\n\"nombre\": \"github.createPullRequest\",\n\"description\": \"Crear una solicitud de extracción\",\n\"esquema_entrada\": {...},\n\"defer_loading\": verdadero\n}\n// ... cientos de herramientas más diferidas con defer_loading: true\n]\n}\n```\n\nPara servidores MCP, puede diferir la carga de servidores completos mientras mantiene cargadas herramientas específicas de alto uso:\n\n```\n{\n\"tipo\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-drive\",\n\"default_config\": {\"defer_loading\": true}, # posponer la carga de todo el servidor\n\"configuraciones\": {\n\"archivos_de búsqueda\": {\n\"defer_loading\": falso\n} // Mantiene cargada la herramienta más utilizada\n}\n}\n```\n\nClaude Developer Platform proporciona herramientas de búsqueda listas para usar basadas en expresiones regulares y basadas en BM25, pero también puede implementar herramientas de búsqueda personalizadas mediante incrustaciones u otras estrategias.\n\nCuándo utilizar la herramienta de búsqueda de herramientas\n\nComo cualquier decisión arquitectónica, habilitar la herramienta de búsqueda de herramientas implica compensaciones.La característica agrega un paso de búsqueda antes de la invocación de la herramienta, por lo que ofrece el mejor retorno de la inversión cuando los ahorros de contexto y las mejoras de precisión superan la latencia adicional.\n\nÚselo cuando:\n\n- Definiciones de herramientas que consumen >10K tokens\n\n- Experimentar problemas de precisión en la selección de herramientas\n\n- Creación de sistemas impulsados por MCP con múltiples servidores\n\n- Más de 10 herramientas disponibles\n\nMenos beneficioso cuando:\n\n- Pequeña biblioteca de herramientas (<10 herramientas)\n\n- Todas las herramientas utilizadas con frecuencia en cada sesión.\n\n- Las definiciones de herramientas son compactas.\n\nLlamada a herramientas programáticas\n\nEl desafío\n\nLa llamada a herramientas tradicionales crea dos problemas fundamentales a medida que los flujos de trabajo se vuelven más complejos:\n\n- Contaminación del contexto a partir de resultados intermedios: cuando Claude analiza un archivo de registro de 10 MB en busca de patrones de error, el archivo completo ingresa a su ventana de contexto, aunque Claude solo necesita un resumen de las frecuencias de error.Al recuperar datos de clientes en varias tablas, cada registro se acumula en contexto independientemente de su relevancia.Estos resultados intermedios consumen presupuestos simbólicos masivos y pueden sacar información importante fuera de la ventana contextual por completo.\n\n- Gastos generales de inferencia y síntesis manual: cada llamada a la herramienta requiere un pase de inferencia completo del modelo.Después de recibir los resultados, Claude debe \"observar\" los datos para extraer información relevante, razonar sobre cómo encajan las piezas y decidir qué hacer a continuación, todo ello mediante el procesamiento del lenguaje natural.Un flujo de trabajo de cinco herramientas significa cinco pases de inferencia más Claude analizando cada resultado, comparando valores y sintetizando conclusiones.Esto es lento y propenso a errores.\n\nNuestra solución\n\nLa llamada de herramientas programáticas permite a Claude orquestar herramientas a través de código en lugar de mediante viajes de ida y vuelta de API individuales.En lugar de que Claude solicite herramientas una a la vez y cada resultado se devuelva a su contexto, Claude escribe código que llama a múltiples herramientas, procesa sus resultados y controla qué información realmente ingresa a su ventana de contexto. Claude se destaca en la escritura de código y, al permitirle expresar la lógica de orquestación en Python en lugar de a través de invocaciones de herramientas de lenguaje natural, se obtiene un flujo de control más confiable y preciso.Los bucles, los condicionales, las transformaciones de datos y el manejo de errores están todos explícitos en el código y no implícitos en el razonamiento de Claude.\n\nEjemplo: control de cumplimiento presupuestario\n\nConsidere una tarea empresarial común: \"¿Qué miembros del equipo excedieron su presupuesto de viaje para el tercer trimestre?\"\n\nTienes tres herramientas disponibles:\n\n- get_team_members(departamento) - Devuelve la lista de miembros del equipo con ID y niveles\n\n- get_expenses(user_id, quarter): devuelve partidas de gastos para un usuario\n\n- get_budget_by_level(nivel): devuelve los límites de presupuesto para un nivel de empleado\n\nEnfoque tradicional:\n\n- Buscar miembros del equipo 20 personas.\n\n- Para cada persona, obtenga sus gastos del tercer trimestre con 20 llamadas de herramientas, cada una de las cuales devolverá entre 50 y 100 partidas (vuelos, hoteles, comidas, recibos).\n\n- Obtener límites de presupuesto por nivel de empleado\n\n- Todo esto entra en el contexto de Claude: más de 2000 partidas de gastos (50 KB+)\n\n- Claude suma manualmente los gastos de cada persona, busca su presupuesto y compara los gastos con los límites presupuestarios.\n\n- Más viajes de ida y vuelta al modelo, consumo de contexto significativo\n\nCon llamadas de herramientas programáticas:\n\nEn lugar de que el resultado de cada herramienta regrese a Claude, Claude escribe un script en Python que organiza todo el flujo de trabajo.El script se ejecuta en la herramienta de ejecución de código (un entorno de espacio aislado) y se detiene cuando necesita resultados de sus herramientas.Cuando devuelve resultados de herramientas a través de la API, el script los procesa en lugar de consumirlos el modelo.El guión continúa ejecutándose y Claude solo ve el resultado final.\n\n[[IMAGE_2|La llamada a herramientas programáticas permite a Claude orquestar herramientas a través de código en lugar de a través de recorridos de ida y vuelta de API individuales, lo que permite la ejecución de herramientas en paralelo.]]\n\nAsí es como se ve el código de orquestación de Claude para la tarea de cumplimiento presupuestario:\n\n```\nequipo = await get_team_members(\"ingeniería\")\n\n# Obtener presupuestos para cada nivel único\nniveles = lista(set(m[\"nivel\"] para m en el equipo))\npresupuesto_resultados = esperar asyncio.gather(*[\nget_budget_by_level(nivel) para nivel en niveles\n])\n\n# Crear un diccionario de búsqueda: {\"junior\": presupuesto1, \"senior\": presupuesto2, ...}\npresupuestos = {nivel: presupuesto por nivel, presupuesto en zip(niveles, presupuesto_resultados)}\n\n# Recuperar todos los gastos en paralelo\ngastos = esperar asyncio.gather(*[\nget_expenses(m[\"id\"], \"Q3\") para m en el equipo\n])\n\n# Encuentre empleados que excedieron su presupuesto de viaje\nsuperado = []\npara miembro, exp en zip (equipo, gastos):\npresupuesto = presupuestos[miembro[\"nivel\"]]\ntotal = suma(e[\"cantidad\"] para e en exp)\nsi total > presupuesto[\"limite_viaje\"]:\nsuperado.append({\n\"nombre\": miembro[\"nombre\"],\n\"gastado\": total,\n\"límite\": presupuesto[\"travel_limit\"]\n})\n\nprint(json.dumps(excedido))\n```\n\nEl contexto de Claude sólo recibe el resultado final: las dos o tres personas que excedieron su presupuesto.Las más de 2000 partidas, las sumas intermedias y las búsquedas de presupuesto no afectan el contexto de Claude, lo que reduce el consumo de 200 KB de datos de gastos sin procesar a solo 1 KB de resultados.\n\nLas ganancias de eficiencia son sustanciales:\n\n- Ahorro de tokens: al mantener los resultados intermedios fuera del contexto de Claude, PTC reduce drásticamente el consumo de tokens.El uso promedio cayó de 43.588 a 27.297 tokens, una reducción del 37% en tareas de investigación complejas.\n\n- Latencia reducida: cada ida y vuelta de API requiere inferencia del modelo (cientos de milisegundos a segundos).Cuando Claude organiza más de 20 llamadas a herramientas en un solo bloque de código, elimina más de 19 pases de inferencia.La API maneja la ejecución de la herramienta sin volver al modelo cada vez.\n\n- Precisión mejorada: al escribir una lógica de orquestación explícita, Claude comete menos errores que cuando hace malabarismos con los resultados de varias herramientas en lenguaje natural.La recuperación interna de conocimientos mejoró del 25,6% al 28,5%;Los puntos de referencia del GIA pasaron del 46,5% al ​​51,2%.\n\nLos flujos de trabajo de producción implican datos desordenados, lógica condicional y operaciones que deben escalarse.La llamada a herramientas programáticas le permite a Claude manejar esa complejidad mediante programación mientras mantiene su enfoque en resultados procesables en lugar del procesamiento de datos sin procesar.\n\nCómo funciona la llamada a herramientas programáticas\n\n1. Marcar herramientas como invocables desde el código\n\nAgregue code_execution a las herramientas y configure Allow_callers para que opten por herramientas para la ejecución programática: ```\n{\n\"herramientas\": [\n{\n\"tipo\": \"code_execution_20250825\",\n\"nombre\": \"código_ejecución\"\n},\n{\n\"nombre\": \"get_team_members\",\n\"description\": \"Obtener todos los miembros de un departamento...\",\n\"esquema_entrada\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # optar por la llamada a herramientas programáticas\n},\n{\n\"nombre\": \"obtener_gastos\",\n...\n},\n{\n\"nombre\": \"obtener_presupuesto_por_nivel\",\n...\n}\n]\n}\n```\n\nLa API convierte estas definiciones de herramientas en funciones de Python que Claude puede llamar.\n\n2. Claude escribe código de orquestación\n\nEn lugar de solicitar herramientas una por una, Claude genera código Python:\n\n```\n{\n\"tipo\": \"server_tool_use\",\n\"id\": \"srvtoolu_abc\",\n\"nombre\": \"código_ejecución\",\n\"entrada\": {\n\"code\": \"team = get_team_members('ingeniería')\\n...\" # el ejemplo de código anterior\n}\n}\n```\n\n3. Las herramientas se ejecutan sin afectar el contexto de Claude\n\nCuando el código llama a get_expenses(), recibe una solicitud de herramienta con un campo de llamada:\n\n```\n{\n\"tipo\": \"uso_herramienta\",\n\"id\": \"toolu_xyz\",\n\"nombre\": \"obtener_gastos\",\n\"input\": {\"user_id\": \"emp_123\", \"trimestre\": \"Q3\"},\n\"persona que llama\": {\n\"tipo\": \"code_execution_20250825\",\n\"tool_id\": \"srvtoolu_abc\"\n}\n}\n```\n\nUsted proporciona el resultado, que se procesa en el entorno de ejecución de código en lugar del contexto de Claude.Este ciclo de solicitud-respuesta se repite para cada llamada a herramienta en el código.\n\n4. Sólo el resultado final entra en contexto\n\nCuando el código termina de ejecutarse, solo se devuelven a Claude los resultados del código:\n\n```\n{\n\"tipo\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"contenido\": {\n\"stdout\": \"[{\\\"nombre\\\": \\\"Alice\\\", \\\"gastado\\\": 12500, \\\"límite\\\": 10000}....]\"\n}\n}\n```\n\nEsto es todo lo que ve Claude, no las más de 2000 partidas de gastos procesadas en el camino.\n\nCuándo utilizar las llamadas a herramientas programáticas\n\nLa llamada a herramientas programáticas agrega un paso de ejecución de código a su flujo de trabajo.Esta sobrecarga adicional vale la pena cuando el ahorro de tokens, las mejoras de latencia y las ganancias en precisión son sustanciales.\n\nMás beneficioso cuando:\n\n- Procesamiento de grandes conjuntos de datos donde solo se necesitan agregados o resúmenes\n\n- Ejecutar flujos de trabajo de varios pasos con tres o más llamadas de herramientas dependientes\n\n- Filtrar, ordenar o transformar los resultados de las herramientas antes de que Claude los vea.\n\n- Manejar tareas donde los datos intermedios no deberían influir en el razonamiento de Claude.\n\n- Ejecutar operaciones paralelas en muchos elementos (comprobar 50 puntos finales, por ejemplo)\n\nMenos beneficioso cuando:\n\n- Realizar invocaciones simples con una sola herramienta.\n\n- Trabajar en tareas donde Claude debería ver y razonar sobre todos los resultados intermedios.\n\n- Realizar búsquedas rápidas con pequeñas respuestas.\n\nEjemplos de uso de herramientas\n\nEl desafío\n\nJSON Schema se destaca en la definición de tipos de estructuras, campos obligatorios, enumeraciones permitidas, pero no puede expresar patrones de uso: cuándo incluir parámetros opcionales, qué combinaciones tienen sentido o qué convenciones espera su API.\n\nConsidere una API de ticket de soporte:\n\n```\n{\n\"nombre\": \"create_ticket\",\n\"esquema_entrada\": {\n\"propiedades\": {\n\"título\": {\"tipo\": \"cadena\"},\n\"prioridad\": {\"enum\": [\"baja\", \"media\", \"alta\", \"crítica\"]},\n\"etiquetas\": {\"tipo\": \"matriz\", \"elementos\": {\"tipo\": \"cadena\"}},\n\"reportero\": {\n\"tipo\": \"objeto\",\n\"propiedades\": {\n\"id\": {\"tipo\": \"cadena\"},\n\"nombre\": {\"tipo\": \"cadena\"},\n\"contacto\": {\n\"tipo\": \"objeto\",\n\"propiedades\": {\n\"correo electrónico\": {\"tipo\": \"cadena\"},\n\"teléfono\": {\"tipo\": \"cadena\"}\n}\n}\n}\n},\n\"fecha_de vencimiento\": {\"tipo\": \"cadena\"},\n\"escalada\": {\n\"tipo\": \"objeto\",\n\"propiedades\": {\n\"nivel\": {\"tipo\": \"entero\"},\n\"notify_manager\": {\"tipo\": \"booleano\"},\n\"sla_hours\": {\"tipo\": \"entero\"}\n}\n}\n},\n\"requerido\": [\"título\"]\n}\n}\n```\n\nEl esquema define lo que es válido, pero deja preguntas críticas sin respuesta:\n\n- Ambigüedad de formato: ¿la fecha de vencimiento debería usar \"2024-11-06\", \"6 de noviembre de 2024\" o \"2024-11-06T00:00:00Z\"?\n\n- Convenciones de identificación: ¿reporter.id es un UUID, \"USR-12345\" o simplemente \"12345\"?\n\n- Uso de estructura anidada: ¿Cuándo debería Claude completar reporter.contact?\n\n- Correlaciones de parámetros: ¿Cómo se relacionan escalation.level y escalation.sla_hours con la prioridad?\n\nEstas ambigüedades pueden provocar llamadas a herramientas con formato incorrecto y un uso inconsistente de parámetros.\n\nNuestra solución\n\nLos ejemplos de uso de herramientas le permiten proporcionar llamadas de herramientas de muestra directamente en sus definiciones de herramientas.En lugar de confiar únicamente en el esquema, le muestra a Claude patrones de uso concretos: ```\n{\n\"nombre\": \"create_ticket\",\n\"input_schema\": { /* mismo esquema que el anterior */ },\n\"ejemplos_entrada\": [\n{\n\"title\": \"La página de inicio de sesión devuelve un error 500\",\n\"prioridad\": \"crítica\",\n\"etiquetas\": [\"error\", \"autenticación\", \"producción\"],\n\"reportero\": {\n\"identificación\": \"USR-12345\",\n\"nombre\": \"Jane Smith\",\n\"contacto\": {\n\"correo electrónico\": \"jane@acme.com\",\n\"teléfono\": \"+1-555-0123\"\n}\n},\n\"fecha_de vencimiento\": \"2024-11-06\",\n\"escalada\": {\n\"nivel\": 2,\n\"notify_manager\": verdadero,\n\"horas_sla\": 4\n}\n},\n{\n\"title\": \"Añadir compatibilidad con el modo oscuro\",\n\"etiquetas\": [\"solicitud de función\", \"ui\"],\n\"reportero\": {\n\"identificación\": \"USR-67890\",\n\"nombre\": \"Alex Chen\"\n}\n},\n{\n\"title\": \"Actualizar la documentación de la API\"\n}\n]\n}\n```\n\nDe estos tres ejemplos, Claude aprende:\n\n- Convenciones de formato: las fechas usan AAAA-MM-DD, los ID de usuario siguen USR-XXXXX, las etiquetas usan kebab-case\n\n- Patrones de estructura anidada: cómo construir el objeto reportero con su objeto de contacto anidado\n\n- Correlaciones de parámetros opcionales: los errores críticos tienen información de contacto completa + escalamiento con SLA estrictos;las solicitudes de funciones tienen reportero pero no contacto/escalada;Las tareas internas solo tienen título.\n\nEn nuestras propias pruebas internas, los ejemplos de uso de herramientas mejoraron la precisión del 72 % al 90 % en el manejo de parámetros complejos.\n\nCuándo utilizar ejemplos de uso de herramientas\n\nLos ejemplos de uso de herramientas agregan tokens a las definiciones de herramientas, por lo que son más valiosos cuando las mejoras en la precisión superan el costo adicional.\n\nMás beneficioso cuando:\n\n- Estructuras anidadas complejas donde JSON válido no implica un uso correcto\n\n- Las herramientas con muchos parámetros opcionales y patrones de inclusión son importantes\n\n- API con convenciones específicas de dominio no capturadas en esquemas\n\n- Herramientas similares donde los ejemplos aclaran cuál usar (por ejemplo, create_ticket vs create_incident)\n\nMenos beneficioso cuando:\n\n- Herramientas simples de un solo parámetro con uso obvio\n\n- Formatos estándar como URL o correos electrónicos que Claude ya comprende.\n\n- Los problemas de validación se manejan mejor mediante restricciones del esquema JSON.\n\nMejores prácticas\n\nCrear agentes que tomen acciones en el mundo real significa manejar la escala, la complejidad y la precisión simultáneamente.Estas tres características trabajan juntas para resolver diferentes cuellos de botella en los flujos de trabajo de uso de herramientas.A continuación se explica cómo combinarlos de forma eficaz.\n\nCapa de características estratégicamente\n\nNo todos los agentes necesitan utilizar las tres funciones para una tarea determinada.Comience con su mayor cuello de botella:\n\n- Inflación de contexto debido a las definiciones de herramientas Herramienta de búsqueda\n\n- Grandes resultados intermedios contaminan el contexto Llamada a herramientas programáticas\n\n- Errores de parámetros y llamadas con formato incorrecto. Ejemplos de uso de herramientas.\n\nEste enfoque enfocado le permite abordar la restricción específica que limita el desempeño de su agente, en lugar de agregar complejidad desde el principio.\n\nLuego, coloque capas de funciones adicionales según sea necesario.Son complementarios: la herramienta de búsqueda de herramientas garantiza que se encuentren las herramientas adecuadas, la llamada a herramientas programáticas garantiza una ejecución eficiente y los ejemplos de uso de herramientas garantizan una invocación correcta.\n\nConfigure la herramienta de búsqueda para un mejor descubrimiento\n\nLa búsqueda de herramientas coincide con nombres y descripciones, por lo que las definiciones claras y descriptivas mejoran la precisión del descubrimiento.\n\n```\n// Bueno\n{\n\"nombre\": \"search_customer_orders\",\n\"description\": \"Busca pedidos de clientes por rango de fechas, estado o monto total. Devuelve detalles del pedido, incluidos artículos, envío e información de pago.\"\n}\n\n// Malo\n{\n\"nombre\": \"query_db_orders\",\n\"description\": \"Ejecutar consulta de orden\"\n}\n```\n\nAgregue una guía rápida del sistema para que Claude sepa qué está disponible:\n\n```\nTienes acceso a herramientas de mensajería de Slack, gestión de archivos de Google Drive,\nSeguimiento de tickets de Jira y operaciones de repositorio de GitHub.Utilice la herramienta de búsqueda\npara encontrar capacidades específicas.\n```\n\nMantenga siempre cargadas sus tres a cinco herramientas más utilizadas, posponga el resto.Esto equilibra el acceso inmediato para operaciones comunes con el descubrimiento bajo demanda para todo lo demás.\n\nConfigurar llamadas a herramientas programáticas para una ejecución correcta\n\nDado que Claude escribe código para analizar los resultados de las herramientas, los formatos de devolución del documento se muestran claramente.Esto ayuda a Claude a escribir la lógica de análisis correcta: ```\n{\n\"nombre\": \"obtener_pedidos\",\n\"description\": \"Recuperar pedidos de un cliente.\nDevoluciones:\nLista de objetos de pedido, cada uno de los cuales contiene:\n- id (cadena): identificador de pedido\n- total (flotante): total del pedido en USD\n- estado (cadena): uno de 'pendiente', 'enviado', 'entregado'\n- artículos (lista): conjunto de {sku, cantidad, precio}\n- creado_at (cadena): marca de tiempo ISO 8601\"\n}\n```\n\nConsulte a continuación las herramientas de suscripción que se benefician de la orquestación programática:\n\n- Herramientas que pueden ejecutarse en paralelo (operaciones independientes)\n\n- Operaciones seguras para reintentar (idempotente)\n\nConfigurar ejemplos de uso de herramientas para la precisión de los parámetros\n\nEjemplos de manualidades para lograr claridad conductual:\n\n- Utilice datos realistas (nombres reales de ciudades, precios plausibles, no \"cadenas\" ni \"valores\")\n\n- Muestre variedad con patrones de especificación mínima, parcial y completa.\n\n- Sea conciso: de 1 a 5 ejemplos por herramienta\n\n- Centrarse en la ambigüedad (solo agregue ejemplos donde el uso correcto no sea obvio en el esquema)\n\nEmpezando\n\nEstas funciones están disponibles en versión beta.Para habilitarlos, agregue el encabezado beta e incluya las herramientas que necesita:\n\n```\ncliente.beta.mensajes.create(\nbetas=[\"uso-de-herramientas-avanzada-2025-11-20\"],\nmodelo=\"claude-sonnet-4-5-20250929\",\ntokens_max=4096,\nherramientas=[\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nombre\": \"tool_search_tool_regex\"},\n{\"tipo\": \"code_execution_20250825\", \"nombre\": \"code_execution\"},\n# Tus herramientas con defer_loading, Allow_callers y input_examples\n]\n)\n```\n\nPara obtener documentación API detallada y ejemplos de SDK, consulte nuestro:\n\n- Documentación y libro de cocina para la herramienta de búsqueda de herramientas.\n\n- Documentación y libro de recetas para llamadas de herramientas programáticas\n\n- Documentación para ejemplos de uso de herramientas.\n\nEstas características hacen que el uso de herramientas pase de una simple llamada de función a una orquestación inteligente.A medida que los agentes abordan flujos de trabajo más complejos que abarcan docenas de herramientas y grandes conjuntos de datos, el descubrimiento dinámico, la ejecución eficiente y la invocación confiable se vuelven fundamentales.\n\nEstamos emocionados de ver lo que construyes.\n\nAgradecimientos\n\nEscrito por Bin Wu, con contribuciones de Adam Jones, Artur Renault, Henry Tay, Jake Noble, Nathan McCandlish, Noah Picard, Sam Jiang y el equipo de Claude Developer Platform.Este trabajo se basa en la investigación fundamental de Chris Gorgolewski, Daniel Jiang, Jeremy Fox y Mike Lambert.También nos inspiramos en todo el ecosistema de IA, incluido LLMVM de Joel Pobar, Code Mode de Cloudflare y Code Execution como MCP.Un agradecimiento especial a Andy Schumeister, Hamish Kerr, Keir Bradwell, Matt Bleifer y Molly Vorwerck por su apoyo.",
        "edited": false
      },
      "ukr": {
        "title": "Представляємо розширене використання інструментів на платформі Claude Developer Platform",
        "content": "Майбутнє агентів штучного інтелекту — це те, де моделі безперебійно працюватимуть із сотнями чи тисячами інструментів.Помічник IDE, який інтегрує операції git, маніпуляції з файлами, менеджери пакетів, інфраструктури тестування та конвеєри розгортання.Операційний координатор, який одночасно з’єднує Slack, GitHub, Google Drive, Jira, бази даних компанії та десятки серверів MCP.\n\nЩоб створювати ефективні агенти, їм потрібно працювати з необмеженими бібліотеками інструментів, не вставляючи кожне визначення в контекст заздалегідь.У нашій статті в блозі про використання коду за допомогою MCP обговорювалося, як результати інструментів і визначення іноді можуть споживати понад 50 000 токенів, перш ніж агент прочитає запит.Агенти повинні знаходити та завантажувати інструменти на вимогу, зберігаючи лише те, що стосується поточного завдання.\n\nАгентам також потрібна можливість викликати інструменти з коду.Під час використання інструментів виклику природної мови для кожного виклику потрібен повний перехід висновку, а проміжні результати накопичуються в контексті незалежно від того, корисні вони чи ні.Код природно підходить для логіки оркестровки, такої як цикли, умови та перетворення даних.Агентам потрібна гнучкість для вибору між виконанням коду та висновком на основі поставленого завдання.\n\nАгентам також необхідно навчитися правильному використанню інструментів на прикладах, а не лише на визначеннях схем.Схеми JSON визначають, що є структурно дійсним, але не можуть виражати шаблони використання: коли включати додаткові параметри, які комбінації мають сенс або які умовності очікує ваш API.\n\nСьогодні ми випускаємо три функції, які роблять це можливим:\n\n- Інструмент пошуку інструментів, який дозволяє Клоду використовувати інструменти пошуку для доступу до тисяч інструментів, не споживаючи контекстне вікно\n\n- Programmatic Tool Calling , що дозволяє Клоду викликати інструменти в середовищі виконання коду, зменшуючи вплив на контекстне вікно моделі\n\n- Приклади використання інструментів, які надають універсальний стандарт для демонстрації того, як ефективно використовувати певний інструмент\n\nПід час внутрішнього тестування ми виявили, що ці функції допомогли нам створювати речі, які були б неможливі за стандартних моделей використання інструментів.Наприклад, Claude для Excel використовує Programmatic Tool Calling, щоб читати та змінювати електронні таблиці з тисячами рядків, не перевантажуючи контекстне вікно моделі.\n\nВиходячи з нашого досвіду, ми вважаємо, що ці функції відкривають нові можливості для того, що ви можете створити з Claude.\n\nІнструмент пошуку інструментів\n\nВиклик\n\nВизначення інструментів MCP надають важливий контекст, але в міру того, як підключається більше серверів, ці маркери можуть додаватися.Розглянемо налаштування з п’яти серверів:\n\n- GitHub: 35 інструментів (~26 тис. токенів)\n\n- Slack: 11 інструментів (~21 тис. токенів)\n\n- Вартовий: 5 інструментів (~3K жетонів)\n\n- Grafana: 5 інструментів (~3K жетонів)\n\n- Splunk: 2 інструменти (~2K жетонів)\n\nЦе 58 інструментів, які споживають приблизно 55 тисяч токенів ще до початку розмови.Додайте більше серверів, таких як Jira (який використовує ~17 тисяч токенів), і ви швидко наблизитеся до понад 100 тисяч токенів.У Anthropic ми бачили, що визначення інструментів споживають 134 тисячі токенів до оптимізації.\n\nАле вартість жетонів — не єдина проблема.Найпоширенішими помилками є неправильний вибір інструменту та неправильні параметри, особливо коли інструменти мають схожі назви, як-от notification-send-user або notification-send-channel.\n\nНаше рішення\n\nЗамість того, щоб завантажувати всі визначення інструментів заздалегідь, Інструмент пошуку інструментів знаходить інструменти за вимогою.Клод бачить лише ті інструменти, які дійсно потрібні для виконання поточного завдання.\n\n[[IMAGE_1|Інструмент пошуку інструментів зберігає 191 300 токенів контексту порівняно з 122 800 у традиційному підході Клода.]]\n\nТрадиційний підхід:\n\n- Усі визначення інструментів завантажуються заздалегідь (~72K маркерів для 50+ інструментів MCP)\n\n- Історія розмов і системна підказка змагаються за місце, що залишилося\n\n- Загальне споживання контексту: ~77 тисяч токенів до початку будь-якої роботи\n\nЗа допомогою інструменту пошуку інструментів:\n\n- Тільки інструмент пошуку інструментів завантажується заздалегідь (~500 токенів)\n\n- Інструменти, виявлені за потребою (3-5 відповідних інструментів, ~3K маркерів)\n\n- Загальне споживання контексту: ~8,7 тис. токенів, зберігаючи 95% вікна контексту\n\nЦе означає зменшення використання маркерів на 85%, зберігаючи доступ до повної бібліотеки інструментів.Внутрішнє тестування показало значне підвищення точності оцінок MCP під час роботи з великими бібліотеками інструментів.Opus 4 покращився з 49% до 74%, а Opus 4.5 покращився з 79,5% до 88,1% з увімкненим інструментом пошуку інструментів.\n\nЯк працює інструмент пошуку інструментів Інструмент пошуку інструментів дозволяє Клоду динамічно знаходити інструменти замість того, щоб завантажувати всі визначення заздалегідь.Ви надаєте всі свої визначення інструментів API, але позначаєте інструменти за допомогою defer_loading: true, щоб зробити їх доступними за запитом.Відкладені інструменти спочатку не завантажуються в контекст Клода.Клод бачить лише сам інструмент пошуку інструментів, а також будь-які інструменти з defer_loading: false (ваші найважливіші інструменти, які часто використовуються).\n\nКоли Клоду потрібні певні можливості, він шукає відповідні інструменти.Інструмент пошуку інструментів повертає посилання на відповідні інструменти, які розширюються до повних визначень у контексті Клода.\n\nНаприклад, якщо Клоду потрібно взаємодіяти з GitHub, він шукає «github», і завантажуються лише github.createPullRequest і github.listIssues, а не інші понад 50 ваших інструментів із Slack, Jira та Google Drive.\n\nТаким чином, Клод отримує доступ до вашої повної бібліотеки інструментів, сплачуючи лише символічну вартість інструментів, які йому дійсно потрібні.\n\nПримітка щодо кешування підказок: Інструмент пошуку інструментів не порушує кешування підказок, оскільки відкладені інструменти повністю виключаються з початкової підказки.Вони додаються до контексту лише після того, як Клод їх шукає, тому ваші системні підказки та визначення основних інструментів залишаються кешованими.\n\nРеалізація:\n\n```\n{\n\"інструменти\": [\n// Включаємо інструмент пошуку інструментів (регулярний вираз, BM25 або спеціальний)\n{\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n\n// Позначити інструменти для виявлення на вимогу\n{\n\"ім'я\": \"github.createPullRequest\",\n\"description\": \"Створити запит на отримання\",\n\"вхідна_схема\": {...},\n\"defer_loading\": правда\n}\n// ... ще сотні відкладених інструментів із defer_loading: true\n]\n}\n```\n\nДля серверів MCP ви можете відкласти завантаження цілих серверів, залишаючи завантаженими певні інструменти, які часто використовуються:\n\n```\n{\n\"тип\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-диск\",\n\"default_config\": {\"defer_loading\": true}, # відкласти завантаження всього сервера\n\"конфігурації\": {\n\"пошук_файлів\": {\n\"defer_loading\": false\n} // Тримайте завантаженим інструмент, який найчастіше використовується\n}\n}\n```\n\nПлатформа Claude Developer Platform надає інструменти пошуку на основі регулярних виразів і BM25 із коробки, але ви також можете реалізувати спеціальні інструменти пошуку за допомогою вбудовування або інших стратегій.\n\nКоли використовувати інструмент пошуку інструментів\n\nЯк і будь-яке архітектурне рішення, увімкнення інструменту пошуку інструментів передбачає компроміси.Ця функція додає крок пошуку перед викликом інструменту, тому забезпечує найкращу рентабельність інвестицій, коли економія контексту та покращення точності переважують додаткову затримку.\n\nВикористовуйте його, коли:\n\n- Визначення інструментів, що споживають >10K токенів\n\n- Проблеми з точністю вибору інструменту\n\n- Створення систем на базі MCP з кількома серверами\n\n- доступні 10+ інструментів\n\nМенш корисно, коли:\n\n- Невелика бібліотека інструментів (<10 інструментів)\n\n- Усі інструменти, які часто використовуються під час кожного сеансу\n\n- Визначення інструментів є компактними\n\nПрограмний виклик інструментів\n\nВиклик\n\nТрадиційний виклик інструментів створює дві фундаментальні проблеми, оскільки робочі процеси стають складнішими:\n\n- Забруднення контексту проміжними результатами: коли Клод аналізує 10-мегабайтний файл журналу на предмет шаблонів помилок, увесь файл потрапляє у вікно контексту, навіть якщо Клоду потрібен лише підсумок частоти помилок.Під час отримання даних клієнтів у кількох таблицях кожен запис накопичується в контексті незалежно від релевантності.Ці проміжні результати споживають значні бюджети токенів і можуть повністю витіснити важливу інформацію з вікна контексту.\n\n- Накладні витрати на логічний висновок і ручний синтез: для кожного виклику інструмента потрібен повний проход логічного висновку моделі.Отримавши результати, Клод повинен «оглядати» дані, щоб отримати релевантну інформацію, міркувати про те, як частини поєднуються разом, і вирішити, що робити далі — і все це за допомогою обробки природної мови.Робочий процес із п’ятьма інструментами означає п’ять проходів висновків плюс Клод аналізує кожен результат, порівнює значення та синтезує висновки.Це повільно і схильне до помилок.\n\nНаше рішення\n\nПрограмний виклик інструментів дає змогу Клоду оркеструвати інструменти за допомогою коду, а не за допомогою окремих двосторонніх звернень API.Замість того, щоб Клод запитував інструменти по одному, повертаючи кожен результат до свого контексту, Клод пише код, який викликає кілька інструментів, обробляє їхні виходи та контролює, яка інформація фактично надходить у контекстне вікно. Клод чудово вміє писати код, і дозволяючи йому виражати логіку оркестровки в Python, а не через виклики інструментів природною мовою, ви отримуєте більш надійний і точний потік керування.Цикли, умови, перетворення даних і обробка помилок — усе це явно виражено в коді, а не приховано в міркуваннях Клода.\n\nПриклад: перевірка відповідності бюджету\n\nРозглянемо звичайне бізнес-завдання: «Хто з членів команди перевищив свій бюджет на відрядження за 3-й квартал?»\n\nУ вас є три інструменти:\n\n- get_team_members(department) - Повертає список членів команди з ідентифікаторами та рівнями\n\n- get_expenses(user_id, quarter) - Повертає позиції витрат для користувача\n\n- get_budget_by_level(level) - Повертає обмеження бюджету для рівня співробітника\n\nТрадиційний підхід:\n\n- Зберіть членів команди 20 осіб\n\n- Для кожної особи отримайте її витрати за 3 квартал 20 викликів інструментів, кожен повертає 50-100 рядків (авіаквитки, готелі, харчування, квитанції)\n\n- Отримайте обмеження бюджету за рівнем співробітника\n\n- Усе це входить у контекст Клода: понад 2000 статей витрат (50 КБ+)\n\n- Клод вручну підсумовує витрати кожної людини, шукає їхній бюджет, порівнює витрати з обмеженнями бюджету\n\n- Більше поворотів до моделі, значне споживання контексту\n\nЗ програмним викликом інструменту:\n\nЗамість того, щоб кожен результат інструменту повертався до Клода, Клод пише сценарій Python, який організовує весь робочий процес.Сценарій виконується в інструменті виконання коду (ізольоване середовище), призупиняючись, коли потрібні результати ваших інструментів.Коли ви повертаєте результати інструменту через API, вони обробляються сценарієм, а не споживаються моделлю.Сценарій продовжує виконуватися, і Клод бачить лише кінцевий результат.\n\n[[IMAGE_2|Програмний виклик інструментів дає змогу Клоду оркеструвати інструменти за допомогою коду, а не за допомогою окремих циклів API, що забезпечує паралельне виконання інструментів.]]\n\nОсь як виглядає оркестровий код Клода для завдання відповідності бюджету:\n\n```\nteam = await get_team_members(\"розробка\")\n\n# Отримати бюджети для кожного унікального рівня\nlevels = list(set(m[\"level\"] for m in team))\nbudget_results = await asyncio.gather(*[\nget_budget_by_level(level) для рівня в рівнях\n])\n\n# Створіть пошуковий словник: {\"молодший\": бюджет1, \"старший\": бюджет2, ...}\nбюджети = {рівень: бюджет для рівня, бюджет у zip(рівні, бюджет_результати)}\n\n# Отримати всі витрати паралельно\nвитрати = очікувати asyncio.gather(*[\nget_expenses(m[\"id\"], \"Q3\") для m у команді\n])\n\n# Знайдіть співробітників, які перевищили свій бюджет на відрядження\nперевищено = []\nдля члена, досвіду в zip(команда, витрати):\nбюджет = бюджети[учасник[\"рівень\"]]\ntotal = sum(e[\"amount\"] for e in exp)\nif total > budget[\"travel_limit\"]:\nперевищено.append({\n\"ім'я\": учасник[\"ім'я\"],\n\"витрачено\": всього,\n\"limit\": бюджет[\"travel_limit\"]\n})\n\nprint(json.dumps(exceeded))\n```\n\nКонтекст Клода отримує лише кінцевий результат: двоє-троє людей, які перевищили свій бюджет.Понад 2000 рядків-позицій, проміжні суми та пошук бюджету не впливають на контекст Клода, зменшуючи споживання з 200 КБ необроблених даних про витрати до лише 1 КБ результатів.\n\nПідвищення ефективності є значним:\n\n- Економія токенів: зберігаючи проміжні результати поза контекстом Клода, PTC значно зменшує споживання токенів.Середнє використання впало з 43 588 до 27 297 токенів, що на 37% менше для складних дослідницьких завдань.\n\n- Зменшена затримка: для кожного зворотного проходження API потрібне визначення моделі (від сотень мілісекунд до секунд).Коли Клод організовує понад 20 викликів інструментів в одному блоці коду, ви виключаєте 19+ проходів висновку.API обробляє виконання інструменту, не повертаючись кожного разу до моделі.\n\n- Покращена точність: створюючи чітку логіку оркестровки, Клод робить менше помилок, ніж під час жонглювання результатами кількох інструментів природною мовою.Внутрішній пошук знань покращився з 25,6% до 28,5%;Орієнтовні показники GIA з 46,5% до 51,2%.\n\nВиробничі робочі процеси містять безладні дані, умовну логіку та операції, які потребують масштабування.Programmatic Tool Calling дозволяє Claude впоратися з цією складністю програмним шляхом, зосереджуючись на ефективних результатах, а не на обробці необроблених даних.\n\nЯк працює Programmatic Tool Calling\n\n1. Позначте інструменти як викликані з коду\n\nДодайте code_execution до інструментів і встановіть allowed_callers для підключення інструментів для програмного виконання: ```\n{\n\"інструменти\": [\n{\n\"type\": \"code_execution_20250825\",\n\"ім'я\": \"виконання_коду\"\n},\n{\n\"name\": \"get_team_members\",\n\"description\": \"Отримати всіх членів відділу...\",\n\"вхідна_схема\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # підключення до програмного виклику інструменту\n},\n{\n\"name\": \"get_expenses\",\n...\n},\n{\n\"name\": \"get_budget_by_level\",\n...\n}\n]\n}\n```\n\nAPI перетворює ці визначення інструментів у функції Python, які може викликати Клод.\n\n2. Клод пише код оркестровки\n\nЗамість того, щоб запитувати інструменти по одному, Клод генерує код Python:\n\n```\n{\n\"type\": \"server_tool_use\",\n\"id\": \"srvtoolu_abc\",\n\"ім'я\": \"виконання_коду\",\n\"вхід\": {\n\"code\": \"team = get_team_members('engineering')\\n...\" # приклад коду вище\n}\n}\n```\n\n3. Інструменти виконуються, не зачіпаючи контекст Клода\n\nКоли код викликає get_expenses(), ви отримуєте запит інструменту з полем виклику:\n\n```\n{\n\"type\": \"tool_use\",\n\"id\": \"toolu_xyz\",\n\"name\": \"get_expenses\",\n\"input\": {\"user_id\": \"emp_123\", \"quarter\": \"Q3\"},\n\"дзвінок\": {\n\"type\": \"code_execution_20250825\",\n\"tool_id\": \"srvtoolu_abc\"\n}\n}\n```\n\nВи надаєте результат, який обробляється в середовищі виконання коду, а не в контексті Клода.Цей цикл запит-відповідь повторюється для кожного виклику інструменту в коді.\n\n4. Лише остаточний результат входить у контекст\n\nКоли код завершує роботу, Клоду повертаються лише результати коду:\n\n```\n{\n\"type\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"вміст\": {\n\"stdout\": \"[{\\\"ім'я\\\": \\\"Аліса\\\", \\\"витрачено\\\": 12500, \\\"ліміт\\\": 10000}...]\"\n}\n}\n```\n\nЦе все, що бачить Клод, а не понад 2000 статей витрат, оброблених на цьому шляху.\n\nКоли використовувати Programmatic Tool Calling\n\nProgrammatic Tool Calling додає крок виконання коду до вашого робочого процесу.Ці додаткові накладні витрати окупаються, коли економія маркерів, покращення затримки та підвищення точності є значними.\n\nНайбільш корисно, коли:\n\n- Обробка великих наборів даних, де вам потрібні лише агрегати або підсумки\n\n- Запуск багатоетапних робочих процесів із трьома або більше залежними викликами інструментів\n\n- Фільтрування, сортування або трансформація результатів інструментів до того, як їх побачить Клод\n\n- Виконання завдань, де проміжні дані не повинні впливати на міркування Клода\n\n- Виконання паралельних операцій з багатьма елементами (перевірка 50 кінцевих точок, наприклад)\n\nМенш корисно, коли:\n\n— Виконання простих викликів одним інструментом\n\n- Робота над завданнями, де Клод повинен бачити та міркувати про всі проміжні результати\n\n- Запуск швидкого пошуку з невеликими відповідями\n\nПриклади використання інструментів\n\nВиклик\n\nСхема JSON відмінно справляється з визначенням структурних типів, обов’язкових полів, дозволених переліків, але вона не може виражати шаблони використання: коли включати додаткові параметри, які комбінації мають сенс або які умовності очікує ваш API.\n\nРозглянемо API квитка підтримки:\n\n```\n{\n\"name\": \"create_ticket\",\n\"вхідна_схема\": {\n\"властивості\": {\n\"title\": {\"type\": \"string\"},\n\"priority\": {\"enum\": [\"низький\", \"середній\", \"високий\", \"критичний\"]},\n\"labels\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n\"репортер\": {\n\"type\": \"об'єкт\",\n\"властивості\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"контакт\": {\n\"type\": \"об'єкт\",\n\"властивості\": {\n\"email\": {\"type\": \"string\"},\n\"телефон\": {\"тип\": \"рядок\"}\n}\n}\n}\n},\n\"due_date\": {\"type\": \"string\"},\n\"ескалація\": {\n\"type\": \"об'єкт\",\n\"властивості\": {\n\"level\": {\"type\": \"integer\"},\n\"notify_manager\": {\"type\": \"boolean\"},\n\"sla_hours\": {\"type\": \"integer\"}\n}\n}\n},\n\"обов'язково\": [\"назва\"]\n}\n}\n```\n\nСхема визначає, що є дійсним, але залишає критичні запитання без відповіді:\n\n- Неоднозначність формату: чи має термін_виконання використовувати \"2024-11-06\", \"Nov 6, 2024\" або \"2024-11-06T00:00:00Z\"?\n\n- Умовні позначення ідентифікаторів: reporter.id є UUID, \"USR-12345\" чи просто \"12345\"?\n\n- Використання вкладеної структури: коли Клод повинен заповнити reporter.contact ?\n\n- Кореляції параметрів: як escalation.level і escalation.sla_hours пов’язані з пріоритетом?\n\nЦі неоднозначності можуть призвести до неправильно сформованих викликів інструментів і непослідовного використання параметрів.\n\nНаше рішення\n\nПриклади використання інструментів дозволяють надати зразки викликів інструментів безпосередньо у визначеннях інструментів.Замість того, щоб покладатися лише на схему, ви показуєте Клоду конкретні моделі використання: ```\n{\n\"name\": \"create_ticket\",\n\"input_schema\": { /* та сама схема, що й вище */ },\n\"input_examples\": [\n{\n\"title\": \"Сторінка входу повертає помилку 500\",\n\"priority\": \"критичний\",\n\"labels\": [\"bug\", \"authentication\", \"production\"],\n\"репортер\": {\n\"id\": \"USR-12345\",\n\"name\": \"Джейн Сміт\",\n\"контакт\": {\n\"електронна пошта\": \"jane@acme.com\",\n\"телефон\": \"+1-555-0123\"\n}\n},\n\"due_date\": \"2024-11-06\",\n\"ескалація\": {\n\"рівень\": 2,\n\"notify_manager\": правда,\n\"sla_hours\": 4\n}\n},\n{\n\"title\": \"Додати підтримку темного режиму\",\n\"labels\": [\"feature-request\", \"ui\"],\n\"репортер\": {\n\"id\": \"USR-67890\",\n\"ім'я\": \"Алекс Чен\"\n}\n},\n{\n\"title\": \"Оновити документацію API\"\n}\n]\n}\n```\n\nЗ цих трьох прикладів Клод дізнається:\n\n- Умовні позначення формату: у датах використовується РРРР-ММ-ДД, в ідентифікаторах користувачів – USR-XXXXX, у мітках – kebab-case.\n\n- Шаблони вкладеної структури: як побудувати об’єкт звіту з його вкладеним об’єктом контакту\n\n- Необов'язкові кореляції параметрів: критичні помилки мають повну контактну інформацію + ескалацію з жорсткими SLA;запити на функції мають репортера, але не мають контакту/ескалації;внутрішні завдання мають лише назву\n\nПід час нашого власного внутрішнього тестування приклади використання інструментів підвищили точність обробки складних параметрів із 72% до 90%.\n\nКоли використовувати інструмент. Приклади використання\n\nПриклади використання інструментів додають маркери до ваших визначень інструментів, тому вони є найбільш цінними, коли підвищення точності переважує додаткові витрати.\n\nНайбільш корисно, коли:\n\n- Складні вкладені структури, де дійсний JSON не передбачає правильного використання\n\n- Інструменти з багатьма необов'язковими параметрами та шаблонами включення мають значення\n\n- API із специфічними для домену угодами, які не враховані в схемах\n\n- Подібні інструменти, де приклади пояснюють, який з них використовувати (наприклад, create_ticket проти create_incident )\n\nМенш корисно, коли:\n\n- Прості інструменти з одним параметром із очевидним використанням\n\n- Стандартні формати, як-от URL-адреси чи електронні листи, які Клод уже розуміє\n\n- Питання перевірки краще обробляються обмеженнями схеми JSON\n\nКращі практики\n\nСтворення агентів, які виконують дії в реальному світі, означає водночас керування масштабом, складністю та точністю.Ці три функції працюють разом, щоб вирішити різні вузькі місця в робочих процесах використання інструментів.Ось як їх ефективно поєднати.\n\nШар має стратегічні особливості\n\nНе кожен агент повинен використовувати всі три функції для певного завдання.Почніть із найбільшого вузького місця:\n\n— Роздутість контексту з визначень інструментів Інструмент пошуку\n\n- Великі проміжні результати, що забруднюють контекст Програмний виклик інструменту\n\n- Помилки параметрів і некоректні виклики інструментів. Приклади використання\n\nЦей цілеспрямований підхід дає змогу вирішити конкретні обмеження, що обмежують продуктивність вашого агента, а не додавати складності заздалегідь.\n\nПотім за потреби нанесіть додаткові функції.Вони доповнюють один одного: Інструмент пошуку інструментів забезпечує пошук потрібних інструментів, програмний виклик інструментів забезпечує ефективне виконання, а приклади використання інструментів забезпечують правильний виклик.\n\nНалаштуйте інструмент пошуку інструментів для кращого пошуку\n\nПошук інструментів збігається з назвами та описами, тож чіткі описові визначення підвищують точність виявлення.\n\n```\n// Добре\n{\n\"name\": \"search_customer_orders\",\n\"description\": \"Пошук замовлень клієнтів за діапазоном дат, статусом або загальною сумою. Повертає деталі замовлення, включаючи елементи, інформацію про доставку та платіж.\"\n}\n\n// Погано\n{\n\"name\": \"query_db_orders\",\n\"description\": \"Виконати запит замовлення\"\n}\n```\n\nДодайте системні підказки, щоб Клод знав, що доступно:\n\n```\nВи маєте доступ до інструментів для обміну повідомленнями Slack, керування файлами Google Drive,\nВідстеження квитків Jira та операції зі сховищем GitHub.Скористайтеся інструментом пошуку\nщоб знайти конкретні можливості.\n```\n\nТримайте три-п’ять найбільш використовуваних інструментів завжди завантаженими, решту відкладіть.Це врівноважує миттєвий доступ для звичайних операцій із виявленням за вимогою для всього іншого.\n\nНалаштуйте Programmatic Tool Calling для правильного виконання\n\nОскільки Клод пише код для аналізу вихідних даних інструменту, чіткі формати повернення документа.Це допомагає Клоду написати правильну логіку аналізу: ```\n{\n\"name\": \"get_orders\",\n\"description\": \"Отримати замовлення для клієнта.\nПовернення:\nСписок об'єктів замовлення, кожен з яких містить:\n- id (str): ідентифікатор замовлення\n- total (float): загальна сума замовлення в доларах США\n- статус (str): один із «очікує», «відправлено», «доставлено»\n- елементи (список): масив {sku, quantity, price}\n- created_at (str): мітка часу ISO 8601\"\n}\n```\n\nНижче наведено інструменти підключення, які виграють від програмної оркестровки:\n\n- Інструменти, які можуть працювати паралельно (незалежні операції)\n\n- Операції, безпечні для повторної спроби (ідемпотентні)\n\nНалаштуйте приклади використання інструменту для точності параметрів\n\nПриклади ремесел для ясності поведінки:\n\n- Використовуйте реалістичні дані (справжні назви міст, правдоподібні ціни, а не \"рядок\" або \"значення\")\n\n- Показуйте різноманітність за допомогою мінімальних, часткових і повних шаблонів специфікацій\n\n- Будьте лаконічними: 1-5 прикладів на інструмент\n\n- Зосередьтеся на двозначності (лише додайте приклади, у яких правильне використання не є очевидним зі схеми)\n\nПочаток роботи\n\nЦі функції доступні в бета-версії.Щоб увімкнути їх, додайте бета-заголовок і включіть необхідні інструменти:\n\n```\nclient.beta.messages.create(\nbetas=[\"advanced-tool-use-2025-11-20\"],\nmodel=\"claude-sonnet-4-5-20250929\",\nmax_tokens=4096,\nінструменти=[\n{\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n{\"type\": \"code_execution_20250825\", \"name\": \"code_execution\"},\n# Ваші інструменти з defer_loading, allowed_callers і input_examples\n]\n)\n```\n\nДетальну документацію API і приклади SDK див.\n\n- Д окументація та кулінарна книга для Інструменту пошуку інструментів\n\n- Документація та кулінарна книга для Programmatic Tool Calling\n\n- Документація для прикладів використання інструментів\n\nЦі функції переміщують використання інструментів від простого виклику функції до інтелектуальної оркестровки.Оскільки агенти вирішують складніші робочі процеси, що охоплюють десятки інструментів і великі набори даних, динамічне виявлення, ефективне виконання та надійний виклик стають основоположними.\n\nМи раді бачити, що ви створюєте.\n\nПодяки\n\nНаписав Бін Ву за участі Адама Джонса, Артура Рено, Генрі Тея, Джейка Нобла, Натана МакКендліша, Ноа Пікарда, Сема Цзяна та команди Claude Developer Platform.Ця робота базується на фундаментальних дослідженнях Кріса Горголевскі, Деніела Цзяна, Джеремі Фокса та Майка Ламберта.Ми також черпали натхнення в екосистемі штучного інтелекту, включаючи LLMVM Джоела Побара, режим коду Cloudflare і виконання коду як MCP.Особлива подяка Енді Шумайстеру, Хемішу Керру, Кіру Бредвеллу, Метту Блейферу та Моллі Форверк за підтримку.",
        "edited": false
      },
      "pt": {
        "title": "Apresentando o uso de ferramentas avançadas na Claude Developer Platform",
        "content": "O futuro dos agentes de IA será aquele em que os modelos funcionarão perfeitamente em centenas ou milhares de ferramentas.Um assistente IDE que integra operações git, manipulação de arquivos, gerenciadores de pacotes, estruturas de teste e pipelines de implantação.Um coordenador de operações que conecta Slack, GitHub, Google Drive, Jira, bancos de dados de empresas e dezenas de servidores MCP simultaneamente.\n\nPara construir agentes eficazes, eles precisam trabalhar com bibliotecas de ferramentas ilimitadas sem colocar todas as definições no contexto antecipadamente.Nosso artigo do blog sobre o uso da execução de código com MCP discutiu como os resultados e definições da ferramenta às vezes podem consumir mais de 50.000 tokens antes que um agente leia uma solicitação.Os agentes devem descobrir e carregar ferramentas sob demanda, mantendo apenas o que for relevante para a tarefa atual.\n\nOs agentes também precisam da capacidade de chamar ferramentas a partir do código.Ao usar a chamada de ferramenta de linguagem natural, cada invocação requer uma passagem de inferência completa e os resultados intermediários se acumulam no contexto, sejam úteis ou não.O código é um ajuste natural para lógica de orquestração, como loops, condicionais e transformações de dados.Os agentes precisam de flexibilidade para escolher entre execução de código e inferência com base na tarefa em questão.\n\nOs agentes também precisam aprender o uso correto da ferramenta a partir de exemplos, não apenas de definições de esquema.Os esquemas JSON definem o que é estruturalmente válido, mas não podem expressar padrões de uso: quando incluir parâmetros opcionais, quais combinações fazem sentido ou quais convenções sua API espera.\n\nHoje, estamos lançando três recursos que tornam isso possível:\n\n- Ferramenta de busca de ferramentas, que permite que Claude use ferramentas de busca para acessar milhares de ferramentas sem consumir sua janela de contexto\n\n- Programmatic Tool Calling, que permite ao Claude invocar ferramentas em um ambiente de execução de código reduzindo o impacto na janela de contexto do modelo\n\n- Exemplos de uso de ferramentas, que fornecem um padrão universal para demonstrar como usar efetivamente uma determinada ferramenta\n\nEm testes internos, descobrimos que esses recursos nos ajudaram a construir coisas que não seriam possíveis com padrões convencionais de uso de ferramentas.Por exemplo, Claude for Excel usa Chamada de Ferramenta Programática para ler e modificar planilhas com milhares de linhas sem sobrecarregar a janela de contexto do modelo.\n\nCom base em nossa experiência, acreditamos que esses recursos abrem novas possibilidades para o que você pode construir com Claude.\n\nFerramenta de pesquisa de ferramentas\n\nO desafio\n\nAs definições da ferramenta MCP fornecem um contexto importante, mas à medida que mais servidores se conectam, esses tokens podem aumentar.Considere uma configuração de cinco servidores:\n\n- GitHub: 35 ferramentas (cerca de 26 mil tokens)\n\n- Slack: 11 ferramentas (~21 mil tokens)\n\n- Sentinela: 5 ferramentas (~3 mil tokens)\n\n- Grafana: 5 ferramentas (~3 mil tokens)\n\n- Splunk: 2 ferramentas (~2 mil tokens)\n\nSão 58 ferramentas consumindo aproximadamente 55 mil tokens antes mesmo de a conversa começar.Adicione mais servidores como o Jira (que sozinho usa aproximadamente 17 mil tokens) e você estará rapidamente se aproximando de mais de 100 mil tokens de sobrecarga.Na Anthropic, vimos definições de ferramentas consumirem 134 mil tokens antes da otimização.\n\nMas o custo do token não é o único problema.As falhas mais comuns são a seleção errada de ferramentas e parâmetros incorretos, especialmente quando as ferramentas têm nomes semelhantes, como notificação-envio-usuário vs.\n\nNossa solução\n\nEm vez de carregar todas as definições de ferramentas antecipadamente, a Ferramenta de pesquisa de ferramentas descobre ferramentas sob demanda.Claude só vê as ferramentas de que realmente precisa para a tarefa atual.\n\n[[IMAGE_1|A ferramenta de pesquisa preserva 191.300 tokens de contexto em comparação com 122.800 com a abordagem tradicional de Claude.]]\n\nAbordagem tradicional:\n\n- Todas as definições de ferramentas carregadas antecipadamente (cerca de 72 mil tokens para mais de 50 ferramentas MCP)\n\n- O histórico de conversas e o prompt do sistema competem pelo espaço restante\n\n- Consumo total de contexto: aproximadamente 77 mil tokens antes do início de qualquer trabalho\n\nCom a ferramenta de pesquisa de ferramentas:\n\n- Somente a ferramenta de pesquisa de ferramentas foi carregada antecipadamente (~500 tokens)\n\n- Ferramentas descobertas sob demanda conforme necessário (3 a 5 ferramentas relevantes, aproximadamente 3 mil tokens)\n\n- Consumo total de contexto: ~8,7 mil tokens, preservando 95% da janela de contexto\n\nIsso representa uma redução de 85% no uso de tokens, mantendo o acesso à sua biblioteca completa de ferramentas.Os testes internos mostraram melhorias significativas na precisão das avaliações do MCP ao trabalhar com grandes bibliotecas de ferramentas.O Opus 4 melhorou de 49% para 74%, e o Opus 4.5 melhorou de 79,5% para 88,1% com a ferramenta de busca de ferramentas habilitada.\n\nComo funciona a ferramenta de pesquisa de ferramentas A ferramenta de pesquisa de ferramentas permite que Claude descubra ferramentas dinamicamente em vez de carregar todas as definições antecipadamente.Você fornece todas as definições de ferramentas para a API, mas marca as ferramentas com defer_loading: true para torná-las detectáveis ​​sob demanda.As ferramentas adiadas não são carregadas inicialmente no contexto de Claude.Claude vê apenas a própria ferramenta de pesquisa de ferramentas e quaisquer ferramentas com defer_loading: false (suas ferramentas mais críticas e usadas com frequência).\n\nQuando Claude precisa de recursos específicos, ele procura ferramentas relevantes.A ferramenta de pesquisa de ferramentas retorna referências a ferramentas correspondentes, que são expandidas em definições completas no contexto de Claude.\n\nPor exemplo, se Claude precisar interagir com o GitHub, ele pesquisará \"github\" e apenas github.createPullRequest e github.listIssues serão carregados, e não suas outras mais de 50 ferramentas do Slack, Jira e Google Drive.\n\nDessa forma, Claude tem acesso à sua biblioteca completa de ferramentas, pagando apenas o custo do token pelas ferramentas de que realmente precisa.\n\nNota sobre cache de prompt: A ferramenta de pesquisa de ferramentas não interrompe o cache de prompt porque as ferramentas adiadas são totalmente excluídas do prompt inicial.Eles só são adicionados ao contexto depois que Claude os procura, para que o prompt do sistema e as definições da ferramenta principal permaneçam armazenáveis ​​em cache.\n\nImplementação:\n\n```\n{\n\"ferramentas\": [\n// Inclui uma ferramenta de busca de ferramentas (regex, BM25 ou customizada)\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nome\": \"tool_search_tool_regex\"},\n\n//Marca ferramentas para descoberta sob demanda\n{\n\"nome\": \"github.createPullRequest\",\n\"description\": \"Criar uma solicitação pull\",\n\"esquema_de entrada\": {...},\n\"defer_loading\": verdadeiro\n}\n// ... mais centenas de ferramentas adiadas com defer_loading: true\n]\n}\n```\n\nPara servidores MCP, você pode adiar o carregamento de servidores inteiros enquanto mantém carregadas ferramentas específicas de alto uso:\n\n```\n{\n\"tipo\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-drive\",\n\"default_config\": {\"defer_loading\": true}, # adia o carregamento de todo o servidor\n\"configurações\": {\n\"arquivos_de_pesquisa\": {\n\"defer_loading\": falso\n} //Mantém a ferramenta mais usada carregada\n}\n}\n```\n\nA Claude Developer Platform fornece ferramentas de pesquisa baseadas em regex e BM25 prontas para uso, mas você também pode implementar ferramentas de pesquisa personalizadas usando embeddings ou outras estratégias.\n\nQuando usar a ferramenta de pesquisa de ferramentas\n\nComo qualquer decisão arquitetônica, habilitar a ferramenta Tool Search envolve compensações.O recurso adiciona uma etapa de pesquisa antes da invocação da ferramenta, proporcionando o melhor ROI quando a economia de contexto e as melhorias na precisão superam a latência adicional.\n\nUse-o quando:\n\n- Definições de ferramentas consumindo >10 mil tokens\n\n- Enfrentando problemas de precisão na seleção de ferramentas\n\n- Construindo sistemas alimentados por MCP com vários servidores\n\n- Mais de 10 ferramentas disponíveis\n\nMenos benéfico quando:\n\n- Pequena biblioteca de ferramentas (<10 ferramentas)\n\n- Todas as ferramentas usadas com frequência em todas as sessões\n\n- As definições de ferramentas são compactas\n\nChamada de ferramenta programática\n\nO desafio\n\nA chamada tradicional de ferramentas cria dois problemas fundamentais à medida que os fluxos de trabalho se tornam mais complexos:\n\n- Poluição de contexto de resultados intermediários: quando Claude analisa um arquivo de log de 10 MB em busca de padrões de erros, o arquivo inteiro entra em sua janela de contexto, embora Claude precise apenas de um resumo das frequências de erros.Ao buscar dados de clientes em diversas tabelas, cada registro é acumulado no contexto, independentemente da relevância.Esses resultados intermediários consomem enormes orçamentos de tokens e podem tirar informações importantes totalmente da janela de contexto.\n\n- Sobrecarga de inferência e síntese manual: cada chamada de ferramenta requer uma passagem completa de inferência do modelo.Depois de receber os resultados, Claude deve “observar” os dados para extrair informações relevantes, raciocinar sobre como as peças se encaixam e decidir o que fazer a seguir – tudo por meio do processamento de linguagem natural.Um fluxo de trabalho de cinco ferramentas significa cinco passagens de inferência, além de Claude analisando cada resultado, comparando valores e sintetizando conclusões.Isso é lento e sujeito a erros.\n\nNossa solução\n\nA chamada de ferramenta programática permite que Claude orquestre ferramentas por meio de código, em vez de viagens de ida e volta de API individuais.Em vez de Claude solicitar uma ferramenta de cada vez, com cada resultado sendo retornado ao seu contexto, Claude escreve um código que chama diversas ferramentas, processa suas saídas e controla quais informações realmente entram na janela de contexto. Claude é excelente em escrever código e, ao permitir que ele expresse a lógica de orquestração em Python, em vez de invocar ferramentas de linguagem natural, você obtém um fluxo de controle mais confiável e preciso.Loops, condicionais, transformações de dados e tratamento de erros estão todos explícitos no código, e não implícitos no raciocínio de Claude.\n\nExemplo: verificação de conformidade orçamentária\n\nConsidere uma tarefa comercial comum: \"Quais membros da equipe excederam o orçamento de viagens do terceiro trimestre?\"\n\nVocê tem três ferramentas disponíveis:\n\n- get_team_members(department) – Retorna a lista de membros da equipe com IDs e níveis\n\n- get_expenses(user_id, quarter) – Retorna itens de linha de despesas para um usuário\n\n- get_budget_by_level(level) – Retorna os limites de orçamento para um nível de funcionário\n\nAbordagem tradicional:\n\n- Buscar membros da equipe 20 pessoas\n\n- Para cada pessoa, busque suas despesas do terceiro trimestre com 20 chamadas de ferramenta, cada uma retornando de 50 a 100 itens de linha (voos, hotéis, refeições, recibos)\n\n- Buscar limites de orçamento por nível de funcionário\n\n- Tudo isso entra no contexto de Claude: mais de 2.000 itens de linha de despesas (50 KB+)\n\n- Claude soma manualmente as despesas de cada pessoa, consulta o orçamento, compara as despesas com os limites orçamentários\n\n- Mais viagens de ida e volta ao modelo, consumo significativo de contexto\n\nCom chamada de ferramenta programática:\n\nEm vez de cada resultado da ferramenta retornar para Claude, Claude escreve um script Python que orquestra todo o fluxo de trabalho.O script é executado na ferramenta Code Execution (um ambiente em área restrita), pausando quando precisa de resultados de suas ferramentas.Quando você retorna resultados de ferramentas por meio da API, eles são processados ​​pelo script em vez de consumidos pelo modelo.O script continua em execução e Claude vê apenas o resultado final.\n\n[[IMAGE_2|A chamada de ferramenta programática permite que Claude orquestre ferramentas por meio de código, em vez de viagens de ida e volta de API individuais, permitindo a execução paralela de ferramentas.]]\n\nEsta é a aparência do código de orquestração de Claude para a tarefa de conformidade orçamentária:\n\n```\nequipe = aguarda get_team_members(\"engenharia\")\n\n# Busque orçamentos para cada nível único\nníveis = lista(set(m[\"nível\"] para m na equipe))\norçamento_resultados = aguardar asyncio.gather(*[\nget_budget_by_level(level) para nível em níveis\n])\n\n# Crie um dicionário de pesquisa: {\"junior\": budget1, \"senior\": budget2, ...}\norçamentos = {nível: orçamento por nível, orçamento em zip(níveis, orçamento_resultados)}\n\n#Busca todas as despesas em paralelo\ndespesas = aguardar asyncio.gather(*[\nget_expenses(m[\"id\"], \"Q3\") para m na equipe\n])\n\n# Encontre funcionários que excederam seu orçamento de viagens\nexcedido = []\npara membro, exp em zip(equipe, despesas):\norçamento = orçamentos[membro[\"nível\"]]\ntotal = soma(e[\"quantia\"] para e em exp)\nse total > orçamento[\"travel_limit\"]:\nexcedido.append({\n\"nome\": membro[\"nome\"],\n\"gasto\": total,\n\"limite\": orçamento[\"limite_viagem\"]\n})\n\nimprimir(json.dumps(excedido))\n```\n\nO contexto de Claude recebe apenas o resultado final: as duas a três pessoas que ultrapassaram o orçamento.Os mais de 2.000 itens de linha, as somas intermediárias e as pesquisas de orçamento não afetam o contexto de Claude, reduzindo o consumo de 200 KB de dados brutos de despesas para apenas 1 KB de resultados.\n\nOs ganhos de eficiência são substanciais:\n\n- Economia de tokens: Ao manter os resultados intermediários fora do contexto de Claude, a PTC reduz drasticamente o consumo de tokens.O uso médio caiu de 43.588 para 27.297 tokens, uma redução de 37% em tarefas complexas de pesquisa.\n\n- Latência reduzida: cada viagem de ida e volta da API requer inferência de modelo (centenas de milissegundos a segundos).Quando Claude orquestra mais de 20 chamadas de ferramenta em um único bloco de código, você elimina mais de 19 passagens de inferência.A API lida com a execução da ferramenta sem retornar ao modelo todas as vezes.\n\n- Precisão aprimorada: ao escrever lógica de orquestração explícita, Claude comete menos erros do que ao fazer malabarismos com vários resultados de ferramentas em linguagem natural.A recuperação de conhecimento interno melhorou de 25,6% para 28,5%;Referências GIA de 46,5% para 51,2%.\n\nOs fluxos de trabalho de produção envolvem dados confusos, lógica condicional e operações que precisam ser escalonadas.A chamada de ferramenta programática permite que Claude lide com essa complexidade de forma programática, mantendo o foco em resultados acionáveis, em vez de no processamento de dados brutos.\n\nComo funciona a chamada de ferramenta programática\n\n1. Marcar ferramentas como chamáveis a partir do código\n\nAdicione code_execution às ferramentas e defina Allow_callers como ferramentas opcionais para execução programática: ```\n{\n\"ferramentas\": [\n{\n\"tipo\": \"código_execução_20250825\",\n\"nome\": \"código_execução\"\n},\n{\n\"nome\": \"get_team_members\",\n\"description\": \"Obter todos os membros de um departamento...\",\n\"esquema_de entrada\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # opte pela chamada de ferramenta programática\n},\n{\n\"nome\": \"get_expenses\",\n...\n},\n{\n\"nome\": \"get_budget_by_level\",\n...\n}\n]\n}\n```\n\nA API converte essas definições de ferramentas em funções Python que Claude pode chamar.\n\n2. Claude escreve código de orquestração\n\nEm vez de solicitar uma ferramenta de cada vez, Claude gera código Python:\n\n```\n{\n\"tipo\": \"server_tool_use\",\n\"id\": \"srvtoolu_abc\",\n\"nome\": \"código_execução\",\n\"entrada\": {\n\"code\": \"team = get_team_members('engineering')\\n...\" # o exemplo de código acima\n}\n}\n```\n\n3. As ferramentas são executadas sem atingir o contexto de Claude\n\nQuando o código chama get_expenses(), você recebe uma solicitação de ferramenta com um campo de chamada:\n\n```\n{\n\"tipo\": \"uso_ferramenta\",\n\"id\": \"toolu_xyz\",\n\"nome\": \"get_expenses\",\n\"input\": {\"user_id\": \"emp_123\", \"trimestre\": \"Q3\"},\n\"chamador\": {\n\"tipo\": \"código_execução_20250825\",\n\"tool_id\": \"srvtoolu_abc\"\n}\n}\n```\n\nVocê fornece o resultado, que é processado no ambiente de execução de código, e não no contexto de Claude.Este ciclo de solicitação-resposta se repete para cada chamada de ferramenta no código.\n\n4. Somente o resultado final entra no contexto\n\nQuando a execução do código termina, apenas os resultados do código são retornados para Claude:\n\n```\n{\n\"tipo\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"conteúdo\": {\n\"stdout\": \"[{\\\"nome\\\": \\\"Alice\\\", \\\"gasto\\\": 12500, \\\"limite\\\": 10000}...]\"\n}\n}\n```\n\nIsso é tudo que Claude vê, e não os mais de 2.000 itens de despesas processados ao longo do caminho.\n\nQuando usar chamada de ferramenta programática\n\nA chamada de ferramenta programática adiciona uma etapa de execução de código ao seu fluxo de trabalho.Essa sobrecarga extra compensa quando a economia de tokens, as melhorias de latência e os ganhos de precisão são substanciais.\n\nMais benéfico quando:\n\n- Processamento de grandes conjuntos de dados onde você só precisa de agregados ou resumos\n\n- Execução de fluxos de trabalho de várias etapas com três ou mais chamadas de ferramentas dependentes\n\n- Filtrar, classificar ou transformar os resultados da ferramenta antes que Claude os veja\n\n- Lidar com tarefas onde dados intermediários não deveriam influenciar o raciocínio de Claude\n\n- Execução de operações paralelas em vários itens (verificação de 50 endpoints, por exemplo)\n\nMenos benéfico quando:\n\n- Fazendo invocações simples de ferramenta única\n\n- Trabalhar em tarefas onde Claude deveria ver e raciocinar sobre todos os resultados intermediários\n\n- Executando pesquisas rápidas com pequenas respostas\n\nExemplos de uso de ferramentas\n\nO desafio\n\nO esquema JSON é excelente na definição de tipos de estrutura, campos obrigatórios e enums permitidos, mas não pode expressar padrões de uso: quando incluir parâmetros opcionais, quais combinações fazem sentido ou quais convenções sua API espera.\n\nConsidere uma API de ticket de suporte:\n\n```\n{\n\"nome\": \"criar_ticket\",\n\"esquema_de entrada\": {\n\"propriedades\": {\n\"título\": {\"tipo\": \"string\"},\n\"prioridade\": {\"enum\": [\"baixo\", \"médio\", \"alto\", \"crítico\"]},\n\"labels\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n\"repórter\": {\n\"tipo\": \"objeto\",\n\"propriedades\": {\n\"id\": {\"tipo\": \"string\"},\n\"nome\": {\"tipo\": \"string\"},\n\"contato\": {\n\"tipo\": \"objeto\",\n\"propriedades\": {\n\"e-mail\": {\"tipo\": \"string\"},\n\"telefone\": {\"tipo\": \"string\"}\n}\n}\n}\n},\n\"data_de vencimento\": {\"tipo\": \"string\"},\n\"escalada\": {\n\"tipo\": \"objeto\",\n\"propriedades\": {\n\"nível\": {\"tipo\": \"inteiro\"},\n\"notify_manager\": {\"type\": \"boolean\"},\n\"sla_hours\": {\"type\": \"inteiro\"}\n}\n}\n},\n\"obrigatório\": [\"título\"]\n}\n}\n```\n\nO esquema define o que é válido, mas deixa questões críticas sem resposta:\n\n- Ambigüidade de formato: a data_de vencimento deve usar \"2024-11-06\", \"Nov 6, 2024\" ou \"2024-11-06T00:00:00Z\"?\n\n- Convenções de ID: reporter.id é um UUID, \"USR-12345\" ou apenas \"12345\"?\n\n- Uso de estrutura aninhada: quando Claude deve preencher reporter.contact ?\n\n- Correlações de parâmetros: como escalation.level e escalation.sla_hours se relacionam com a prioridade?\n\nEssas ambigüidades podem levar a chamadas de ferramentas malformadas e ao uso inconsistente de parâmetros.\n\nNossa solução\n\nOs Exemplos de uso de ferramentas permitem fornecer amostras de chamadas de ferramentas diretamente nas definições de ferramentas.Em vez de confiar apenas no esquema, você mostra padrões de uso concretos a Claude: ```\n{\n\"nome\": \"criar_ticket\",\n\"input_schema\": { /* mesmo esquema acima */ },\n\"input_examples\": [\n{\n\"title\": \"A página de login retorna erro 500\",\n\"prioridade\": \"crítico\",\n\"labels\": [\"bug\", \"autenticação\", \"produção\"],\n\"repórter\": {\n\"id\": \"USR-12345\",\n\"nome\": \"Jane Smith\",\n\"contato\": {\n\"e-mail\": \"jane@acme.com\",\n\"telefone\": \"+1-555-0123\"\n}\n},\n\"data_de vencimento\": \"06/11/2024\",\n\"escalada\": {\n\"nível\": 2,\n\"notify_manager\": verdadeiro,\n\"sla_horas\": 4\n}\n},\n{\n\"title\": \"Adicionar suporte ao modo escuro\",\n\"rótulos\": [\"solicitação de recurso\", \"ui\"],\n\"repórter\": {\n\"id\": \"USR-67890\",\n\"nome\": \"Alex Chen\"\n}\n},\n{\n\"title\": \"Atualizar documentação da API\"\n}\n]\n}\n```\n\nA partir desses três exemplos, Claude aprende:\n\n- Convenções de formato: as datas usam AAAA-MM-DD, os IDs de usuário seguem USR-XXXXX, os rótulos usam kebab-case\n\n- Padrões de estrutura aninhada: como construir o objeto repórter com seu objeto de contato aninhado\n\n- Correlações de parâmetros opcionais: Bugs críticos têm informações de contato completas + escalonamento com SLAs rígidos;solicitações de recursos têm relator, mas não têm contato/escalonamento;tarefas internas têm apenas título\n\nEm nossos próprios testes internos, exemplos de uso de ferramentas melhoraram a precisão de 72% para 90% no tratamento de parâmetros complexos.\n\nQuando usar exemplos de uso de ferramentas\n\nExemplos de uso de ferramentas adicionam tokens às definições de ferramentas, portanto, eles são mais valiosos quando as melhorias na precisão superam o custo adicional.\n\nMais benéfico quando:\n\n- Estruturas aninhadas complexas onde JSON válido não implica uso correto\n\n- Ferramentas com muitos parâmetros opcionais e padrões de inclusão são importantes\n\n- APIs com convenções específicas de domínio não capturadas em esquemas\n\n- Ferramentas semelhantes onde os exemplos esclarecem qual usar (por exemplo, create_ticket vs create_incident )\n\nMenos benéfico quando:\n\n- Ferramentas simples de parâmetro único com uso óbvio\n\n- Formatos padrão como URLs ou e-mails que Claude já entende\n\n- Preocupações de validação melhor tratadas pelas restrições do esquema JSON\n\nMelhores práticas\n\nConstruir agentes que realizam ações no mundo real significa lidar com escala, complexidade e precisão simultaneamente.Esses três recursos trabalham juntos para resolver diferentes gargalos nos fluxos de trabalho de uso de ferramentas.Veja como combiná-los de forma eficaz.\n\nCamada de recursos estrategicamente\n\nNem todo agente precisa usar todos os três recursos para uma determinada tarefa.Comece com seu maior gargalo:\n\n- Inchaço de contexto das definições de ferramentas Ferramenta de pesquisa de ferramentas\n\n- Grandes resultados intermediários contexto poluente Chamada de ferramenta programática\n\n- Erros de parâmetro e chamadas malformadas Exemplos de uso de ferramentas\n\nEssa abordagem focada permite que você resolva a restrição específica que limita o desempenho do seu agente, em vez de adicionar complexidade antecipadamente.\n\nEm seguida, coloque recursos adicionais conforme necessário.Eles são complementares: a ferramenta de pesquisa de ferramentas garante que as ferramentas certas sejam encontradas, a chamada programática de ferramentas garante uma execução eficiente e os exemplos de uso de ferramentas garantem a invocação correta.\n\nConfigure a ferramenta de pesquisa de ferramentas para uma melhor descoberta\n\nA pesquisa de ferramentas corresponde a nomes e descrições, portanto, definições claras e descritivas melhoram a precisão da descoberta.\n\n```\n//Bom\n{\n\"nome\": \"search_customer_orders\",\n\"description\": \"Pesquise pedidos de clientes por intervalo de datas, status ou valor total. Retorna detalhes do pedido, incluindo itens, frete e informações de pagamento.\"\n}\n\n// Ruim\n{\n\"nome\": \"query_db_orders\",\n\"description\": \"Executar consulta de pedido\"\n}\n```\n\nAdicione orientação imediata do sistema para que Claude saiba o que está disponível:\n\n```\nVocê tem acesso a ferramentas de mensagens do Slack, gerenciamento de arquivos do Google Drive,\nRastreamento de tickets Jira e operações de repositório GitHub.Utilize a ferramenta de busca\npara encontrar capacidades específicas.\n```\n\nMantenha suas três a cinco ferramentas mais usadas sempre carregadas, adie o resto.Isso equilibra o acesso imediato para operações comuns com a descoberta sob demanda para todo o resto.\n\nConfigure a chamada de ferramenta programática para execução correta\n\nComo Claude escreve código para analisar os resultados da ferramenta, documente os formatos de retorno com clareza.Isso ajuda Claude a escrever a lógica de análise correta: ```\n{\n\"nome\": \"get_orders\",\n\"description\": \"Recuperar pedidos de um cliente.\nRetorna:\nLista de objetos de pedido, cada um contendo:\n- id (str): identificador do pedido\n- total (float): total do pedido em USD\n- status (str): Um entre 'pendente', 'enviado', 'entregue'\n- itens (lista): Matriz de {sku, quantidade, preço}\n- criado_at (str): carimbo de data/hora ISO 8601\"\n}\n```\n\nVeja abaixo as ferramentas opcionais que se beneficiam da orquestração programática:\n\n- Ferramentas que podem funcionar em paralelo (operações independentes)\n\n- Operações seguras para tentar novamente (idempotentes)\n\nConfigurar exemplos de uso de ferramentas para precisão de parâmetros\n\nCrie exemplos para clareza comportamental:\n\n- Use dados realistas (nomes reais de cidades, preços plausíveis, não \"string\" ou \"valor\")\n\n- Mostre variedade com padrões de especificações mínimas, parciais e completas\n\n- Seja conciso: 1 a 5 exemplos por ferramenta\n\n- Concentre-se na ambiguidade (adicione apenas exemplos onde o uso correto não seja óbvio no esquema)\n\nPrimeiros passos\n\nEsses recursos estão disponíveis na versão beta.Para ativá-los, adicione o cabeçalho beta e inclua as ferramentas necessárias:\n\n```\ncliente.beta.messages.create(\nbetas = [\"uso de ferramenta avançada-2025-11-20\"],\nmodelo = \"claude-sonnet-4-5-20250929\",\nmax_tokens=4096,\nferramentas=[\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nome\": \"tool_search_tool_regex\"},\n{\"tipo\": \"code_execution_20250825\", \"nome\": \"code_execution\"},\n# Suas ferramentas com defer_loading, Allow_callers e input_examples\n]\n)\n```\n\nPara obter documentação detalhada da API e exemplos de SDK, consulte:\n\n- D ocumentação e livro de receitas para a ferramenta Tool Search\n\n- Documentação e livro de receitas para chamada de ferramenta programática\n\n- Documentação para exemplos de uso de ferramentas\n\nEsses recursos movem o uso da ferramenta de uma simples chamada de função para uma orquestração inteligente.À medida que os agentes lidam com fluxos de trabalho mais complexos, abrangendo dezenas de ferramentas e grandes conjuntos de dados, a descoberta dinâmica, a execução eficiente e a invocação confiável tornam-se fundamentais.\n\nEstamos entusiasmados para ver o que você constrói.\n\nAgradecimentos\n\nEscrito por Bin Wu, com contribuições de Adam Jones, Artur Renault, Henry Tay, Jake Noble, Nathan McCandlish, Noah Picard, Sam Jiang e a equipe da Claude Developer Platform.Este trabalho baseia-se na pesquisa fundamental de Chris Gorgolewski, Daniel Jiang, Jeremy Fox e Mike Lambert.Também nos inspiramos em todo o ecossistema de IA, incluindo LLMVM de Joel Pobar, Code Mode da Cloudflare e Code Execution como MCP.Agradecimentos especiais a Andy Schumeister, Hamish Kerr, Keir Bradwell, Matt Bleifer e Molly Vorwerck pelo apoio.",
        "edited": false
      },
      "zh": {
        "title": "介绍 Claude 开发者平台上的高级工具使用",
        "content": "人工智能代理的未来是模型可以跨数百或数千种工具无缝工作。集成了 git 操作、文件操作、包管理器、测试框架和部署管道的 IDE 助手。一个运营协调器，可同时连接 Slack、GitHub、Google Drive、Jira、公司数据库和数十台 MCP 服务器。\n\n为了构建有效的代理，他们需要使用无限的工具库，而不需要预先将每个定义填充到上下文中。我们关于使用 MCP 执行代码的博客文章讨论了工具结果和定义有时如何在代理读取请求之前消耗 50,000 多个令牌。代理应该按需发现和加载工具，只保留与当前任务相关的工具。\n\n代理还需要能够从代码调用工具。使用自然语言工具调用时，每次调用都需要完整的推理过程，中间结果会在上下文中堆积，无论它们是否有用。代码非常适合编排逻辑，例如循环、条件和数据转换。代理需要根据手头的任务灵活地在代码执行和推理之间进行选择。\n\n代理还需要从示例中学习正确的工具用法，而不仅仅是模式定义。JSON 模式定义了结构上有效的内容，但无法表达使用模式：何时包含可选参数、哪些组合有意义，或者您的 API 期望什么约定。\n\n今天，我们发布了三项使这成为可能的功能：\n\n- 工具搜索工具，允许 Claude 使用搜索工具访问数千种工具，而无需消耗其上下文窗口\n\n- 编程工具调用，允许 Claude 在代码执行环境中调用工具，减少对模型上下文窗口的影响\n\n- 工具使用示例，提供了演示如何有效使用给定工具的通用标准\n\n在内部测试中，我们发现这些功能帮助我们构建了传统工具使用模式无法实现的东西。例如，Claude for Excel 使用编程工具调用来读取和修改具有数千行的电子表格，而不会使模型的上下文窗口超载。\n\n根据我们的经验，我们相信这些功能为您与 Claude 一起构建内容开辟了新的可能性。\n\n工具搜索工具\n\n挑战\n\nMCP 工具定义提供了重要的上下文，但随着更多服务器连接，这些令牌会不断增加。考虑五台服务器的设置：\n\n- GitHub：35 个工具（约 26K 代币）\n\n- Slack：11 个工具（约 21K 代币）\n\n- Sentry：5 个工具（~3K 代币）\n\n- Grafana：5 个工具（~3K 代币）\n\n- Splunk：2 个工具（~2K 代币）\n\n在对话开始之前，这 58 个工具消耗了大约 55K 令牌。添加更多像 Jira 这样的服务器（仅使用约 17K 令牌），您很快就会接近 100K+ 令牌开销。在 Anthropic，我们看到工具定义在优化之前消耗了 134K 令牌。\n\n但代币成本并不是唯一的问题。最常见的故障是错误的工具选择和不正确的参数，尤其是当工具具有类似名称（例如 notification-send-user 与 notification-send-channel ）时。\n\n我们的解决方案\n\n工具搜索工具不是预先加载所有工具定义，而是按需发现工具。Claude 只看到当前任务实际需要的工具。\n\n[[IMAGE_1|工具搜索工具保留了 191,300 个上下文标记，而 Claude 的传统方法保留了 122,800 个。]]\n\n传统方法：\n\n- 预先加载所有工具定义（50 多个 MCP 工具约 72K 令牌）\n\n- 对话历史和系统提示争夺剩余空间\n\n- 总上下文消耗：在任何工作开始之前约 77K 令牌\n\n使用工具搜索工具：\n\n- 仅预先加载工具搜索工具（约 500 个令牌）\n\n- 根据需要按需发现工具（3-5 个相关工具，约 3K 代币）\n\n- 总上下文消耗：~8.7K 令牌，保留 95% 的上下文窗口\n\n这意味着令牌使用量减少了 85%，同时保持对完整工具库的访问。内部测试表明，使用大型工具库时，MCP 评估的准确性显着提高。启用工具搜索工具后，Opus 4 从 49% 提高到 74%，Opus 4.5 从 79.5% 提高到 88.1%。\n\n工具搜索工具的工作原理 工具搜索工具可让 Claude 动态发现工具，而不是预先加载所有定义。您向 API 提供所有工具定义，但使用 defer_loading: true 标记工具，以便按需发现它们。延迟工具最初不会加载到 Claude 的上下文中。Claude 只能看到工具搜索工具本身以及带有 defer_loading: false 的任何工具（您最关键、最常用的工具）。\n\n当 Claude 需要特定功能时，它会搜索相关工具。工具搜索工具返回对匹配工具的引用，这些工​​具在 Claude 的上下文中扩展为完整的定义。\n\n例如，如果 Claude 需要与 GitHub 交互，它会搜索“github”，并且仅加载 github.createPullRequest 和 github.listIssues，而不加载来自 Slack、Jira 和 Google Drive 的其他 50 多个工具。\n\n这样，Claude 就可以访问您的完整工具库，而只需支付其实际需要的工具的代币成本。\n\n提示缓存注意：工具搜索工具不会破坏提示缓存，因为延迟工具完全从初始提示中排除。它们仅在 Claude 搜索后才会添加到上下文中，因此您的系统提示和核心工具定义仍然可缓存。\n\n实施：\n\n````\n{\n“工具”：[\n// 包含工具搜索工具（正则表达式、BM25 或自定义）\n{“类型”：“tool_search_tool_regex_20251119”，“名称”：“tool_search_tool_regex”}，\n\n// 标记用于按需发现的工具\n{\n\"name\": \"github.createPullRequest\",\n\"description\": \"创建拉取请求\",\n“输入模式”：{...}，\n“延迟加载”：正确\n}\n// ... 数百个带有 defer_loading: true 的延迟工具\n]\n}\n````\n\n对于 MCP 服务器，您可以推迟加载整个服务器，同时保持加载特定的高使用率工具：\n\n````\n{\n“类型”：“mcp_toolset”，\n\"mcp_server_name\": \"谷歌驱动器\",\n\"default_config\": {\"defer_loading\": true}, # 延迟加载整个服务器\n“配置”：{\n“搜索文件”：{\n“延迟加载”：假\n} // 保持最常用的工具加载\n}\n}\n````\n\nClaude 开发者平台提供开箱即用的基于正则表达式和基于 BM25 的搜索工具，但您也可以使用嵌入或其他策略来实现自定义搜索工具。\n\n何时使用工具搜索工具\n\n与任何架构决策一样，启用工具搜索工具需要权衡。该功能在工具调用之前添加了一个搜索步骤，因此当上下文节省和准确性改进超过额外的延迟时，它可以提供最佳的投资回报率。\n\n在以下情况下使用它：\n\n- 消耗 >10K 代币的工具定义\n\n- 遇到工具选择准确性问题\n\n- 使用多个服务器构建 MCP 驱动的系统\n\n- 10 多个可用工具\n\n在以下情况下效果较差：\n\n- 小型工具库（<10 个工具）\n\n- 每个会话中经常使用的所有工具\n\n- 工具定义紧凑\n\n程序化工具调用\n\n挑战\n\n随着工作流程变得更加复杂，传统的工具调用会产生两个基本问题：\n\n- 中间结果的上下文污染：当 Claude 分析 10MB 日志文件中的错误模式时，整个文件都会进入其上下文窗口，即使 Claude 只需要错误频率的摘要。当跨多个表获取客户数据时，每条记录都会在上下文中累积，无论相关性如何。这些中间结果消耗大量的代币预算，并且可以将重要信息完全推出上下文窗口。\n\n- 推理开销和手动综合：每个工具调用都需要完整的模型推理过程。收到结果后，克劳德必须“观察”数据以提取相关信息，推理各个部分如何组合在一起，并通过自然语言处理决定下一步该做什么。五工具工作流程意味着五次推理过程加上 Claude 解析每个结果、比较值并综合结论。这既缓慢又容易出错。\n\n我们的解决方案\n\n编程工具调用使 Claude 能够通过代码而不是通过单独的 API 往返来编排工具。Claude 不是每次请求一个工具并将每个结果返回到其上下文，而是编写调用多个工具、处理其输出并控制实际进入其上下文窗口的信息的代码。 Claude 擅长编写代码，通过让它用 Python 表达编排逻辑，而不是通过自然语言工具调用，您可以获得更可靠、更精确的控制流。循环、条件、数据转换和错误处理在代码中都是显式的，而不是在 Claude 的推理中隐式的。\n\n示例：预算合规性检查\n\n考虑一个常见的业务任务：“哪些团队成员超出了第三季度的差旅预算？”\n\n您可以使用三种工具：\n\n- get_team_members(department) - 返回带有 ID 和级别的团队成员列表\n\n- get_expenses(user_id,quarter) - 返回用户的费用行项目\n\n- get_budget_by_level(level) - 返回员工级别的预算限制\n\n传统方法：\n\n- 获取团队成员20人\n\n- 对于每个人，获取他们的第三季度支出 20 个工具调用，每个返回 50-100 个行项目（航班、酒店、餐饮、收据）\n\n- 按员工级别获取预算限制\n\n- 所有这些都进入 Claude 的上下文：2,000 多个费用行项目 (50 KB+)\n\n- 克劳德手动汇总每个人的费用，查找他们的预算，将费用与预算限制进行比较\n\n- 模型的往返次数更多，上下文消耗显着\n\n通过编程工具调用：\n\nClaude 没有将每个工具结果返回给 Claude，而是编写了一个 Python 脚本来协调整个工作流程。该脚本在代码执行工具（沙盒环境）中运行，在需要工具的结果时暂停。当您通过 API 返回工具结果时，它们将由脚本处理，而不是由模型使用。脚本继续执行，克劳德只看到最终的输出。\n\n[[IMAGE_2|编程工具调用使 Claude 能够通过代码而不是通过单独的 API 往返来编排工具，从而允许并行工具执行。]]\n\n以下是克劳德针对预算合规任务的编排代码：\n\n````\n团队=等待 get_team_members(“工程”)\n\n# 获取每个独特级别的预算\n级别 = list(set(m[\"level\"] for m in team))\nBudget_results = 等待 asyncio.gather(*[\nget_budget_by_level(level) 获取级别中的级别\n]）\n\n# 创建一个查找字典: {\"junior\":budget1, \"senior\":budget2, ...}\n预算 = {级别：级别预算，zip 中的预算(levels,budget_results)}\n\n# 并行获取所有费用\n费用 = 等待 asyncio.gather(*[\n团队中 m 的 get_expenses(m[\"id\"], \"Q3\")\n]）\n\n# 查找超出差旅预算的员工\n超出=[]\n对于会员，exp in zip（团队，费用）：\n预算 = 预算[成员[\"级别\"]]\n总计 = sum(e[\"金额\"] for e in exp)\n如果总计 > 预算[“travel_limit”]：\n超出.append({\n“姓名”：成员[“姓名”]，\n“花费”：总计，\n“限制”：预算[“旅行限制”]\n})\n\nprint(json.dumps(超出))\n````\n\n克劳德的上下文只收到最终结果：超出预算的两到三个人。2,000 多个行项目、中间金额和预算查找不会影响 Claude 的上下文，从而将消耗量从 200KB 的原始费用数据减少到仅 1KB 的结果。\n\n效率提升是巨大的：\n\n- 节省代币：通过将中间结果排除在 Claude 的上下文之外，PTC 极大地减少了代币消耗。平均使用量从 43,588 个令牌下降到 27,297 个令牌，复杂研究任务减少了 37%。\n\n- 减少延迟：每个 API 往返都需要模型推理（数百毫秒到秒）。当 Claude 在单个代码块中协调 20 多个工具调用时，您可以消除 19 多个推理过程。API 处理工具执行，而无需每次都返回模型。\n\n- 提高准确性：通过编写明确的编排逻辑，Claude 比用自然语言处理多个工具结果时犯的错误更少。内部知识检索从25.6%提高到28.5%；GIA 基准从 46.5% 降至 51.2%。\n\n生产工作流程涉及混乱的数据、条件逻辑和需要扩展的操作。编程工具调用让 Claude 以编程方式处理这种复杂性，同时将重点放在可操作的结果而不是原始数据处理上。\n\n编程工具调用的工作原理\n\n1. 将工具标记为可从代码调用\n\n将 code_execution 添加到工具中，并将 allowed_callers 设置为选择加入工具以进行编程执行： ````\n{\n“工具”：[\n{\n“类型”：“code_execution_20250825”，\n“名称”：“代码执行”\n},\n{\n“名称”：“获取团队成员”，\n\"description\": \"获取部门的所有成员...\",\n“输入模式”：{...}，\n\"allowed_callers\": [\"code_execution_20250825\"] # 选择以编程方式调用工具\n},\n{\n“名称”：“获取费用”，\n...\n},\n{\n“名称”：“按级别获取预算”，\n...\n}\n]\n}\n````\n\nAPI 将这些工具定义转换为 Claude 可以调用的 Python 函数。\n\n2.Claude编写编排代码\n\nClaude 不是一次请求一个工具，而是生成 Python 代码：\n\n````\n{\n“类型”：“服务器工具使用”，\n“id”：“srvtoolu_abc”，\n“名称”：“代码执行”，\n“输入”：{\n\"code\": \"team = get_team_members('engineering')\\n...\" # 上面的代码示例\n}\n}\n````\n\n3. 工具在不影响 Claude 上下文的情况下执行\n\n当代码调用 get_expenses() 时，您会收到带有调用者字段的工具请求：\n\n````\n{\n“类型”：“工具使用”，\n“id”：“toolu_xyz”，\n“名称”：“获取费用”，\n\"input\": {\"user_id\": \"emp_123\", \"quarter\": \"Q3\"},\n“来电者”：{\n“类型”：“code_execution_20250825”，\n“tool_id”：“srvtoolu_abc”\n}\n}\n````\n\n您提供结果，该结果在代码执行环境而不是 Claude 的上下文中进行处理。对于代码中的每个工具调用，都会重复此请求-响应循环。\n\n4.只有最终输出才进入上下文\n\n当代码运行完毕后，只将代码的结果返回给Claude：\n\n````\n{\n“类型”：“代码执行工具结果”，\n\"tool_use_id\": \"srvtoolu_abc\",\n“内容”：{\n\"stdout\": \"[{\\\"name\\\": \\\"Alice\\\", \\\"spent\\\": 12500, \\\"limit\\\": 10000}...]\"\n}\n}\n````\n\n这就是 Claude 看到的全部内容，而不是一路上处理的 2000 多个费用行项目。\n\n何时使用编程工具调用\n\n编程工具调用向您的工作流程添加了代码执行步骤。当令牌节省、延迟改进和准确性提升显着时，这种额外的开销就会得到回报。\n\n在以下情况下最有益：\n\n- 处理只需要聚合或摘要的大型数据集\n\n- 通过三个或更多相关工具调用运行多步骤工作流程\n\n- 在克劳德看到工具结果之前对其进行过滤、排序或转换\n\n- 处理中间数据不应影响克劳德推理的任务\n\n- 跨多个项目运行并行操作（例如，检查 50 个端点）\n\n在以下情况下效果较差：\n\n- 进行简单的单一工具调用\n\n- 从事克劳德应该看到并推理所有中间结果的任务\n\n- 以较小的响应运行快速查找\n\n工具使用示例\n\n挑战\n\nJSON Schema 擅长定义结构类型、必填字段、允许的枚举，但它无法表达使用模式：何时包含可选参数、哪些组合有意义，或者您的 API 期望什么约定。\n\n考虑一个支持票证 API：\n\n````\n{\n“名称”：“创建票”，\n“输入模式”：{\n“属性”：{\n“标题”：{“类型”：“字符串”}，\n“优先级”：{“enum”：[“低”，“中”，“高”，“关键”]}，\n“标签”：{“类型”：“数组”，“项目”：{“类型”：“字符串”}}，\n“记者”：{\n“类型”：“对象”，\n“属性”：{\n“id”：{“类型”：“字符串”}，\n“名称”：{“类型”：“字符串”}，\n“联系方式”：{\n“类型”：“对象”，\n“属性”：{\n“电子邮件”：{“类型”：“字符串”}，\n“电话”：{“类型”：“字符串”}\n}\n}\n}\n},\n“到期日期”：{“类型”：“字符串”}，\n“升级”：{\n“类型”：“对象”，\n“属性”：{\n“级别”：{“类型”：“整数”}，\n\"notify_manager\": {\"type\": \"boolean\"},\n“sla_hours”：{“类型”：“整数”}\n}\n}\n},\n“必需”：[“标题”]\n}\n}\n````\n\n该模式定义了什么是有效的，但没有回答关键问题：\n\n- 格式不明确： due_date 应该使用“2024-11-06”、“2024 年 11 月 6 日”还是“2024-11-06T00:00:00Z”？\n\n- ID 约定：reporter.id 是 UUID、“USR-12345”还是只是“12345”？\n\n- 嵌套结构的使用：Claude 应该何时填充reporter.contact？\n\n- 参数相关性：escalation.level 和 escalation.sla_hours 与优先级有何关系？\n\n这些歧义可能导致格式错误的工具调用和不一致的参数使用。\n\n我们的解决方案\n\n工具使用示例让您可以直接在工具定义中提供示例工具调用。您不是仅仅依赖于模式，而是向 Claude 展示了具体的使用模式： ````\n{\n“名称”：“创建票”，\n\"input_schema\": { /* 与上面相同的模式 */ },\n“输入示例”：[\n{\n\"title\": \"登录页面返回500错误\",\n“优先级”：“关键”，\n\"labels\": [\"bug\", \"认证\", \"生产\"],\n“记者”：{\n“id”：“USR-12345”，\n“姓名”：“简·史密斯”，\n“联系方式”：{\n“电子邮件”：“jane@acme.com”，\n“电话”：“+1-555-0123”\n}\n},\n“到期日期”：“2024-11-06”，\n“升级”：{\n“级别”：2，\n“notify_manager”：正确，\n“sla_小时”：4\n}\n},\n{\n\"title\": \"添加深色模式支持\",\n“标签”：[“功能请求”，“ui”]，\n“记者”：{\n“id”：“USR-67890”，\n“姓名”：“亚历克斯·陈”\n}\n},\n{\n\"title\": \"更新API文档\"\n}\n]\n}\n````\n\n从这三个例子中，克劳德了解到：\n\n- 格式约定：日期使用 YYYY-MM-DD，用户 ID 遵循 USR-XXXXX，标签使用短横线大小写\n\n- 嵌套结构模式：如何使用嵌套的联系对象构造报告者对象\n\n- 可选参数相关性：关键错误具有完整的联系信息 + 具有严格 SLA 的升级；功能请求有记者但没有联系/升级；内部任务只有标题\n\n在我们自己的内部测试中，工具使用示例将复杂参数处理的准确性从 72% 提高到 90%。\n\n何时使用工具使用示例\n\n工具使用示例将标记添加到您的工具定义中，因此当准确性改进超过额外成本时，它们是最有价值的。\n\n在以下情况下最有益：\n\n- 复杂的嵌套结构，其中有效的 JSON 并不意味着正确的用法\n\n- 具有许多可选参数和包含模式的工具很重要\n\n- 具有特定领域约定的 API 未在模式中捕获\n\n- 类似的工具，其中的示例阐明了要使用哪一个（例如， create_ticket 与 create_incident ）\n\n在以下情况下效果较差：\n\n- 简单的单参数工具，用法一目了然\n\n- Claude 已经理解的标准格式，如 URL 或电子邮件\n\n- JSON Schema 约束可以更好地处理验证问题\n\n最佳实践\n\n构建采取现实世界行动的代理意味着同时处理规模、复杂性和精度。这三个功能共同解决工具使用工作流程中的不同瓶颈。以下是如何有效地将它们结合起来。\n\n战略性地分层特征\n\n并非每个代理都需要使用所有三个功能来完成给定的任务。从你最大的瓶颈开始：\n\n- 工具定义中的上下文膨胀工具搜索工具\n\n- 大量中间结果污染上下文编程工具调用\n\n- 参数错误和格式错误的调用工具使用示例\n\n这种集中的方法可以让您解决限制代理性能的特定约束，而不是预先增加复杂性。\n\n然后根据需要分层附加功能。它们是互补的：工具搜索工具确保找到正确的工具，编程工具调用确保高效执行，工具使用示例确保正确调用。\n\n设置工具搜索工具以更好地发现\n\n工具搜索与名称和描述相匹配，因此清晰的描述性定义可以提高发现的准确性。\n\n````\n// 好\n{\n“名称”：“搜索客户订单”，\n\"description\": \"按日期范围、状态或总金额搜索客户订单。返回订单详细信息，包括商品、运输和付款信息。\"\n}\n\n// 不好\n{\n“名称”：“query_db_orders”，\n\"description\": \"执行订单查询\"\n}\n````\n\n添加系统提示指导，以便 Claude 知道可用的内容：\n\n````\n您可以使用 Slack 消息传递、Google Drive 文件管理等工具\nJira 票证跟踪和 GitHub 存储库操作。使用工具搜索\n寻找特定的能力。\n````\n\n始终加载三到五个最常用的工具，推迟其余的。这可以平衡常见操作的即时访问与其他所有内容的按需发现。\n\n设置编程工具调用以正确执行\n\n由于 Claude 编写代码来解析工具输出，因此文档返回格式清晰。这有助于 Claude 编写正确的解析逻辑： ````\n{\n“名称”：“获取订单”，\n\"description\": \"检索客户的订单。\n返回：\n订单对象列表，每个对象包含：\n- id (str): 订单标识符\n- 总计（浮点数）：订单总计（美元）\n- 状态 (str)：“待处理”、“已发货”、“已交付”之一\n- 项目（列表）：{sku，数量，价格}的数组\n-created_at（str）：ISO 8601 时间戳”\n}\n````\n\n请参阅下文，了解受益于程序化编排的选择加入工具：\n\n- 可以并行运行的工具（独立操作）\n\n- 操作可以安全重试（幂等）\n\n设置工具使用示例以确保参数准确性\n\n行为清晰的工艺示例：\n\n- 使用真实的数据（真实的城市名称、合理的价格，而不是“字符串”或“值”）\n\n- 以最小、部分和完整规格模式显示多样性\n\n- 保持简洁：每个工具 1-5 个示例\n\n- 关注歧义（仅添加模式中正确用法不明显的示例）\n\n开始使用\n\n这些功能在测试版中可用。要启用它们，请添加 beta 标头并包含您需要的工具：\n\n````\n客户端.beta.messages.create(\nbetas=[\"高级工具使用-2025-11-20\"],\n模型=“克劳德-sonnet-4-5-20250929”，\n最大令牌=4096，\n工具=[\n{“类型”：“tool_search_tool_regex_20251119”，“名称”：“tool_search_tool_regex”}，\n{“类型”：“code_execution_20250825”，“名称”：“code_execution”}，\n# 您的工具包含 defer_loading、allowed_callers 和 input_examples\n]\n）\n````\n\n有关详细的 API 文档和 SDK 示例，请参阅我们的：\n\n- 工具搜索工具的文档和食谱\n\n- 编程工具调用的文档和食谱\n\n- 工具使用示例文档\n\n这些功能将工具的使用从简单的函数调用转向智能编排。随着代理处理涉及数十种工具和大型数据集的更复杂的工作流程，动态发现、高效执行和可靠调用成为基础。\n\n我们很高兴看到您所构建的内容。\n\n致谢\n\n由 Bin Wu 编写，Adam Jones、Artur Renault、Henry Tay、Jake Noble、Nathan McCandlish、Noah Picard、Sam Jiang 和 Claude 开发者平台团队的贡献。这项工作建立在 Chris Gorgolewski、Daniel Jiang、Jeremy Fox 和 Mike Lambert 的基础研究的基础上。我们还从整个 AI 生态系统中汲取灵感，包括 Joel Pobar 的 LLMVM、Cloudflare 的代码模式和 MCP 代码执行。特别感谢 Andy Schumeister、Hamish Kerr、Keir Bradwell、Matt Bleifer 和 Molly Vorwerck 的支持。",
        "edited": false
      },
      "hi": {
        "title": "क्लाउड डेवलपर प्लेटफ़ॉर्म पर उन्नत टूल उपयोग का परिचय",
        "content": "एआई एजेंटों का भविष्य वह है जहां मॉडल सैकड़ों या हजारों उपकरणों पर निर्बाध रूप से काम करते हैं।एक आईडीई सहायक जो गिट संचालन, फ़ाइल हेरफेर, पैकेज प्रबंधक, परीक्षण ढांचे और तैनाती पाइपलाइनों को एकीकृत करता है।एक संचालन समन्वयक जो स्लैक, गिटहब, गूगल ड्राइव, जीरा, कंपनी डेटाबेस और दर्जनों एमसीपी सर्वरों को एक साथ जोड़ता है।\n\nप्रभावी एजेंट बनाने के लिए, उन्हें हर परिभाषा को पहले से संदर्भ में डाले बिना असीमित टूल लाइब्रेरी के साथ काम करने की आवश्यकता है।एमसीपी के साथ कोड निष्पादन का उपयोग करने पर हमारे ब्लॉग लेख में चर्चा की गई है कि एजेंट के अनुरोध को पढ़ने से पहले टूल परिणाम और परिभाषाएँ कभी-कभी 50,000+ टोकन का उपभोग कैसे कर सकती हैं।एजेंटों को केवल वर्तमान कार्य के लिए प्रासंगिक टूल को ध्यान में रखते हुए ऑन-डिमांड टूल की खोज और लोड करना चाहिए।\n\nएजेंटों को कोड से टूल कॉल करने की क्षमता की भी आवश्यकता होती है।प्राकृतिक भाषा टूल कॉलिंग का उपयोग करते समय, प्रत्येक आह्वान के लिए पूर्ण अनुमान पास की आवश्यकता होती है, और मध्यवर्ती परिणाम संदर्भ में ढेर हो जाते हैं, चाहे वे उपयोगी हों या नहीं।कोड ऑर्केस्ट्रेशन लॉजिक, जैसे लूप, कंडीशनल और डेटा ट्रांसफ़ॉर्मेशन के लिए स्वाभाविक रूप से फिट है।एजेंटों को कार्य के आधार पर कोड निष्पादन और अनुमान के बीच चयन करने की लचीलेपन की आवश्यकता होती है।\n\nएजेंटों को केवल स्कीमा परिभाषाओं से ही नहीं, बल्कि उदाहरणों से भी उपकरण का सही उपयोग सीखने की जरूरत है।JSON स्कीमा परिभाषित करते हैं कि संरचनात्मक रूप से क्या मान्य है, लेकिन उपयोग पैटर्न को व्यक्त नहीं कर सकते: वैकल्पिक पैरामीटर कब शामिल करना है, कौन सा संयोजन समझ में आता है, या आपका एपीआई किन सम्मेलनों की अपेक्षा करता है।\n\nआज, हम तीन सुविधाएँ जारी कर रहे हैं जो इसे संभव बनाती हैं:\n\n- टूल सर्च टूल, जो क्लाउड को अपनी संदर्भ विंडो का उपभोग किए बिना हजारों टूल तक पहुंचने के लिए खोज टूल का उपयोग करने की अनुमति देता है\n\n- प्रोग्रामेटिक टूल कॉलिंग, जो क्लाउड को मॉडल के संदर्भ विंडो पर प्रभाव को कम करने वाले कोड निष्पादन वातावरण में टूल को लागू करने की अनुमति देता है\n\n- टूल उपयोग उदाहरण, जो किसी दिए गए टूल का प्रभावी ढंग से उपयोग करने के तरीके को प्रदर्शित करने के लिए एक सार्वभौमिक मानक प्रदान करता है\n\nआंतरिक परीक्षण में, हमने पाया है कि इन सुविधाओं ने हमें ऐसी चीजें बनाने में मदद की है जो पारंपरिक उपकरण उपयोग पैटर्न के साथ संभव नहीं होती।उदाहरण के लिए, एक्सेल के लिए क्लाउड मॉडल की संदर्भ विंडो को ओवरलोड किए बिना हजारों पंक्तियों वाली स्प्रेडशीट को पढ़ने और संशोधित करने के लिए प्रोग्रामेटिक टूल कॉलिंग का उपयोग करता है।\n\nहमारे अनुभव के आधार पर, हमारा मानना ​​है कि ये सुविधाएँ क्लाउड के साथ आप जो कुछ भी बना सकते हैं उसके लिए नई संभावनाएँ खोलती हैं।\n\nउपकरण खोज उपकरण\n\nचुनौती\n\nएमसीपी टूल परिभाषाएँ महत्वपूर्ण संदर्भ प्रदान करती हैं, लेकिन जैसे-जैसे अधिक सर्वर जुड़ते हैं, वे टोकन जुड़ सकते हैं।पाँच-सर्वर सेटअप पर विचार करें:\n\n- GitHub: 35 उपकरण (~26K टोकन)\n\n- स्लैक: 11 टूल्स (~21K टोकन)\n\n- संतरी: 5 उपकरण (~3K टोकन)\n\n- ग्राफाना: 5 उपकरण (~3K टोकन)\n\n- स्प्लंक: 2 उपकरण (~2K टोकन)\n\nबातचीत शुरू होने से पहले ही 58 टूल लगभग 55K टोकन का उपभोग कर रहे हैं।जिरा जैसे और सर्वर जोड़ें (जो अकेले ~17K टोकन का उपयोग करता है) और आप तेजी से 100K+ टोकन ओवरहेड के करीब पहुंच रहे हैं।एंथ्रोपिक में, हमने देखा है कि टूल परिभाषाएँ अनुकूलन से पहले 134K टोकन का उपभोग करती हैं।\n\nलेकिन टोकन लागत ही एकमात्र मुद्दा नहीं है।सबसे आम विफलताएं गलत टूल चयन और गलत पैरामीटर हैं, खासकर जब टूल के समान नाम होते हैं जैसे अधिसूचना-भेजें-उपयोगकर्ता बनाम अधिसूचना-भेजें-चैनल।\n\nहमारा समाधान\n\nसभी टूल परिभाषाओं को पहले से लोड करने के बजाय, टूल सर्च टूल ऑन-डिमांड टूल खोजता है।क्लाउड केवल उन उपकरणों को देखता है जिनकी उसे वर्तमान कार्य के लिए वास्तव में आवश्यकता होती है।\n\n[[IMAGE_1|टूल सर्च टूल क्लाउड के पारंपरिक दृष्टिकोण के 122,800 की तुलना में संदर्भ के 191,300 टोकन सुरक्षित रखता है।]]\n\nपारंपरिक दृष्टिकोण:\n\n- सभी टूल परिभाषाएँ अग्रिम रूप से लोड की गईं (50+ MCP टूल के लिए ~72K टोकन)\n\n- वार्तालाप इतिहास और सिस्टम प्रॉम्प्ट शेष स्थान के लिए प्रतिस्पर्धा करते हैं\n\n- कुल संदर्भ खपत: कोई भी कार्य शुरू होने से पहले ~77K टोकन\n\nटूल सर्च टूल के साथ:\n\n- केवल टूल सर्च टूल अग्रिम रूप से लोड किया गया (~500 टोकन)\n\n- आवश्यकतानुसार ऑन-डिमांड खोजे गए उपकरण (3-5 प्रासंगिक उपकरण, ~3K टोकन)\n\n- कुल संदर्भ खपत: ~8.7K टोकन, 95% संदर्भ विंडो को संरक्षित करना\n\nयह आपकी संपूर्ण टूल लाइब्रेरी तक पहुंच बनाए रखते हुए टोकन उपयोग में 85% की कमी दर्शाता है।बड़े उपकरण पुस्तकालयों के साथ काम करते समय आंतरिक परीक्षण ने एमसीपी मूल्यांकन पर महत्वपूर्ण सटीकता में सुधार दिखाया।टूल सर्च टूल सक्षम होने पर ओपस 4 49% से 74% तक सुधरा, और ओपस 4.5 79.5% से सुधरकर 88.1% हो गया।\n\nटूल सर्च टूल कैसे काम करता है टूल सर्च टूल क्लाउड को सभी परिभाषाओं को पहले से लोड करने के बजाय गतिशील रूप से टूल खोजने की सुविधा देता है।आप एपीआई को अपनी सभी टूल परिभाषाएँ प्रदान करते हैं, लेकिन टूल को ऑन-डिमांड खोजने योग्य बनाने के लिए defer_loading: true के साथ चिह्नित करते हैं।प्रारंभ में विलंबित उपकरण क्लाउड के संदर्भ में लोड नहीं किए गए हैं।क्लाउड केवल टूल सर्च टूल और defer_loading: false (आपके सबसे महत्वपूर्ण, अक्सर उपयोग किए जाने वाले टूल) वाले किसी भी टूल को देखता है।\n\nजब क्लाउड को विशिष्ट क्षमताओं की आवश्यकता होती है, तो वह प्रासंगिक टूल की खोज करता है।टूल सर्च टूल मिलान करने वाले टूल के संदर्भ लौटाता है, जो क्लाउड के संदर्भ में पूर्ण परिभाषाओं में विस्तारित हो जाते हैं।\n\nउदाहरण के लिए, यदि क्लाउड को GitHub के साथ इंटरैक्ट करने की आवश्यकता है, तो वह \"github\" खोजता है और केवल github.createPullRequest और github.listIssues लोड होते हैं-स्लैक, जिरा और Google ड्राइव से आपके अन्य 50+ टूल नहीं।\n\nइस तरह, क्लाउड को आपकी पूरी टूल लाइब्रेरी तक पहुंच प्राप्त हो जाती है, जबकि उसे वास्तव में आवश्यक टूल के लिए केवल टोकन लागत का भुगतान करना पड़ता है।\n\nप्रॉम्प्ट कैशिंग नोट: टूल सर्च टूल प्रॉम्प्ट कैशिंग को नहीं तोड़ता है क्योंकि विलंबित टूल को प्रारंभिक प्रॉम्प्ट से पूरी तरह से बाहर रखा गया है।क्लाउड द्वारा उनकी खोज करने के बाद ही उन्हें संदर्भ में जोड़ा जाता है, इसलिए आपके सिस्टम प्रॉम्प्ट और कोर टूल परिभाषाएँ कैश करने योग्य बनी रहती हैं।\n\nकार्यान्वयन:\n\n```\n{\n\"उपकरण\": [\n// एक टूल सर्च टूल शामिल करें (रेगेक्स, बीएम25, या कस्टम)\n{\"प्रकार\": \"टूल_सर्च_टूल_रेगेक्स_20251119\", \"नाम\": \"टूल_सर्च_टूल_रेगेक्स\"},\n\n// ऑन-डिमांड खोज के लिए उपकरण चिह्नित करें\n{\n\"नाम\": \"github.createPullRequest\",\n\"विवरण\": \"एक पुल अनुरोध बनाएँ\",\n\"इनपुट_स्कीमा\": {...},\n\"defer_loading\": सत्य\n}\n// ... defer_loading के साथ सैकड़ों और स्थगित उपकरण: सत्य\n]\n}\n```\n\nएमसीपी सर्वरों के लिए, आप विशिष्ट उच्च-उपयोग टूल लोड रखते हुए संपूर्ण सर्वर लोड करना स्थगित कर सकते हैं:\n\n```\n{\n\"प्रकार\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-drive\",\n\"default_config\": {\"defer_loading\": true}, # संपूर्ण सर्वर को लोड करना स्थगित करें\n\"कॉन्फ़िगरेशन\": {\n\"खोज_फ़ाइलें\": {\n\"defer_loading\": गलत\n} // सर्वाधिक उपयोग किये जाने वाले टूल को लोड रखें\n}\n}\n```\n\nक्लाउड डेवलपर प्लेटफ़ॉर्म रेगेक्स-आधारित और BM25-आधारित खोज टूल को बॉक्स से बाहर प्रदान करता है, लेकिन आप एम्बेडिंग या अन्य रणनीतियों का उपयोग करके कस्टम खोज टूल भी लागू कर सकते हैं।\n\nटूल सर्च टूल का उपयोग कब करें\n\nकिसी भी वास्तुशिल्प निर्णय की तरह, टूल सर्च टूल को सक्षम करने में ट्रेड-ऑफ़ शामिल होता है।टूल इनवोकेशन से पहले यह सुविधा एक खोज चरण जोड़ती है, इसलिए जब संदर्भ बचत और सटीकता में सुधार अतिरिक्त विलंबता से अधिक हो जाता है तो यह सर्वोत्तम आरओआई प्रदान करता है।\n\nइसका उपयोग तब करें जब:\n\n- टूल परिभाषाएँ >10K टोकन का उपभोग करती हैं\n\n- उपकरण चयन सटीकता संबंधी समस्याओं का अनुभव करना\n\n- कई सर्वरों के साथ एमसीपी-संचालित सिस्टम का निर्माण\n\n- 10+ उपकरण उपलब्ध हैं\n\nकम लाभकारी जब:\n\n- छोटी टूल लाइब्रेरी (<10 टूल)\n\n- प्रत्येक सत्र में बार-बार उपयोग किए जाने वाले सभी उपकरण\n\n- टूल परिभाषाएँ संक्षिप्त हैं\n\nप्रोग्रामेटिक टूल कॉलिंग\n\nचुनौती\n\nपारंपरिक टूल कॉलिंग दो मूलभूत समस्याएं पैदा करती है क्योंकि वर्कफ़्लो अधिक जटिल हो जाता है:\n\n- मध्यवर्ती परिणामों से संदर्भ प्रदूषण: जब क्लाउड त्रुटि पैटर्न के लिए 10 एमबी लॉग फ़ाइल का विश्लेषण करता है, तो पूरी फ़ाइल इसकी संदर्भ विंडो में प्रवेश करती है, भले ही क्लाउड को केवल त्रुटि आवृत्तियों के सारांश की आवश्यकता होती है।कई तालिकाओं में ग्राहक डेटा लाते समय, प्रत्येक रिकॉर्ड प्रासंगिकता की परवाह किए बिना संदर्भ में जमा होता है।ये मध्यवर्ती परिणाम बड़े पैमाने पर टोकन बजट का उपभोग करते हैं और महत्वपूर्ण जानकारी को संदर्भ विंडो से पूरी तरह बाहर धकेल सकते हैं।\n\n- अनुमान ओवरहेड और मैन्युअल संश्लेषण: प्रत्येक टूल कॉल के लिए पूर्ण मॉडल अनुमान पास की आवश्यकता होती है।परिणाम प्राप्त करने के बाद, क्लाउड को प्रासंगिक जानकारी निकालने के लिए डेटा पर \"आँख\" लगानी होगी, टुकड़े एक साथ कैसे फिट होते हैं इसके बारे में तर्क करना होगा, और प्राकृतिक भाषा प्रसंस्करण के माध्यम से आगे क्या करना है यह तय करना होगा।पांच टूल वर्कफ़्लो का अर्थ है पांच अनुमान पास करना और साथ ही क्लाउड द्वारा प्रत्येक परिणाम को पार्स करना, मूल्यों की तुलना करना और निष्कर्षों को संश्लेषित करना।यह धीमा और त्रुटि-प्रवण दोनों है।\n\nहमारा समाधान\n\nप्रोग्रामेटिक टूल कॉलिंग क्लाउड को व्यक्तिगत एपीआई राउंड-ट्रिप के बजाय कोड के माध्यम से टूल को व्यवस्थित करने में सक्षम बनाती है।क्लाउड द्वारा प्रत्येक परिणाम को उसके संदर्भ में लौटाए जाने के साथ एक समय में एक टूल का अनुरोध करने के बजाय, क्लाउड कोड लिखता है जो कई टूल को कॉल करता है, उनके आउटपुट को संसाधित करता है, और नियंत्रित करता है कि कौन सी जानकारी वास्तव में इसकी संदर्भ विंडो में प्रवेश करती है। क्लाउड कोड लिखने में उत्कृष्ट है और इसे प्राकृतिक भाषा टूल इनवोकेशन के बजाय पायथन में ऑर्केस्ट्रेशन तर्क व्यक्त करने की अनुमति देकर, आपको अधिक विश्वसनीय, सटीक नियंत्रण प्रवाह मिलता है।लूप्स, कंडीशनल्स, डेटा ट्रांसफॉर्मेशन और एरर हैंडलिंग सभी क्लाउड के तर्क में निहित होने के बजाय कोड में स्पष्ट हैं।\n\nउदाहरण: बजट अनुपालन जाँच\n\nएक सामान्य व्यावसायिक कार्य पर विचार करें: \"किस टीम के सदस्यों ने अपने Q3 यात्रा बजट को पार कर लिया?\"\n\nआपके पास तीन उपकरण उपलब्ध हैं:\n\n- get_team_members(विभाग) - आईडी और स्तरों के साथ टीम सदस्य सूची लौटाता है\n\n- get_expenses(user_id, तिमाही) - उपयोगकर्ता के लिए व्यय लाइन आइटम लौटाता है\n\n- get_budget_by_level(level) - कर्मचारी स्तर के लिए बजट सीमा लौटाता है\n\nपारंपरिक दृष्टिकोण:\n\n- टीम के सदस्यों को 20 लोगों को लाएं\n\n- प्रत्येक व्यक्ति के लिए, उनके Q3 खर्चों के लिए 20 टूल कॉल प्राप्त करें, प्रत्येक में 50-100 लाइन आइटम (उड़ानें, होटल, भोजन, रसीदें) हों।\n\n- कर्मचारी स्तर के अनुसार बजट सीमा प्राप्त करें\n\n- यह सब क्लाउड के संदर्भ में शामिल है: 2,000+ व्यय पंक्ति आइटम (50 KB+)\n\n- क्लाउड मैन्युअल रूप से प्रत्येक व्यक्ति के खर्चों का योग करता है, उनके बजट को देखता है, बजट सीमाओं के विरुद्ध खर्चों की तुलना करता है\n\n- मॉडल के लिए अधिक राउंड-ट्रिप, महत्वपूर्ण संदर्भ खपत\n\nप्रोग्रामेटिक टूल कॉलिंग के साथ:\n\nप्रत्येक टूल परिणाम क्लाउड पर लौटने के बजाय, क्लाउड एक पायथन स्क्रिप्ट लिखता है जो संपूर्ण वर्कफ़्लो को व्यवस्थित करता है।स्क्रिप्ट कोड एक्ज़ीक्यूशन टूल (एक सैंडबॉक्स्ड वातावरण) में चलती है, जब इसे आपके टूल से परिणामों की आवश्यकता होती है तो रुक जाती है।जब आप एपीआई के माध्यम से टूल परिणाम लौटाते हैं, तो उन्हें मॉडल द्वारा उपभोग किए जाने के बजाय स्क्रिप्ट द्वारा संसाधित किया जाता है।स्क्रिप्ट क्रियान्वित होती रहती है और क्लाउड केवल अंतिम आउटपुट देखता है।\n\n[[IMAGE_2|प्रोग्रामेटिक टूल कॉलिंग क्लाउड को अलग-अलग एपीआई राउंड-ट्रिप्स के बजाय कोड के माध्यम से टूल को ऑर्केस्ट्रेट करने में सक्षम बनाता है, जिससे समानांतर टूल निष्पादन की अनुमति मिलती है।]]\n\nबजट अनुपालन कार्य के लिए क्लाउड का ऑर्केस्ट्रेशन कोड इस प्रकार दिखता है:\n\n```\nटीम = प्रतीक्षा करें get_team_members(\"इंजीनियरिंग\")\n\n# प्रत्येक अद्वितीय स्तर के लिए बजट प्राप्त करें\nस्तर = सूची(सेट(एम[\"स्तर\"] टीम में एम के लिए))\nबजट_परिणाम = प्रतीक्षा करें asyncio.gather(*[\nस्तरों में स्तर के लिए get_budget_by_level(level)।\n])\n\n# एक लुकअप डिक्शनरी बनाएं: {\"जूनियर\": बजट1, \"सीनियर\": बजट2, ...}\nबजट = {स्तर: स्तर के लिए बजट, ज़िप में बजट(स्तर, बजट_परिणाम)}\n\n# सभी खर्चों को समानांतर रूप से प्राप्त करें\nव्यय = asyncio.gather की प्रतीक्षा करें(*[\nटीम में एम के लिए get_expenses(m[\"id\"], \"Q3\")\n])\n\n# ऐसे कर्मचारियों को ढूंढें जिन्होंने अपने यात्रा बजट को पार कर लिया है\nपार हो गया = []\nसदस्य के लिए, ज़िप में क्स्प (टीम, व्यय):\nबजट = बजट[सदस्य[\"स्तर\"]]\nकुल = योग(ई[\"राशि\"] ई के लिए ऍक्स्प में)\nयदि कुल > बजट[\"यात्रा_सीमा\"]:\nअधिक.जोड़ें({\n\"नाम\": सदस्य[\"नाम\"],\n\"खर्च\": कुल,\n\"सीमा\": बजट[\"यात्रा_सीमा\"]\n})\n\nप्रिंट(json.dumps(पार हो गया))\n```\n\nक्लाउड के संदर्भ से केवल अंतिम परिणाम प्राप्त होता है: दो से तीन लोग जिन्होंने अपना बजट पार कर लिया।2,000 से अधिक लाइन आइटम, मध्यवर्ती रकम और बजट लुकअप क्लाउड के संदर्भ को प्रभावित नहीं करते हैं, जिससे खपत 200KB कच्चे व्यय डेटा से घटकर केवल 1KB परिणाम रह जाती है।\n\nदक्षता लाभ पर्याप्त हैं:\n\n- टोकन बचत: मध्यवर्ती परिणामों को क्लाउड के संदर्भ से बाहर रखकर, पीटीसी नाटकीय रूप से टोकन खपत को कम कर देता है।औसत उपयोग 43,588 से घटकर 27,297 टोकन हो गया, जो जटिल अनुसंधान कार्यों पर 37% की कमी है।\n\n- कम विलंबता: प्रत्येक एपीआई राउंड-ट्रिप के लिए मॉडल अनुमान (सैकड़ों मिलीसेकंड से सेकंड) की आवश्यकता होती है।जब क्लाउड एक एकल कोड ब्लॉक में 20+ टूल कॉल को व्यवस्थित करता है, तो आप 19+ अनुमान पास को हटा देते हैं।एपीआई हर बार मॉडल पर वापस आए बिना टूल निष्पादन को संभालता है।\n\n- बेहतर सटीकता: स्पष्ट ऑर्केस्ट्रेशन तर्क लिखकर, क्लाउड प्राकृतिक भाषा में एकाधिक टूल परिणामों को संयोजित करने की तुलना में कम त्रुटियां करता है।आंतरिक ज्ञान पुनर्प्राप्ति 25.6% से बढ़कर 28.5% हो गई;जीआईए बेंचमार्क 46.5% से 51.2% तक।\n\nउत्पादन वर्कफ़्लो में गड़बड़ डेटा, सशर्त तर्क और संचालन शामिल होते हैं जिन्हें स्केल करने की आवश्यकता होती है।प्रोग्रामेटिक टूल कॉलिंग क्लाउड को कच्चे डेटा प्रोसेसिंग के बजाय कार्रवाई योग्य परिणामों पर अपना ध्यान केंद्रित करते हुए उस जटिलता को प्रोग्रामेटिक रूप से संभालने की सुविधा देता है।\n\nप्रोग्रामेटिक टूल कॉलिंग कैसे काम करती है\n\n1. टूल को कोड से कॉल करने योग्य के रूप में चिह्नित करें\n\nटूल में कोड_एक्ज़ीक्यूशन जोड़ें, और प्रोग्रामेटिक निष्पादन के लिए ऑप्ट-इन टूल में अनुमति_कॉलर्स सेट करें: ```\n{\n\"उपकरण\": [\n{\n\"प्रकार\": \"code_execution_20250825\",\n\"नाम\": \"कोड_निष्पादन\"\n},\n{\n\"नाम\": \"get_team_members\",\n\"विवरण\": \"विभाग के सभी सदस्यों को प्राप्त करें...\",\n\"इनपुट_स्कीमा\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # प्रोग्रामेटिक टूल कॉलिंग के लिए ऑप्ट-इन करें\n},\n{\n\"नाम\": \"get_expenses\",\n...\n},\n{\n\"नाम\": \"get_budget_by_level\",\n...\n}\n]\n}\n```\n\nएपीआई इन टूल परिभाषाओं को पायथन फ़ंक्शंस में परिवर्तित करता है जिन्हें क्लाउड कॉल कर सकता है।\n\n2. क्लाउड ऑर्केस्ट्रेशन कोड लिखता है\n\nएक समय में एक उपकरण का अनुरोध करने के बजाय, क्लाउड पायथन कोड उत्पन्न करता है:\n\n```\n{\n\"प्रकार\": \"सर्वर_टूल_उपयोग\",\n\"आईडी\": \"srvtoolu_abc\",\n\"नाम\": \"कोड_निष्पादन\",\n\"इनपुट\": {\n\"कोड\": \"टीम = get_team_members('इंजीनियरिंग')\\n...\" # उपरोक्त कोड उदाहरण\n}\n}\n```\n\n3. उपकरण क्लाउड के संदर्भ से टकराए बिना निष्पादित होते हैं\n\nजब कोड get_expenses() को कॉल करता है, तो आपको कॉलर फ़ील्ड के साथ एक टूल अनुरोध प्राप्त होता है:\n\n```\n{\n\"प्रकार\": \"टूल_यूज़\",\n\"आईडी\": \"टूलू_xyz\",\n\"नाम\": \"get_expenses\",\n\"इनपुट\": {\"user_id\": \"emp_123\", \"तिमाही\": \"Q3\"},\n\"कॉलर\": {\n\"प्रकार\": \"code_execution_20250825\",\n\"टूल_आईडी\": \"srvtoolu_abc\"\n}\n}\n```\n\nआप परिणाम प्रदान करते हैं, जिसे क्लाउड के संदर्भ के बजाय कोड निष्पादन वातावरण में संसाधित किया जाता है।यह अनुरोध-प्रतिक्रिया चक्र कोड में प्रत्येक टूल कॉल के लिए दोहराता है।\n\n4. केवल अंतिम आउटपुट ही संदर्भ में प्रवेश करता है\n\nजब कोड चलना समाप्त हो जाता है, तो केवल कोड के परिणाम क्लाउड को लौटाए जाते हैं:\n\n```\n{\n\"प्रकार\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"सामग्री\": {\n\"स्टडआउट\": \"[{\\\"नाम\\\": \"ऐलिस\\\", \"खर्च\\\": 12500, \"सीमा\\\": 10000}...]\"\n}\n}\n```\n\nक्लाउड यही सब देखता है, न कि रास्ते में संसाधित की गई 2000 से अधिक व्यय पंक्ति की वस्तुएँ।\n\nप्रोग्रामेटिक टूल कॉलिंग का उपयोग कब करें\n\nप्रोग्रामेटिक टूल कॉलिंग आपके वर्कफ़्लो में एक कोड निष्पादन चरण जोड़ता है।यह अतिरिक्त ओवरहेड तब फायदेमंद होता है जब टोकन बचत, विलंबता सुधार और सटीकता लाभ पर्याप्त होते हैं।\n\nसबसे अधिक लाभकारी जब:\n\n- बड़े डेटासेट को संसाधित करना जहां आपको केवल समुच्चय या सारांश की आवश्यकता होती है\n\n- तीन या अधिक निर्भर टूल कॉल के साथ मल्टी-स्टेप वर्कफ़्लो चलाना\n\n- क्लाउड द्वारा देखे जाने से पहले टूल परिणामों को फ़िल्टर करना, सॉर्ट करना या रूपांतरित करना\n\n- ऐसे कार्यों को संभालना जहां मध्यवर्ती डेटा क्लाउड के तर्क को प्रभावित नहीं करना चाहिए\n\n- कई वस्तुओं पर समानांतर संचालन चलाना (उदाहरण के लिए 50 समापन बिंदुओं की जाँच करना)\n\nकम लाभकारी जब:\n\n- सरल एकल-उपकरण मंगलाचरण बनाना\n\n- उन कार्यों पर काम करना जहां क्लाउड को सभी मध्यवर्ती परिणामों को देखना और तर्क करना चाहिए\n\n- छोटी प्रतिक्रियाओं के साथ त्वरित लुकअप चलाना\n\nउपकरण उपयोग के उदाहरण\n\nचुनौती\n\nJSON स्कीमा संरचना-प्रकार, आवश्यक फ़ील्ड, अनुमत एनम को परिभाषित करने में उत्कृष्टता प्राप्त करती है - लेकिन यह उपयोग पैटर्न को व्यक्त नहीं कर सकती है: वैकल्पिक पैरामीटर कब शामिल करना है, कौन सा संयोजन समझ में आता है, या आपका एपीआई किन सम्मेलनों की अपेक्षा करता है।\n\nएक समर्थन टिकट एपीआई पर विचार करें:\n\n```\n{\n\"नाम\": \"create_ticket\",\n\"इनपुट_स्कीमा\": {\n\"गुण\": {\n\"शीर्षक\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"प्राथमिकता\": {\"एनम\": [\"निम्न\", \"मध्यम\", \"उच्च\", \"महत्वपूर्ण\"]},\n\"लेबल\": {\"प्रकार\": \"सरणी\", \"आइटम\": {\"प्रकार\": \"स्ट्रिंग\"}},\n\"रिपोर्टर\": {\n\"प्रकार\": \"ऑब्जेक्ट\",\n\"गुण\": {\n\"आईडी\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"नाम\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"संपर्क करें\": {\n\"प्रकार\": \"ऑब्जेक्ट\",\n\"गुण\": {\n\"ईमेल\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"फ़ोन\": {\"प्रकार\": \"स्ट्रिंग\"}\n}\n}\n}\n},\n\"due_date\": {\"type\": \"string\"},\n\"वृद्धि\": {\n\"प्रकार\": \"ऑब्जेक्ट\",\n\"गुण\": {\n\"स्तर\": {\"प्रकार\": \"पूर्णांक\"},\n\"notify_manager\": {\"type\": \"boolean\"},\n\"sla_hours\": {\"type\": \"integer\"}\n}\n}\n},\n\"आवश्यक\": [\"शीर्षक\"]\n}\n}\n```\n\nस्कीमा परिभाषित करती है कि क्या मान्य है, लेकिन महत्वपूर्ण प्रश्नों को अनुत्तरित छोड़ देता है:\n\n- प्रारूप अस्पष्टता: क्या ड्यू_डेट में \"2024-11-06\", \"नवंबर 6, 2024\", या \"2024-11-06T00:00:00Z\" का उपयोग किया जाना चाहिए?\n\n- आईडी परंपराएं: क्या रिपोर्टर.आईडी एक यूयूआईडी है, \"यूएसआर-12345\", या सिर्फ \"12345\"?\n\n- नेस्टेड संरचना का उपयोग: क्लाउड को रिपोर्टर.संपर्क को कब पॉप्युलेट करना चाहिए?\n\n- पैरामीटर सहसंबंध: एस्केलेशन.लेवल और एस्केलेशन.sla_hours प्राथमिकता से कैसे संबंधित हैं?\n\nये अस्पष्टताएं विकृत टूल कॉल और असंगत पैरामीटर उपयोग का कारण बन सकती हैं।\n\nहमारा समाधान\n\nटूल उपयोग उदाहरण आपको सीधे अपनी टूल परिभाषाओं में नमूना टूल कॉल प्रदान करने देते हैं।केवल स्कीमा पर निर्भर रहने के बजाय, आप क्लाउड कंक्रीट उपयोग पैटर्न दिखाते हैं: ```\n{\n\"नाम\": \"create_ticket\",\n\"input_schema\": {/* उपरोक्त जैसा ही स्कीमा */ },\n\"इनपुट_उदाहरण\": [\n{\n\"शीर्षक\": \"लॉगिन पेज 500 त्रुटि देता है\",\n\"प्राथमिकता\": \"महत्वपूर्ण\",\n\"लेबल\": [\"बग\", \"प्रमाणीकरण\", \"उत्पादन\"],\n\"रिपोर्टर\": {\n\"आईडी\": \"यूएसआर-12345\",\n\"नाम\": \"जेन स्मिथ\",\n\"संपर्क करें\": {\n\"ईमेल\": \"jane@acme.com\",\n\"फ़ोन\": \"+1-555-0123\"\n}\n},\n\"नियत तिथि\": \"2024-11-06\",\n\"वृद्धि\": {\n\"स्तर\": 2,\n\"सूचित_प्रबंधक\": सत्य,\n\"sla_hours\": 4\n}\n},\n{\n\"शीर्षक\": \"डार्क मोड समर्थन जोड़ें\",\n\"लेबल\": [\"फ़ीचर-अनुरोध\", \"यूआई\"],\n\"रिपोर्टर\": {\n\"आईडी\": \"यूएसआर-67890\",\n\"नाम\": \"एलेक्स चेन\"\n}\n},\n{\n\"शीर्षक\": \"एपीआई दस्तावेज़ अपडेट करें\"\n}\n]\n}\n```\n\nइन तीन उदाहरणों से, क्लाउड सीखता है:\n\n- प्रारूप परंपराएँ: दिनांक YYYY-MM-DD का उपयोग करते हैं, उपयोगकर्ता आईडी USR-XXXXX का पालन करते हैं, लेबल कबाब-केस का उपयोग करते हैं\n\n- नेस्टेड संरचना पैटर्न: नेस्टेड संपर्क ऑब्जेक्ट के साथ रिपोर्टर ऑब्जेक्ट का निर्माण कैसे करें\n\n- वैकल्पिक पैरामीटर सहसंबंध: गंभीर बग में पूर्ण संपर्क जानकारी + सख्त एसएलए के साथ वृद्धि होती है;फीचर अनुरोधों में रिपोर्टर है लेकिन कोई संपर्क/एस्केलेशन नहीं है;आंतरिक कार्यों का केवल शीर्षक होता है\n\nहमारे अपने आंतरिक परीक्षण में, उपकरण उपयोग के उदाहरणों ने जटिल पैरामीटर हैंडलिंग पर सटीकता को 72% से 90% तक सुधार दिया।\n\nटूल का उपयोग कब करें उदाहरण उपयोग करें\n\nटूल उपयोग उदाहरण आपकी टूल परिभाषाओं में टोकन जोड़ते हैं, इसलिए जब सटीकता में सुधार अतिरिक्त लागत से अधिक हो जाता है तो वे सबसे मूल्यवान होते हैं।\n\nसबसे अधिक लाभकारी जब:\n\n- जटिल नेस्टेड संरचनाएं जहां वैध JSON सही उपयोग का संकेत नहीं देता है\n\n- कई वैकल्पिक मापदंडों और समावेशन पैटर्न वाले उपकरण मायने रखते हैं\n\n- डोमेन-विशिष्ट सम्मेलनों वाले एपीआई स्कीमा में कैप्चर नहीं किए गए हैं\n\n- समान उपकरण जहां उदाहरण स्पष्ट करते हैं कि किसका उपयोग करना है (उदाहरण के लिए, create_ticket बनाम create_incident )\n\nकम लाभकारी जब:\n\n- स्पष्ट उपयोग के साथ सरल एकल-पैरामीटर उपकरण\n\n- यूआरएल या ईमेल जैसे मानक प्रारूप जिन्हें क्लाउड पहले से ही समझता है\n\n- सत्यापन संबंधी चिंताओं को JSON स्कीमा बाधाओं द्वारा बेहतर ढंग से नियंत्रित किया जाता है\n\nसर्वोत्तम प्रथाएँ\n\nबिल्डिंग एजेंट जो वास्तविक दुनिया की कार्रवाई करते हैं, उनका अर्थ है पैमाने, जटिलता और सटीकता को एक साथ संभालना।उपकरण उपयोग वर्कफ़्लो में विभिन्न बाधाओं को हल करने के लिए ये तीन सुविधाएँ एक साथ काम करती हैं।यहां उन्हें प्रभावी ढंग से संयोजित करने का तरीका बताया गया है।\n\nपरत रणनीतिक रूप से सुविधाएँ\n\nप्रत्येक एजेंट को किसी दिए गए कार्य के लिए सभी तीन सुविधाओं का उपयोग करने की आवश्यकता नहीं है।अपनी सबसे बड़ी अड़चन से शुरुआत करें:\n\n- टूल परिभाषाओं टूल सर्च टूल से संदर्भ ब्लोट\n\n- बड़े मध्यवर्ती परिणाम संदर्भ को प्रदूषित करते हैं प्रोग्रामेटिक टूल कॉलिंग\n\n- पैरामीटर त्रुटियां और विकृत कॉल टूल उपयोग उदाहरण\n\nयह केंद्रित दृष्टिकोण आपको पहले से ही जटिलता जोड़ने के बजाय, आपके एजेंट के प्रदर्शन को सीमित करने वाली विशिष्ट बाधा को संबोधित करने देता है।\n\nफिर आवश्यकतानुसार अतिरिक्त सुविधाएँ जोड़ें।वे पूरक हैं: टूल सर्च टूल सुनिश्चित करता है कि सही टूल मिलें, प्रोग्रामेटिक टूल कॉलिंग कुशल निष्पादन सुनिश्चित करता है, और टूल उपयोग उदाहरण सही आह्वान सुनिश्चित करते हैं।\n\nबेहतर खोज के लिए टूल सर्च टूल सेट करें\n\nटूल खोज नामों और विवरणों से मेल खाती है, इसलिए स्पष्ट, वर्णनात्मक परिभाषाएं खोज सटीकता में सुधार करती हैं।\n\n```\n// अच्छा\n{\n\"नाम\": \"खोज_ग्राहक_आदेश\",\n\"विवरण\": \"तिथि सीमा, स्थिति या कुल राशि के आधार पर ग्राहक के ऑर्डर खोजें। आइटम, शिपिंग और भुगतान जानकारी सहित ऑर्डर विवरण लौटाता है।\"\n}\n\n// ख़राब\n{\n\"नाम\": \"query_db_orders\",\n\"विवरण\": \"आदेश क्वेरी निष्पादित करें\"\n}\n```\n\nसिस्टम प्रॉम्प्ट मार्गदर्शन जोड़ें ताकि क्लाउड को पता चले कि क्या उपलब्ध है:\n\n```\nआपके पास स्लैक मैसेजिंग, Google ड्राइव फ़ाइल प्रबंधन, के लिए टूल तक पहुंच है।\nजीरा टिकट ट्रैकिंग, और GitHub रिपॉजिटरी संचालन।खोज टूल का उपयोग करें\nविशिष्ट क्षमताओं को खोजने के लिए.\n```\n\nअपने तीन से पांच सबसे अधिक उपयोग किए जाने वाले उपकरणों को हमेशा लोड रखें, बाकी को स्थगित कर दें।यह अन्य सभी चीज़ों के लिए ऑन-डिमांड खोज के साथ सामान्य परिचालनों के लिए तत्काल पहुंच को संतुलित करता है।\n\nसही निष्पादन के लिए प्रोग्रामेटिक टूल कॉलिंग सेट करें\n\nचूंकि क्लाउड टूल आउटपुट को पार्स करने के लिए कोड लिखता है, दस्तावेज़ रिटर्न प्रारूप स्पष्ट रूप से होता है।इससे क्लाउड को सही पार्सिंग तर्क लिखने में मदद मिलती है: ```\n{\n\"नाम\": \"get_orders\",\n\"विवरण\": \"किसी ग्राहक के लिए ऑर्डर पुनर्प्राप्त करें।\nरिटर्न:\nऑर्डर ऑब्जेक्ट की सूची, प्रत्येक में शामिल हैं:\n- आईडी (str): ऑर्डर पहचानकर्ता\n- कुल (फ्लोट): कुल ऑर्डर USD में\n- स्थिति (str): 'लंबित', 'भेजा गया', 'वितरित' में से एक\n- आइटम (सूची): {sku, मात्रा, मूल्य} की सरणी\n- create_at (str): आईएसओ 8601 टाइमस्टैम्प\"\n}\n```\n\nप्रोग्रामेटिक ऑर्केस्ट्रेशन से लाभ उठाने वाले ऑप्ट-इन टूल के लिए नीचे देखें:\n\n- उपकरण जो समानांतर में चल सकते हैं (स्वतंत्र संचालन)\n\n- पुनः प्रयास करने के लिए संचालन सुरक्षित (बेवकूफ)\n\nपैरामीटर सटीकता के लिए टूल उपयोग उदाहरण सेट करें\n\nव्यवहारिक स्पष्टता के लिए शिल्प उदाहरण:\n\n- यथार्थवादी डेटा का उपयोग करें (वास्तविक शहर के नाम, उचित कीमतें, \"स्ट्रिंग\" या \"मूल्य\" नहीं)\n\n- न्यूनतम, आंशिक और पूर्ण विनिर्देश पैटर्न के साथ विविधता दिखाएं\n\n- इसे संक्षिप्त रखें: प्रति टूल 1-5 उदाहरण\n\n- अस्पष्टता पर ध्यान दें (केवल ऐसे उदाहरण जोड़ें जहां स्कीमा से सही उपयोग स्पष्ट न हो)\n\nआरंभ करना\n\nये सुविधाएं बीटा में उपलब्ध हैं.उन्हें सक्षम करने के लिए, बीटा हेडर जोड़ें और आवश्यक उपकरण शामिल करें:\n\n```\nclient.beta.messages.create(\nbetas=[\"उन्नत-उपकरण-उपयोग-2025-11-20\"],\nमॉडल = \"क्लाउड-सॉनेट-4-5-20250929\",\nmax_tokens=4096,\nउपकरण=[\n{\"प्रकार\": \"टूल_सर्च_टूल_रेगेक्स_20251119\", \"नाम\": \"टूल_सर्च_टूल_रेगेक्स\"},\n{\"प्रकार\": \"code_execution_20250825\", \"नाम\": \"code_execution\"},\n# आपके टूल defer_loading, स्वीकृत_कॉलर्स और इनपुट_examples के साथ\n]\n)\n```\n\nविस्तृत एपीआई दस्तावेज़ीकरण और एसडीके उदाहरणों के लिए, हमारा देखें:\n\n- टूल सर्च टूल के लिए डी डॉक्यूमेंटेशन और कुकबुक\n\n- प्रोग्रामेटिक टूल कॉलिंग के लिए दस्तावेज़ीकरण और कुकबुक\n\n- उपकरण उपयोग उदाहरणों के लिए दस्तावेज़ीकरण\n\nये सुविधाएँ टूल के उपयोग को सरल फ़ंक्शन कॉलिंग से बुद्धिमान ऑर्केस्ट्रेशन की ओर ले जाती हैं।जैसे-जैसे एजेंट दर्जनों उपकरणों और बड़े डेटासेटों में फैले अधिक जटिल वर्कफ़्लो से निपटते हैं, गतिशील खोज, कुशल निष्पादन और विश्वसनीय आह्वान मूलभूत बन जाते हैं।\n\nहम यह देखने के लिए उत्साहित हैं कि आप क्या बनाते हैं।\n\nआभार\n\nबिन वू द्वारा लिखित, एडम जोन्स, आर्टूर रेनॉल्ट, हेनरी टे, जेक नोबल, नाथन मैककैंडलिश, नूह पिकार्ड, सैम जियांग और क्लाउड डेवलपर प्लेटफ़ॉर्म टीम के योगदान के साथ।यह कार्य क्रिस गोर्गोलेव्स्की, डैनियल जियांग, जेरेमी फॉक्स और माइक लैम्बर्ट के मूलभूत शोध पर आधारित है।हमने एआई पारिस्थितिकी तंत्र से भी प्रेरणा ली, जिसमें जोएल पोबार के एलएलएमवीएम, क्लाउडफ्लेयर के कोड मोड और एमसीपी के रूप में कोड निष्पादन शामिल हैं।एंडी शूमिस्टर, हामिश केर, कीर ब्रैडवेल, मैट ब्लेइफ़र और मौली वोरवर्क को उनके समर्थन के लिए विशेष धन्यवाद।",
        "edited": false
      }
    },
    "metadata": {
      "tags": [
        "Anthropic",
        "MCP",
        "Tooling"
      ]
    }
  },
  {
    "id": "sample-anthropic-code-execution",
    "source": "Anthropic",
    "source_url": "https://www.anthropic.com/engineering/code-execution-with-mcp",
    "title": "Code execution with MCP: Building more efficient agents",
    "author": "Anthropic Engineering",
    "published_date": "2025-11-04T00:00:00Z",
    "scraped_at": 1733203200000,
    "status": "published",
    "content": {
      "original_html": "",
      "text": "The Model Context Protocol (MCP) is an open standard for connecting AI agents to external systems. Connecting agents to tools and data traditionally requires a custom integration for each pairing, creating fragmentation and duplicated effort that makes it difficult to scale truly connected systems. MCP provides a universal protocol-developers implement MCP once in their agent and it unlocks an entire ecosystem of integrations.\n\nSince launching MCP in November 2024, adoption has been rapid: the community has built thousands of MCP servers , SDKs are available for all major programming languages, and the industry has adopted MCP as the de-facto standard for connecting agents to tools and data.\n\nToday developers routinely build agents with access to hundreds or thousands of tools across dozens of MCP servers. However, as the number of connected tools grows, loading all tool definitions upfront and passing intermediate results through the context window slows down agents and increases costs.\n\nIn this blog we'll explore how code execution can enable agents to interact with MCP servers more efficiently, handling more tools while using fewer tokens.\n\nExcessive token consumption from tools makes agents less efficient\n\nAs MCP usage scales, there are two common patterns that can increase agent cost and latency:\n\n- Tool definitions overload the context window;\n\n- Intermediate tool results consume additional tokens.\n\n1. Tool definitions overload the context window\n\nMost MCP clients load all tool definitions upfront directly into context, exposing them to the model using a direct tool-calling syntax. These tool definitions might look like:\n\n```\ngdrive.getDocument\n     Description: Retrieves a document from Google Drive\n     Parameters:\n                documentId (required, string): The ID of the document to retrieve\n                fields (optional, string): Specific fields to return\n     Returns: Document object with title, body content, metadata, permissions, etc.\n```\n\n```\nsalesforce.updateRecord\n    Description: Updates a record in Salesforce\n    Parameters:\n               objectType (required, string): Type of Salesforce object (Lead, Contact,      Account, etc.)\n               recordId (required, string): The ID of the record to update\n               data (required, object): Fields to update with their new values\n     Returns: Updated record object with confirmation\n```\n\nTool descriptions occupy more context window space, increasing response time and costs. In cases where agents are connected to thousands of tools, they'll need to process hundreds of thousands of tokens before reading a request.\n\n2. Intermediate tool results consume additional tokens\n\nMost MCP clients allow models to directly call MCP tools. For example, you might ask your agent: \"Download my meeting transcript from Google Drive and attach it to the Salesforce lead.\"\n\nThe model will make calls like:\n\n```\nTOOL CALL: gdrive.getDocument(documentId: \"abc123\")\n        → returns \"Discussed Q4 goals...\\n[full transcript text]\"\n           (loaded into model context)\n\nTOOL CALL: salesforce.updateRecord(\n\t\t\tobjectType: \"SalesMeeting\",\n\t\t\trecordId: \"00Q5f000001abcXYZ\",\n  \t\t\tdata: { \"Notes\": \"Discussed Q4 goals...\\n[full transcript text written out]\" }\n\t\t)\n\t\t(model needs to write entire transcript into context again)\n```\n\nEvery intermediate result must pass through the model. In this example, the full call transcript flows through twice. For a 2-hour sales meeting, that could mean processing an additional 50,000 tokens. Even larger documents may exceed context window limits, breaking the workflow.\n\nWith large documents or complex data structures, models may be more likely to make mistakes when copying data between tool calls.\n\n[[IMAGE_1|The MCP client loads tool definitions into the model's context window and orchestrates a message loop where each tool call and result passes through the model between operations.]]\n\nCode execution with MCP improves context efficiency\n\nWith code execution environments becoming more common for agents, a solution is to present MCP servers as code APIs rather than direct tool calls. The agent can then write code to interact with MCP servers. This approach addresses both challenges: agents can load only the tools they need and process data in the execution environment before passing results back to the model.\n\nThere are a number of ways to do this. One approach is to generate a file tree of all available tools from connected MCP servers. Here's an implementation using TypeScript:\n\n```\nservers\n├── google-drive\n│   ├── getDocument.ts\n│   ├── ... (other tools)\n│   └── index.ts\n├── salesforce\n│   ├── updateRecord.ts\n│   ├── ... (other tools)\n│   └── index.ts\n└── ... (other servers)\n```\n\nThen each tool corresponds to a file, something like:\n\n```\n// ./servers/google-drive/getDocument.ts\nimport { callMCPTool } from \"../../../client.js\";\n\ninterface GetDocumentInput {\n  documentId: string;\n}\n\ninterface GetDocumentResponse {\n  content: string;\n}\n\n/* Read a document from Google Drive */\nexport async function getDocument(input: GetDocumentInput): Promise<GetDocumentResponse> {\n  return callMCPTool<GetDocumentResponse>('google_drive__get_document', input);\n}\n```\n\nOur Google Drive to Salesforce example above becomes the code:\n\n```\n// Read transcript from Google Docs and add to Salesforce prospect\nimport * as gdrive from './servers/google-drive';\nimport * as salesforce from './servers/salesforce';\n\nconst transcript = (await gdrive.getDocument({ documentId: 'abc123' })).content;\nawait salesforce.updateRecord({\n  objectType: 'SalesMeeting',\n  recordId: '00Q5f000001abcXYZ',\n  data: { Notes: transcript }\n});\n```\n\nThe agent discovers tools by exploring the filesystem: listing the ./servers/ directory to find available servers (like google-drive and salesforce ), then reading the specific tool files it needs (like getDocument.ts and updateRecord.ts ) to understand each tool's interface. This lets the agent load only the definitions it needs for the current task. This reduces the token usage from 150,000 tokens to 2,000 tokens-a time and cost saving of 98.7% .\n\nCloudflare published similar findings , referring to code execution with MCP as \"Code Mode.\" The core insight is the same: LLMs are adept at writing code and developers should take advantage of this strength to build agents that interact with MCP servers more efficiently.\n\nBenefits of code execution with MCP\n\nCode execution with MCP enables agents to use context more efficiently by loading tools on demand, filtering data before it reaches the model, and executing complex logic in a single step. There are also security and state management benefits to using this approach.\n\nProgressive disclosure\n\nModels are great at navigating filesystems. Presenting tools as code on a filesystem allows models to read tool definitions on-demand, rather than reading them all up-front.\n\nAlternatively, a search_tools tool can be added to the server to find relevant definitions. For example, when working with the hypothetical Salesforce server used above, the agent searches for \"salesforce\" and loads only those tools that it needs for the current task. Including a detail level parameter in the search_tools tool that allows the agent to select the level of detail required (such as name only, name and description, or the full definition with schemas) also helps the agent conserve context and find tools efficiently.\n\nContext efficient tool results\n\nWhen working with large datasets, agents can filter and transform results in code before returning them. Consider fetching a 10,000-row spreadsheet:\n\n```\n// Without code execution - all rows flow through context\nTOOL CALL: gdrive.getSheet(sheetId: 'abc123')\n        → returns 10,000 rows in context to filter manually\n\n// With code execution - filter in the execution environment\nconst allRows = await gdrive.getSheet({ sheetId: 'abc123' });\nconst pendingOrders = allRows.filter(row => \n  row[\"Status\"] === 'pending'\n);\nconsole.log(`Found ${pendingOrders.length} pending orders`);\nconsole.log(pendingOrders.slice(0, 5)); // Only log first 5 for review\n```\n\nThe agent sees five rows instead of 10,000. Similar patterns work for aggregations, joins across multiple data sources, or extracting specific fields-all without bloating the context window.\n\nMore powerful and context-efficient control flow\n\nLoops, conditionals, and error handling can be done with familiar code patterns rather than chaining individual tool calls. For example, if you need a deployment notification in Slack, the agent can write:\n\n```\nlet found = false;\nwhile (!found) {\n  const messages = await slack.getChannelHistory({ channel: 'C123456' });\n  found = messages.some(m => m.text.includes('deployment complete'));\n  if (!found) await new Promise(r => setTimeout(r, 5000));\n}\nconsole.log('Deployment notification received');\n```\n\nThis approach is more efficient than alternating between MCP tool calls and sleep commands through the agent loop.\n\nAdditionally, being able to write out a conditional tree that gets executed also saves on \"time to first token\" latency: rather than having to wait for a model to evaluate an if-statement, the agent can let the code execution environment do this.\n\nPrivacy-preserving operations\n\nWhen agents use code execution with MCP, intermediate results stay in the execution environment by default. This way, the agent only sees what you explicitly log or return, meaning data you don't wish to share with the model can flow through your workflow without ever entering the model's context.\n\nFor even more sensitive workloads, the agent harness can tokenize sensitive data automatically. For example, imagine you need to import customer contact details from a spreadsheet into Salesforce. The agent writes:\n\n```\nconst sheet = await gdrive.getSheet({ sheetId: 'abc123' });\nfor (const row of sheet.rows) {\n  await salesforce.updateRecord({\n    objectType: 'Lead',\n    recordId: row.salesforceId,\n    data: { \n      Email: row.email,\n      Phone: row.phone,\n      Name: row.name\n    }\n  });\n}\nconsole.log(`Updated ${sheet.rows.length} leads`);\n```\n\nThe MCP client intercepts the data and tokenizes PII before it reaches the model:\n\n```\n// What the agent would see, if it logged the sheet.rows:\n[\n  { salesforceId: '00Q...', email: '[EMAIL_1]', phone: '[PHONE_1]', name: '[NAME_1]' },\n  { salesforceId: '00Q...', email: '[EMAIL_2]', phone: '[PHONE_2]', name: '[NAME_2]' },\n  ...\n]\n```\n\nThen, when the data is shared in another MCP tool call, it is untokenized via a lookup in the MCP client. The real email addresses, phone numbers, and names flow from Google Sheets to Salesforce, but never through the model. This prevents the agent from accidentally logging or processing sensitive data. You can also use this to define deterministic security rules, choosing where data can flow to and from.\n\nState persistence and skills\n\nCode execution with filesystem access allows agents to maintain state across operations. Agents can write intermediate results to files, enabling them to resume work and track progress:\n\n```\nconst leads = await salesforce.query({ \n  query: 'SELECT Id, Email FROM Lead LIMIT 1000' \n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nawait fs.writeFile('./workspace/leads.csv', csvData);\n\n// Later execution picks up where it left off\nconst saved = await fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nAgents can also persist their own code as reusable functions. Once an agent develops working code for a task, it can save that implementation for future use:\n\n```\n// In ./skills/save-sheet-as-csv.ts\nimport * as gdrive from './servers/google-drive';\nexport async function saveSheetAsCsv(sheetId: string) {\n  const data = await gdrive.getSheet({ sheetId });\n  const csv = data.map(row => row.join(',')).join('\\n');\n  await fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\n  return `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Later, in any agent execution:\nimport { saveSheetAsCsv } from './skills/save-sheet-as-csv';\nconst csvPath = await saveSheetAsCsv('abc123');\n```\n\nThis ties in closely to the concept of Skills , folders of reusable instructions, scripts, and resources for models to improve performance on specialized tasks. Adding a SKILL.md file to these saved functions creates a structured skill that models can reference and use. Over time, this allows your agent to build a toolbox of higher-level capabilities, evolving the scaffolding that it needs to work most effectively.\n\nNote that code execution introduces its own complexity. Running agent-generated code requires a secure execution environment with appropriate sandboxing , resource limits, and monitoring. These infrastructure requirements add operational overhead and security considerations that direct tool calls avoid. The benefits of code execution-reduced token costs, lower latency, and improved tool composition-should be weighed against these implementation costs.\n\nSummary\n\nMCP provides a foundational protocol for agents to connect to many tools and systems. However, once too many servers are connected, tool definitions and results can consume excessive tokens, reducing agent efficiency.\n\nAlthough many of the problems here feel novel-context management, tool composition, state persistence-they have known solutions from software engineering. Code execution applies these established patterns to agents, letting them use familiar programming constructs to interact with MCP servers more efficiently. If you implement this approach, we encourage you to share your findings with the MCP community .\n\nAcknowledgments\n\nThis article was written by Adam Jones and Conor Kelly. Thanks to Jeremy Fox, Jerome Swannack, Stuart Ritchie, Molly Vorwerck, Matt Samuels, and Maggie Vo for feedback on drafts of this post.",
      "images": [
        "https://www-cdn.anthropic.com/images/4zrzovbb/website/42f40f6fae9ec2d7cf2e5a98908a16d0216b91be-1000x1000.svg",
        "https://www-cdn.anthropic.com/images/4zrzovbb/website/9ecf165020005c09a22a9472cee6309555485619-1920x1080.png"
      ]
    },
    "translations": {
      "es": {
        "title": "Ejecución de código con MCP: creación de agentes más eficientes",
        "content": "El Model Context Protocol (MCP) es un estándar abierto para conectar agentes de IA a sistemas externos.Conectar agentes a herramientas y datos tradicionalmente requiere una integración personalizada para cada emparejamiento, lo que genera fragmentación y esfuerzos duplicados que dificultan la ampliación de sistemas verdaderamente conectados.MCP proporciona un protocolo universal: los desarrolladores implementan MCP una vez en su agente y desbloquea un ecosistema completo de integraciones.\n\nDesde el lanzamiento de MCP en noviembre de 2024, la adopción ha sido rápida: la comunidad ha creado miles de servidores MCP, hay SDK disponibles para todos los principales lenguajes de programación y la industria ha adoptado MCP como el estándar de facto para conectar agentes a herramientas y datos.\n\nHoy en día, los desarrolladores crean rutinariamente agentes con acceso a cientos o miles de herramientas en docenas de servidores MCP.Sin embargo, a medida que crece el número de herramientas conectadas, cargar todas las definiciones de herramientas por adelantado y pasar resultados intermedios a través de la ventana contextual ralentiza a los agentes y aumenta los costos.\n\nEn este blog exploraremos cómo la ejecución de código puede permitir que los agentes interactúen con los servidores MCP de manera más eficiente, manejando más herramientas y usando menos tokens.\n\nEl consumo excesivo de tokens de las herramientas hace que los agentes sean menos eficientes\n\nA medida que aumenta el uso de MCP, existen dos patrones comunes que pueden aumentar el costo y la latencia del agente:\n\n- Las definiciones de herramientas sobrecargan la ventana contextual;\n\n- Los resultados de la herramienta intermedia consumen tokens adicionales.\n\n1. Las definiciones de herramientas sobrecargan la ventana contextual\n\nLa mayoría de los clientes MCP cargan todas las definiciones de herramientas por adelantado directamente en el contexto, exponiéndolas al modelo mediante una sintaxis de llamada directa a herramientas.Estas definiciones de herramientas podrían verse así:\n\n```\ngdrive.getDocumento\nDescripción: Recupera un documento de Google Drive\nParámetros:\ndocumentId (obligatorio, cadena): el ID del documento a recuperar\ncampos (opcional, cadena): campos específicos para devolver\nDevuelve: Objeto de documento con título, contenido del cuerpo, metadatos, permisos, etc.\n```\n\n```\nsalesforce.updateRecord\nDescripción: Actualiza un registro en Salesforce\nParámetros:\nobjectType (obligatorio, cadena): tipo de objeto de Salesforce (cliente potencial, contacto, cuenta, etc.)\nrecordId (obligatorio, cadena): el ID del registro a actualizar\ndatos (obligatorio, objeto): Campos para actualizar con sus nuevos valores\nDevoluciones: objeto de registro actualizado con confirmación\n```\n\nLas descripciones de las herramientas ocupan más espacio en la ventana contextual, lo que aumenta el tiempo de respuesta y los costos.En los casos en que los agentes estén conectados a miles de herramientas, necesitarán procesar cientos de miles de tokens antes de leer una solicitud.\n\n2. Los resultados de la herramienta intermedia consumen tokens adicionales\n\nLa mayoría de los clientes MCP permiten que los modelos llamen directamente a las herramientas MCP.Por ejemplo, podría preguntarle a su agente: \"Descargue la transcripción de mi reunión desde Google Drive y adjúntela al cliente potencial de Salesforce\".\n\nEl modelo hará llamadas como:\n\n```\nLLAMADA DE HERRAMIENTA: gdrive.getDocument(documentId: \"abc123\")\n→ devuelve \"Se discutieron los objetivos del cuarto trimestre...\\n[texto de la transcripción completa]\"\n(cargado en el contexto del modelo)\n\nLLAMADA DE HERRAMIENTA: salesforce.updateRecord(\ntipo de objeto: \"Reunión de ventas\",\nID de registro: \"00Q5f000001abcXYZ\",\ndata: { \"Notas\": \"Se discutieron los objetivos del cuarto trimestre...\\n[texto de la transcripción completa escrito]\" }\n)\n(El modelo necesita volver a escribir la transcripción completa en contexto)\n```\n\nCada resultado intermedio debe pasar por el modelo.En este ejemplo, la transcripción completa de la llamada se transmite dos veces.Para una reunión de ventas de 2 horas, eso podría significar procesar 50.000 tokens adicionales.Incluso los documentos más grandes pueden exceder los límites de la ventana contextual, interrumpiendo el flujo de trabajo.\n\nCon documentos grandes o estructuras de datos complejas, es más probable que los modelos cometan errores al copiar datos entre llamadas a herramientas.\n\n[[IMAGE_1|El cliente MCP carga definiciones de herramientas en la ventana contextual del modelo y organiza un bucle de mensajes donde cada llamada de herramienta y resultado pasa a través del modelo entre operaciones.]]\n\nLa ejecución de código con MCP mejora la eficiencia del contexto\n\nDado que los entornos de ejecución de código se vuelven más comunes para los agentes, una solución es presentar los servidores MCP como API de código en lugar de llamadas directas a herramientas.Luego, el agente puede escribir código para interactuar con los servidores MCP.Este enfoque aborda ambos desafíos: los agentes pueden cargar solo las herramientas que necesitan y procesar datos en el entorno de ejecución antes de devolver los resultados al modelo. Hay varias formas de hacer esto.Un enfoque es generar un árbol de archivos de todas las herramientas disponibles desde los servidores MCP conectados.Aquí hay una implementación usando TypeScript:\n\n```\nservidores\n├── google-drive\n│ ├── getDocument.ts\n│ ├── ... (otras herramientas)\n│ └── index.ts\n├── fuerza de ventas\n│ ├── actualizarRecord.ts\n│ ├── ... (otras herramientas)\n│ └── index.ts\n└──... (otros servidores)\n```\n\nEntonces cada herramienta corresponde a un archivo, algo así como:\n\n```\n// ./servers/google-drive/getDocument.ts\nimportar { callMCPTool } desde \"../../../client.js\";\n\ninterfaz GetDocumentInput {\nID de documento: cadena;\n}\n\ninterfaz GetDocumentResponse {\ncontenido: cadena;\n}\n\n/* Leer un documento de Google Drive */\nexportar función asíncrona getDocument(entrada: GetDocumentInput): Promesa<GetDocumentResponse> {\ndevolver callMCPTool<GetDocumentResponse>('google_drive__get_document', entrada);\n}\n```\n\nNuestro ejemplo anterior de Google Drive a Salesforce se convierte en el código:\n\n```\n// Leer la transcripción de Google Docs y agregarla al prospecto de Salesforce\nimportar * como gdrive desde './servers/google-drive';\nimportar * como Salesforce desde './servers/salesforce';\n\nconst transcript = (await gdrive.getDocument({ documentId: 'abc123' })).content;\nespere salesforce.updateRecord({\ntipo de objeto: 'Reunión de ventas',\nID de registro: '00Q5f000001abcXYZ',\ndatos: { Notas: transcripción }\n});\n```\n\nEl agente descubre herramientas explorando el sistema de archivos: enumera el directorio ./servers/ para encontrar servidores disponibles (como google-drive y salesforce) y luego lee los archivos de herramientas específicos que necesita (como getDocument.ts y updateRecord.ts) para comprender la interfaz de cada herramienta.Esto permite que el agente cargue solo las definiciones que necesita para la tarea actual.Esto reduce el uso de tokens de 150.000 tokens a 2.000 tokens, un ahorro de tiempo y costos del 98,7%.\n\nCloudflare publicó hallazgos similares, refiriéndose a la ejecución de código con MCP como \"Modo de código\".La idea central es la misma: los LLM son expertos en escribir código y los desarrolladores deberían aprovechar esta fortaleza para crear agentes que interactúen con los servidores MCP de manera más eficiente.\n\nBeneficios de la ejecución de código con MCP\n\nLa ejecución de código con MCP permite a los agentes utilizar el contexto de manera más eficiente al cargar herramientas bajo demanda, filtrar datos antes de que lleguen al modelo y ejecutar lógica compleja en un solo paso.También existen beneficios de seguridad y gestión del estado al utilizar este enfoque.\n\nDivulgación progresiva\n\nLos modelos son excelentes para navegar por sistemas de archivos.Presentar herramientas como código en un sistema de archivos permite a los modelos leer definiciones de herramientas bajo demanda, en lugar de leerlas todas por adelantado.\n\nAlternativamente, se puede agregar una herramienta search_tools al servidor para encontrar definiciones relevantes.Por ejemplo, cuando se trabaja con el servidor hipotético de Salesforce utilizado anteriormente, el agente busca \"salesforce\" y carga solo aquellas herramientas que necesita para la tarea actual.Incluir un parámetro de nivel de detalle en la herramienta search_tools que permita al agente seleccionar el nivel de detalle requerido (como solo nombre, nombre y descripción, o la definición completa con esquemas) también ayuda al agente a conservar el contexto y encontrar herramientas de manera eficiente.\n\nResultados de herramientas contextualmente eficientes\n\nCuando trabajan con grandes conjuntos de datos, los agentes pueden filtrar y transformar los resultados en código antes de devolverlos.Considere buscar una hoja de cálculo de 10.000 filas:\n\n```\n// Sin ejecución de código: todas las filas fluyen a través del contexto\nLLAMADA DE HERRAMIENTA: gdrive.getSheet(sheetId: 'abc123')\n→ devuelve 10.000 filas en contexto para filtrar manualmente\n\n// Con ejecución de código - filtrar en el entorno de ejecución\nconst allRows = await gdrive.getSheet({ hojaId: 'abc123' });\nconst pedidos pendientes = todas las filas.filtro (fila =>\nfila[\"Estado\"] === 'pendiente'\n);\nconsole.log(`Se encontraron ${pendingOrders.length} pedidos pendientes`);\nconsole.log(pendingOrders.slice(0, 5));// Registra solo los primeros 5 para revisión\n```\n\nEl agente ve cinco filas en lugar de 10.000.Patrones similares funcionan para agregaciones, uniones entre múltiples fuentes de datos o extracción de campos específicos, todo sin inflar la ventana contextual.\n\nFlujo de control más potente y contextualmente eficiente\n\nLos bucles, los condicionales y el manejo de errores se pueden realizar con patrones de código familiares en lugar de encadenar llamadas a herramientas individuales.Por ejemplo, si necesita una notificación de implementación en Slack, el agente puede escribir: ```\ndejar encontrado = falso;\nmientras (! encontrado) {\nmensajes constantes = await slack.getChannelHistory({ canal: 'C123456' });\nencontrado = mensajes.algunos(m => m.text.includes('implementación completa'));\nif (!found) espera nueva Promesa(r => setTimeout(r, 5000));\n}\nconsole.log('Notificación de implementación recibida');\n```\n\nEste enfoque es más eficiente que alternar entre llamadas a herramientas MCP y comandos de suspensión a través del bucle del agente.\n\nAdemás, poder escribir un árbol condicional que se ejecuta también ahorra latencia de \"tiempo hasta el primer token\": en lugar de tener que esperar a que un modelo evalúe una declaración if, el agente puede dejar que el entorno de ejecución de código haga esto.\n\nOperaciones que preservan la privacidad\n\nCuando los agentes utilizan la ejecución de código con MCP, los resultados intermedios permanecen en el entorno de ejecución de forma predeterminada.De esta manera, el agente solo ve lo que usted registra o devuelve explícitamente, lo que significa que los datos que no desea compartir con el modelo pueden fluir a través de su flujo de trabajo sin siquiera ingresar al contexto del modelo.\n\nPara cargas de trabajo aún más confidenciales, el arnés del agente puede tokenizar datos confidenciales automáticamente.Por ejemplo, imagine que necesita importar datos de contacto de un cliente desde una hoja de cálculo a Salesforce.El agente escribe:\n\n```\nhoja const = espera gdrive.getSheet({ hojaId: 'abc123' });\npara (fila constante de hoja.filas) {\nespere salesforce.updateRecord({\ntipo de objeto: 'plomo',\nrecordId: fila.salesforceId,\ndatos: {\nCorreo electrónico: fila.correo electrónico,\nTeléfono: fila.teléfono,\nNombre: fila.nombre\n}\n});\n}\nconsole.log(`Clientes potenciales ${sheet.rows.length} actualizados`);\n```\n\nEl cliente MCP intercepta los datos y tokeniza la PII antes de que llegue al modelo:\n\n```\n// Lo que vería el agente si registrara la hoja.filas:\n[\n{ salesforceId: '00Q...', correo electrónico: '[EMAIL_1]', teléfono: '[PHONE_1]', nombre: '[NAME_1]' },\n{ salesforceId: '00Q...', correo electrónico: '[EMAIL_2]', teléfono: '[PHONE_2]', nombre: '[NAME_2]' },\n...\n]\n```\n\nLuego, cuando los datos se comparten en otra llamada a la herramienta MCP, se destokenizan mediante una búsqueda en el cliente MCP.Las direcciones de correo electrónico, números de teléfono y nombres reales fluyen desde Google Sheets a Salesforce, pero nunca a través del modelo.Esto evita que el agente registre o procese datos confidenciales accidentalmente.También puede utilizar esto para definir reglas de seguridad deterministas, eligiendo hacia dónde y desde dónde pueden fluir los datos.\n\nEstado de persistencia y habilidades.\n\nLa ejecución de código con acceso al sistema de archivos permite a los agentes mantener el estado en todas las operaciones.Los agentes pueden escribir resultados intermedios en archivos, lo que les permite reanudar el trabajo y realizar un seguimiento del progreso:\n\n```\nclientes potenciales constantes = esperar salesforce.query({\nconsulta: 'SELECCIONAR ID, correo electrónico DESDE LÍMITE de cliente potencial 1000'\n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nespere fs.writeFile('./workspace/leads.csv', csvData);\n\n// La ejecución posterior continúa donde lo dejó\nconst guardado = await fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nLos agentes también pueden conservar su propio código como funciones reutilizables.Una vez que un agente desarrolla un código de trabajo para una tarea, puede guardar esa implementación para uso futuro:\n\n```\n// En ./skills/save-sheet-as-csv.ts\nimportar * como gdrive desde './servers/google-drive';\nexportar función asíncrona saveSheetAsCsv (sheetId: cadena) {\ndatos constantes = esperar gdrive.getSheet({sheetId});\nconst csv = data.map(fila => fila.join(',')).join('\\n');\nespere fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\nreturn `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Posteriormente, en cualquier ejecución de agente:\nimportar { saveSheetAsCsv } desde './skills/save-sheet-as-csv';\nconst csvPath = espera saveSheetAsCsv('abc123');\n```\n\nEsto está estrechamente relacionado con el concepto de Habilidades, carpetas de instrucciones, scripts y recursos reutilizables para que los modelos mejoren el desempeño en tareas especializadas.Agregar un archivo SKILL.md a estas funciones guardadas crea una habilidad estructurada a la que los modelos pueden hacer referencia y usar.Con el tiempo, esto le permite a su agente crear una caja de herramientas con capacidades de nivel superior, evolucionando el andamiaje que necesita para funcionar de manera más efectiva.\n\nTenga en cuenta que la ejecución del código introduce su propia complejidad.La ejecución de código generado por agentes requiere un entorno de ejecución seguro con espacio aislado, límites de recursos y supervisión adecuados.Estos requisitos de infraestructura añaden gastos operativos y consideraciones de seguridad que las llamadas directas a herramientas evitan.Los beneficios de la ejecución de código (costos de token reducidos, menor latencia y composición mejorada de herramientas) deben sopesarse con estos costos de implementación.\n\nResumen MCP proporciona un protocolo fundamental para que los agentes se conecten a muchas herramientas y sistemas.Sin embargo, una vez que se conectan demasiados servidores, las definiciones y resultados de las herramientas pueden consumir tokens excesivos, lo que reduce la eficiencia del agente.\n\nAunque muchos de los problemas aquí parecen novedosos (gestión del contexto, composición de herramientas, persistencia del estado), tienen soluciones conocidas de la ingeniería de software.La ejecución de código aplica estos patrones establecidos a los agentes, permitiéndoles utilizar construcciones de programación familiares para interactuar con los servidores MCP de manera más eficiente.Si implementa este enfoque, lo alentamos a compartir sus hallazgos con la comunidad de MCP.\n\nAgradecimientos\n\nEste artículo fue escrito por Adam Jones y Conor Kelly.Gracias a Jeremy Fox, Jerome Swannack, Stuart Ritchie, Molly Vorwerck, Matt Samuels y Maggie Vo por sus comentarios sobre los borradores de esta publicación.",
        "edited": false
      },
      "ukr": {
        "title": "Виконання коду за допомогою MCP: створення більш ефективних агентів",
        "content": "Model Context Protocol (MCP) — це відкритий стандарт для підключення агентів AI до зовнішніх систем.Підключення агентів до інструментів і даних традиційно вимагає спеціальної інтеграції для кожної пари, створюючи фрагментацію та дублюючі зусилля, що ускладнює масштабування справді підключених систем.MCP надає універсальний протокол — розробники впроваджують MCP один раз у своїх агентах, і це відкриває цілу екосистему інтеграцій.\n\nЗ моменту запуску MCP у листопаді 2024 року впровадження було швидким: спільнота створила тисячі серверів MCP, SDK доступні для всіх основних мов програмування, а галузь прийняла MCP як фактичний стандарт для підключення агентів до інструментів і даних.\n\nСьогодні розробники регулярно створюють агенти з доступом до сотень або тисяч інструментів на десятках серверів MCP.Однак, оскільки кількість підключених інструментів зростає, завантаження всіх визначень інструментів наперед і передача проміжних результатів через контекстне вікно сповільнюють роботу агентів і збільшують витрати.\n\nУ цьому блозі ми дослідимо, як виконання коду може дозволити агентам ефективніше взаємодіяти з серверами MCP, обробляючи більше інструментів і використовуючи менше маркерів.\n\nНадмірне споживання маркерів інструментами робить агентів менш ефективними\n\nУ зв’язку з масштабами використання MCP існують дві загальні моделі, які можуть збільшити вартість агента та затримку:\n\n- Визначення інструментів перевантажують контекстне вікно;\n\n- Проміжні результати інструменту споживають додаткові жетони.\n\n1. Визначення інструментів перевантажують контекстне вікно\n\nБільшість клієнтів MCP завантажують усі визначення інструментів безпосередньо в контекст, відкриваючи їх для моделі за допомогою синтаксису прямого виклику інструментів.Ці визначення інструментів можуть виглядати так:\n\n```\ngdrive.getDocument\nОпис: отримує документ із Google Drive\nПараметри:\ndocumentId (обов’язково, рядок): ідентифікатор документа, який потрібно отримати\nполя (необов’язкові, рядок): певні поля для повернення\nПовертає: об’єкт документа із заголовком, основним вмістом, метаданими, дозволами тощо.\n```\n\n```\nsalesforce.updateRecord\nОпис: оновлює запис у Salesforce\nПараметри:\nobjectType (обов’язково, рядок): Тип об’єкта Salesforce (Lead, Contact, Account тощо)\nrecordId (обов’язково, рядок): ідентифікатор запису для оновлення\nдані (обов’язково, об’єкт): поля для оновлення з новими значеннями\nПовертає: оновлений об’єкт запису з підтвердженням\n```\n\nОписи інструментів займають більше контекстного вікна, збільшуючи час відповіді та витрати.У випадках, коли агенти підключені до тисяч інструментів, їм потрібно буде обробити сотні тисяч токенів, перш ніж прочитати запит.\n\n2. Проміжні результати інструменту споживають додаткові токени\n\nБільшість клієнтів MCP дозволяють моделям безпосередньо викликати інструменти MCP.Наприклад, ви можете попросити свого агента: «Завантажте стенограму моєї зустрічі з Диска Google і прикріпіть її до потенційного клієнта Salesforce».\n\nМодель здійснюватиме такі дзвінки:\n\n```\nВИКЛИК ІНСТРУМЕНТУ: gdrive.getDocument(documentId: \"abc123\")\n→ повертає \"Обговорювані цілі Q4...\\n[повний текст стенограми]\"\n(завантажується в контекст моделі)\n\nВИКЛИК ІНСТРУМЕНТА: salesforce.updateRecord(\nobjectType: \"SalesMeeting\",\nrecordId: \"00Q5f000001abcXYZ\",\ndata: { \"Примітки\": \"Обговорювані цілі Q4...\\n[виписаний повний текст стенограми]\" }\n)\n(моделі потрібно знову записати всю транскрипцію в контекст)\n```\n\nКожен проміжний результат повинен пройти через модель.У цьому прикладі повна стенограма виклику проходить двічі.Для 2-годинної зустрічі з продажу це може означати обробку додаткових 50 000 токенів.Навіть більші документи можуть перевищувати межі вікон контексту, порушуючи робочий процес.\n\nЗ великими документами або складними структурами даних моделі можуть частіше робити помилки під час копіювання даних між викликами інструментів.\n\n[[IMAGE_1|Клієнт MCP завантажує визначення інструментів у контекстне вікно моделі та організовує цикл повідомлень, у якому кожен виклик інструмента та результат проходять через модель між операціями.]]\n\nВиконання коду за допомогою MCP покращує ефективність контексту\n\nОскільки середовища виконання коду стають все більш поширеними для агентів, рішенням є представлення серверів MCP як кодових API, а не прямих викликів інструментів.Потім агент може написати код для взаємодії з серверами MCP.Цей підхід вирішує обидві проблеми: агенти можуть завантажувати лише ті інструменти, які їм потрібні, і обробляти дані в середовищі виконання, перш ніж передати результати назад у модель. Для цього існує кілька способів.Одним із підходів є створення дерева файлів усіх доступних інструментів із підключених серверів MCP.Ось реалізація з використанням TypeScript:\n\n```\nсерверів\n├── гугл-диск\n│ ├── getDocument.ts\n│ ├── ... (інші інструменти)\n│ └── індекс.ц\n├── відділ продажів\n│ ├── updateRecord.ts\n│ ├── ... (інші інструменти)\n│ └── індекс.ц\n└── ... (інші сервери)\n```\n\nТоді кожен інструмент відповідає файлу, приблизно так:\n\n```\n// ./servers/google-drive/getDocument.ts\nімпорт { callMCPTool } із \"../../../client.js\";\n\nінтерфейс GetDocumentInput {\ndocumentId: рядок;\n}\n\nінтерфейс GetDocumentResponse {\nвміст: рядок;\n}\n\n/* Читання документа з Google Drive */\nекспорт асинхронної функції getDocument(вхід: GetDocumentInput): Promise<GetDocumentResponse> {\nreturn callMCPTool<GetDocumentResponse>('google_drive__get_document', введення);\n}\n```\n\nНаш приклад Google Drive to Salesforce, наведений вище, стає кодом:\n\n```\n// Читання стенограми з Документів Google і додавання до перспективи Salesforce\nімпорт * як gdrive з './servers/google-drive';\nімпорт * як salesforce з './servers/salesforce';\n\nconst transcript = (очікуйте gdrive.getDocument({ documentId: 'abc123' })).content;\nawait salesforce.updateRecord({\nobjectType: 'SalesMeeting',\nrecordId: '00Q5f000001abcXYZ',\nдані: {Примітки: розшифровка}\n});\n```\n\nАгент знаходить інструменти, досліджуючи файлову систему: перераховуючи каталог ./servers/, щоб знайти доступні сервери (наприклад, google-drive і salesforce), а потім читаючи файли конкретних інструментів, які йому потрібні (наприклад, getDocument.ts і updateRecord.ts), щоб зрозуміти інтерфейс кожного інструменту.Це дозволяє агенту завантажувати лише визначення, необхідні для поточного завдання.Це зменшує використання токенів зі 150 000 до 2 000 токенів — економія часу та витрат становить 98,7%.\n\nCloudflare опублікував подібні висновки, називаючи виконання коду за допомогою MCP «режимом коду».Основне розуміння те ж саме: магістратури вміють писати код, і розробники повинні скористатися цією перевагою для створення агентів, які ефективніше взаємодіють із серверами MCP.\n\nПереваги виконання коду за допомогою MCP\n\nВиконання коду за допомогою MCP дозволяє агентам ефективніше використовувати контекст шляхом завантаження інструментів на вимогу, фільтрації даних до того, як вони потраплять до моделі, і виконання складної логіки за один крок.Використання цього підходу також має переваги для безпеки та управління станом.\n\nПрогресивне розкриття\n\nМоделі чудово підходять для навігації файловими системами.Представлення інструментів у вигляді коду у файловій системі дозволяє моделям читати визначення інструментів на вимогу, а не читати їх усі заздалегідь.\n\nКрім того, на сервер можна додати інструмент search_tools для пошуку відповідних визначень.Наприклад, під час роботи з гіпотетичним сервером Salesforce, використаним вище, агент шукає \"salesforce\" і завантажує лише ті інструменти, які йому потрібні для поточного завдання.Включення параметра рівня деталізації в інструмент search_tools, який дозволяє агенту вибирати необхідний рівень деталізації (наприклад, лише ім’я, ім’я та опис або повне визначення зі схемами), також допомагає агенту зберегти контекст і ефективно знаходити інструменти.\n\nКонтекстно ефективний інструмент результати\n\nПрацюючи з великими наборами даних, агенти можуть фільтрувати та перетворювати результати в код, перш ніж повертати їх.Спробуйте отримати електронну таблицю на 10 000 рядків:\n\n```\n// Без виконання коду - усі рядки проходять через контекст\nВИКЛИК ІНСТРУМЕНТУ: gdrive.getSheet(sheetId: 'abc123')\n→ повертає 10 000 рядків у контексті для ручного фільтрування\n\n// З виконанням коду - фільтр у середовищі виконання\nconst allRows = await gdrive.getSheet({ sheetId: 'abc123' });\nconst pendingOrders = allRows.filter(row =>\nrow[\"Status\"] === 'очікує на розгляд'\n);\nconsole.log(`Знайдено ${pendingOrders.length} відкладених ордерів`);\nconsole.log(pendingOrders.slice(0, 5));// Зареєструйте лише перші 5 для перегляду\n```\n\nАгент бачить п'ять рядків замість 10 000.Подібні шаблони працюють для агрегацій, об’єднань у кількох джерелах даних або вилучення певних полів – і все це без роздування вікна контексту.\n\nБільш потужний і контекстно-ефективний потік керування\n\nЦикли, умови й обробку помилок можна виконати за допомогою знайомих шаблонів коду, а не згрупувати окремі виклики інструментів.Наприклад, якщо вам потрібно сповіщення про розгортання в Slack, агент може написати: ```\nlet found = false;\nwhile (!знайдено) {\nconst messages = await slack.getChannelHistory({ канал: 'C123456' });\nзнайдено = messages.some(m => m.text.includes('розгортання завершено'));\nif (!found) await new Promise(r => setTimeout(r, 5000));\n}\nconsole.log('Отримано сповіщення про розгортання');\n```\n\nЦей підхід більш ефективний, ніж чергування між викликами інструментів MCP і командами сну через цикл агента.\n\nКрім того, можливість написати умовне дерево, яке виконується, також економить затримку «часу до першого маркера»: замість того, щоб чекати, поки модель оцінить інструкцію if, агент може дозволити середовищу виконання коду зробити це.\n\nОперації збереження конфіденційності\n\nКоли агенти використовують виконання коду з MCP, проміжні результати за замовчуванням залишаються в середовищі виконання.Таким чином, агент бачить лише те, що ви явно реєструєте або повертаєте, тобто дані, якими ви не бажаєте ділитися з моделлю, можуть проходити через ваш робочий процес без входження в контекст моделі.\n\nДля ще більш конфіденційних робочих навантажень джгут агентів може автоматично токенізувати конфіденційні дані.Наприклад, уявіть, що вам потрібно імпортувати контактні дані клієнта з електронної таблиці в Salesforce.Агент пише:\n\n```\nconst sheet = await gdrive.getSheet({ sheetId: 'abc123' });\nfor (const row of sheet.rows) {\nawait salesforce.updateRecord({\nobjectType: 'Lead',\nrecordId: row.salesforceId,\nдані: {\nЕлектронна пошта: row.email,\nТелефон: row.phone,\nНазва: row.name\n}\n});\n}\nconsole.log(`Оновлені потенційні клієнти ${sheet.rows.length}`);\n```\n\nКлієнт MCP перехоплює дані та токенізує ідентифікаційну інформацію, перш ніж вона досягне моделі:\n\n```\n// Що побачить агент, якщо він зареєструє sheet.rows:\n[\n{ salesforceId: '00Q...', електронна адреса: '[EMAIL_1]', телефон: '[PHONE_1]', ім'я: '[NAME_1]' },\n{ salesforceId: '00Q...', електронна адреса: '[EMAIL_2]', телефон: '[PHONE_2]', ім'я: '[NAME_2]' },\n...\n]\n```\n\nПотім, коли дані передаються під час іншого виклику інструменту MCP, вони скасовуються через пошук у клієнті MCP.Справжні електронні адреси, номери телефонів та імена надходять із Google Таблиць до Salesforce, але не через модель.Це запобігає випадковому реєстрації чи обробці конфіденційних даних агентом.Ви також можете використовувати це для визначення детермінованих правил безпеки, вибираючи, куди і звідки можуть надходити дані.\n\nДержавна наполегливість і вміння\n\nВиконання коду з доступом до файлової системи дозволяє агентам підтримувати стан між операціями.Агенти можуть записувати проміжні результати у файли, що дозволяє їм відновити роботу та відстежувати прогрес:\n\n```\nconst leads = await salesforce.query({\nзапит: \"SELECT Id, Email FROM Lead LIMIT 1000\"\n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nawait fs.writeFile('./workspace/leads.csv', csvData);\n\n// Пізніше виконання продовжується з того місця, де воно зупинилося\nconst saved = await fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nАгенти також можуть зберігати свій власний код як функції для повторного використання.Коли агент розробляє робочий код для завдання, він може зберегти цю реалізацію для майбутнього використання:\n\n```\n// У ./skills/save-sheet-as-csv.ts\nімпорт * як gdrive з './servers/google-drive';\nекспорт асинхронної функції saveSheetAsCsv(sheetId: рядок) {\nconst data = await gdrive.getSheet({sheetId});\nconst csv = data.map(row => row.join(',')).join('\\n');\nawait fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\nreturn `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Пізніше, у будь-якому виконанні агента:\nімпорт { saveSheetAsCsv } із './skills/save-sheet-as-csv';\nconst csvPath = очікувати saveSheetAsCsv('abc123');\n```\n\nЦе тісно пов’язане з концепцією навичок, папок багаторазових інструкцій, сценаріїв і ресурсів для моделей для підвищення ефективності виконання спеціалізованих завдань.Додавання файлу SKILL.md до цих збережених функцій створює структурований навик, на який моделі можуть посилатися та використовувати.Згодом це дозволить вашому агенту створити набір інструментів із можливостями вищого рівня, розвиваючи каркас, необхідний для найбільш ефективної роботи.\n\nЗауважте, що виконання коду вносить власну складність.Для запуску створеного агентом коду потрібне безпечне середовище виконання з відповідним ізольованим програмним середовищем, обмеженнями ресурсів і моніторингом.Ці вимоги до інфраструктури додають додаткові робочі витрати та міркування щодо безпеки, яких уникають прямі виклики інструментів.Переваги виконання коду — зменшення витрат на токени, меншу затримку та покращену композицію інструментів — слід порівняти з цими витратами на впровадження.\n\nРезюме MCP надає базовий протокол для підключення агентів до багатьох інструментів і систем.Однак, як тільки підключено занадто багато серверів, визначення інструментів і результати можуть споживати надмірну кількість маркерів, що знижує ефективність агента.\n\nХоча багато проблем тут здаються новими — керування контекстом, композиція інструментів, збереження стану — вони мають відомі рішення з інженерії програмного забезпечення.Виконання коду застосовує ці встановлені шаблони до агентів, дозволяючи їм використовувати знайомі конструкції програмування для більш ефективної взаємодії з серверами MCP.Якщо ви застосовуєте цей підхід, ми радимо вам поділитися своїми висновками зі спільнотою MCP.\n\nПодяки\n\nЦю статтю написали Адам Джонс і Конор Келлі.Дякуємо Джеремі Фоксу, Джерому Суоннеку, Стюарту Річі, Моллі Форверк, Метту Семюелсу та Меггі Во за відгуки про чернетки цієї публікації.",
        "edited": false
      },
      "pt": {
        "title": "Execução de código com MCP: Construindo agentes mais eficientes",
        "content": "O Model Context Protocol (MCP) é um padrão aberto para conectar agentes de IA a sistemas externos.Conectar agentes a ferramentas e dados tradicionalmente requer uma integração personalizada para cada emparelhamento, criando fragmentação e esforço duplicado que dificulta o dimensionamento de sistemas verdadeiramente conectados.O MCP fornece um protocolo universal: os desenvolvedores implementam o MCP uma vez em seu agente e isso desbloqueia todo um ecossistema de integrações.\n\nDesde o lançamento do MCP em novembro de 2024, a adoção tem sido rápida: a comunidade construiu milhares de servidores MCP, os SDKs estão disponíveis para todas as principais linguagens de programação e a indústria adotou o MCP como o padrão de fato para conectar agentes a ferramentas e dados.\n\nHoje, os desenvolvedores criam rotineiramente agentes com acesso a centenas ou milhares de ferramentas em dezenas de servidores MCP.No entanto, à medida que o número de ferramentas conectadas cresce, carregar todas as definições de ferramentas antecipadamente e passar resultados intermediários pela janela de contexto desacelera os agentes e aumenta os custos.\n\nNeste blog exploraremos como a execução de código pode permitir que os agentes interajam com servidores MCP de forma mais eficiente, lidando com mais ferramentas e usando menos tokens.\n\nO consumo excessivo de tokens das ferramentas torna os agentes menos eficientes\n\nÀ medida que o uso do MCP aumenta, há dois padrões comuns que podem aumentar o custo e a latência do agente:\n\n- As definições de ferramentas sobrecarregam a janela de contexto;\n\n- Os resultados da ferramenta intermediária consomem tokens adicionais.\n\n1. As definições de ferramentas sobrecarregam a janela de contexto\n\nA maioria dos clientes MCP carrega antecipadamente todas as definições de ferramentas diretamente no contexto, expondo-as ao modelo usando uma sintaxe de chamada direta de ferramentas.Essas definições de ferramentas podem ser semelhantes a:\n\n```\ngdrive.getDocument\nDescrição: Recupera um documento do Google Drive\nParâmetros:\ndocumentId (obrigatório, string): o ID do documento a ser recuperado\ncampos (opcional, string): campos específicos para retornar\nRetorna: Objeto de documento com título, conteúdo do corpo, metadados, permissões, etc.\n```\n\n```\nsalesforce.updateRecord\nDescrição: Atualiza um registro no Salesforce\nParâmetros:\nobjectType (obrigatório, string): Tipo de objeto do Salesforce (Lead, Contato, Conta, etc.)\nrecordId (obrigatório, string): o ID do registro a ser atualizado\ndados (obrigatório, objeto): Campos a serem atualizados com seus novos valores\nRetorna: Objeto de registro atualizado com confirmação\n```\n\nAs descrições das ferramentas ocupam mais espaço na janela de contexto, aumentando o tempo de resposta e os custos.Nos casos em que os agentes estão conectados a milhares de ferramentas, eles precisarão processar centenas de milhares de tokens antes de ler uma solicitação.\n\n2. Os resultados intermediários da ferramenta consomem tokens adicionais\n\nA maioria dos clientes MCP permite que os modelos chamem diretamente as ferramentas MCP.Por exemplo, você pode perguntar ao seu agente: “Baixe a transcrição da minha reunião do Google Drive e anexe-a ao lead do Salesforce”.\n\nO modelo fará chamadas como:\n\n```\nCHAMADA DE FERRAMENTA: gdrive.getDocument(documentId: \"abc123\")\n→ retorna \"Metas discutidas no quarto trimestre...\\n[texto da transcrição completa]\"\n(carregado no contexto do modelo)\n\nCHAMADA DE FERRAMENTA: salesforce.updateRecord(\nobjectType: \"SalesMeeting\",\nrecordId: \"00Q5f000001abcXYZ\",\ndata: { \"Notas\": \"Metas discutidas no quarto trimestre...\\n[texto completo da transcrição escrito]\" }\n)\n(o modelo precisa escrever toda a transcrição no contexto novamente)\n```\n\nTodo resultado intermediário deve passar pelo modelo.Neste exemplo, a transcrição completa da chamada flui duas vezes.Para uma reunião de vendas de 2 horas, isso pode significar o processamento de 50.000 tokens adicionais.Documentos ainda maiores podem exceder os limites da janela de contexto, interrompendo o fluxo de trabalho.\n\nCom documentos grandes ou estruturas de dados complexas, os modelos podem ter maior probabilidade de cometer erros ao copiar dados entre chamadas de ferramentas.\n\n[[IMAGE_1|O cliente MCP carrega definições de ferramenta na janela de contexto do modelo e orquestra um loop de mensagens onde cada chamada de ferramenta e resultado passa pelo modelo entre as operações.]]\n\nA execução de código com MCP melhora a eficiência do contexto\n\nCom os ambientes de execução de código se tornando mais comuns para os agentes, uma solução é apresentar os servidores MCP como APIs de código, em vez de chamadas diretas de ferramentas.O agente pode então escrever código para interagir com os servidores MCP.Essa abordagem aborda ambos os desafios: os agentes podem carregar apenas as ferramentas necessárias e processar os dados no ambiente de execução antes de transmitir os resultados de volta ao modelo. Existem várias maneiras de fazer isso.Uma abordagem é gerar uma árvore de arquivos de todas as ferramentas disponíveis nos servidores MCP conectados.Aqui está uma implementação usando TypeScript:\n\n```\nservidores\n├── google-drive\n│ ├── getDocument.ts\n│ ├── ... (outras ferramentas)\n│ └── index.ts\n├── força de vendas\n│ ├── updateRecord.ts\n│ ├── ... (outras ferramentas)\n│ └── index.ts\n└── ... (outros servidores)\n```\n\nEntão cada ferramenta corresponde a um arquivo, algo como:\n\n```\n// ./servers/google-drive/getDocument.ts\nimportar { callMCPTool } de \"../../../client.js\";\n\ninterfaceGetDocumentInput {\ndocumentID: string;\n}\n\ninterfaceGetDocumentResponse{\nconteúdo: sequência;\n}\n\n/* Ler um documento do Google Drive */\nexportar função assíncrona getDocument(input: GetDocumentInput): Promise<GetDocumentResponse> {\nreturn callMCPTool<GetDocumentResponse>('google_drive__get_document', input);\n}\n```\n\nNosso exemplo do Google Drive para Salesforce acima se torna o código:\n\n```\n// Leia a transcrição do Google Docs e adicione ao cliente potencial do Salesforce\nimportar * como gdrive de './servers/google-drive';\nimportar * como força de vendas de './servers/salesforce';\n\ntranscrição const = (aguarde gdrive.getDocument({documentId: 'abc123' })).content;\naguardar salesforce.updateRecord({\nobjectType: 'SalesMeeting',\nID de registro: '00Q5f000001abcXYZ',\ndados: {Notas: transcrição}\n});\n```\n\nO agente descobre ferramentas explorando o sistema de arquivos: listando o diretório ./servers/ para encontrar servidores disponíveis (como google-drive e salesforce ) e, em seguida, lendo os arquivos de ferramentas específicos necessários (como getDocument.ts e updateRecord.ts ) para entender a interface de cada ferramenta.Isso permite que o agente carregue apenas as definições necessárias para a tarefa atual.Isso reduz o uso de tokens de 150.000 tokens para 2.000 tokens – uma economia de tempo e custos de 98,7%.\n\nA Cloudflare publicou descobertas semelhantes, referindo-se à execução de código com MCP como “Modo de Código”.O insight principal é o mesmo: os LLMs são adeptos da escrita de código e os desenvolvedores devem aproveitar essa vantagem para criar agentes que interajam com os servidores MCP de maneira mais eficiente.\n\nBenefícios da execução de código com MCP\n\nA execução de código com MCP permite que os agentes usem o contexto de forma mais eficiente, carregando ferramentas sob demanda, filtrando dados antes que cheguem ao modelo e executando lógica complexa em uma única etapa.Há também benefícios de segurança e gerenciamento de estado ao usar essa abordagem.\n\nDivulgação progressiva\n\nOs modelos são ótimos para navegar em sistemas de arquivos.Apresentar ferramentas como código em um sistema de arquivos permite que os modelos leiam as definições de ferramentas sob demanda, em vez de lê-las todas antecipadamente.\n\nAlternativamente, uma ferramenta search_tools pode ser adicionada ao servidor para encontrar definições relevantes.Por exemplo, ao trabalhar com o servidor Salesforce hipotético usado acima, o agente procura por \"força de vendas\" e carrega apenas as ferramentas necessárias para a tarefa atual.Incluir um parâmetro de nível de detalhe na ferramenta search_tools que permite ao agente selecionar o nível de detalhe necessário (como apenas nome, nome e descrição ou a definição completa com esquemas) também ajuda o agente a conservar o contexto e encontrar ferramentas com eficiência.\n\nResultados de ferramentas com eficiência de contexto\n\nAo trabalhar com grandes conjuntos de dados, os agentes podem filtrar e transformar os resultados em código antes de retorná-los.Considere buscar uma planilha de 10.000 linhas:\n\n```\n// Sem execução de código - todas as linhas fluem através do contexto\nCHAMADA DE FERRAMENTA: gdrive.getSheet(sheetId: 'abc123')\n→ retorna 10.000 linhas no contexto para filtrar manualmente\n\n// Com execução de código - filtro no ambiente de execução\nconst allRows = aguarda gdrive.getSheet({sheetId: 'abc123' });\nconst pendenteOrders = allRows.filter(linha =>\nlinha[\"Status\"] === 'pendente'\n);\nconsole.log(`Encontrados ${pendingOrders.length} pedidos pendentes`);\nconsole.log(pendingOrders.slice(0, 5));// Registra apenas os 5 primeiros para revisão\n```\n\nO agente vê cinco linhas em vez de 10.000.Padrões semelhantes funcionam para agregações, junções em diversas fontes de dados ou extração de campos específicos - tudo isso sem sobrecarregar a janela de contexto.\n\nFluxo de controle mais poderoso e eficiente em termos de contexto\n\nLoops, condicionais e tratamento de erros podem ser feitos com padrões de código familiares, em vez de encadear chamadas de ferramentas individuais.Por exemplo, se você precisar de uma notificação de implantação no Slack, o agente poderá escrever: ```\ndeixe encontrado = falso;\nenquanto (!encontrado) {\nmensagens const = aguarda slack.getChannelHistory({canal: 'C123456' });\nencontrado = mensagens.some(m => m.text.includes('implantação concluída'));\nif (!found) aguarda new Promise(r => setTimeout(r, 5000));\n}\nconsole.log('Notificação de implantação recebida');\n```\n\nEssa abordagem é mais eficiente do que alternar entre chamadas de ferramenta MCP e comandos de suspensão por meio do loop do agente.\n\nAlém disso, ser capaz de escrever uma árvore condicional que é executada também economiza na latência do \"tempo até o primeiro token\": em vez de ter que esperar que um modelo avalie uma instrução if, o agente pode deixar o ambiente de execução de código fazer isso.\n\nOperações de preservação de privacidade\n\nQuando os agentes usam a execução de código com o MCP, os resultados intermediários permanecem no ambiente de execução por padrão.Dessa forma, o agente só vê o que você registra ou retorna explicitamente, o que significa que os dados que você não deseja compartilhar com o modelo podem fluir pelo seu fluxo de trabalho sem nunca entrar no contexto do modelo.\n\nPara cargas de trabalho ainda mais confidenciais, o equipamento do agente pode tokenizar dados confidenciais automaticamente.Por exemplo, imagine que você precise importar detalhes de contato do cliente de uma planilha para o Salesforce.O agente escreve:\n\n```\nplanilha const = aguarda gdrive.getSheet({sheetId: 'abc123' });\nfor (const linha de planilha.rows) {\naguardar salesforce.updateRecord({\nobjectType: 'Lead',\nrecordId: linha.salesforceId,\ndados: {\nE-mail: linha.email,\nTelefone: row.phone,\nNome: linha.nome\n}\n});\n}\nconsole.log(`Leads ${sheet.rows.length} atualizados`);\n```\n\nO cliente MCP intercepta os dados e tokeniza PII antes que cheguem ao modelo:\n\n```\n// O que o agente veria se registrasse o sheet.rows:\n[\n{ salesforceId: '00Q...', email: '[EMAIL_1]', telefone: '[PHONE_1]', nome: '[NAME_1]' },\n{ salesforceId: '00Q...', email: '[EMAIL_2]', telefone: '[PHONE_2]', nome: '[NAME_2]' },\n...\n]\n```\n\nEntão, quando os dados são compartilhados em outra chamada de ferramenta MCP, eles não são tokenizados por meio de uma consulta no cliente MCP.Os endereços de e-mail, números de telefone e nomes reais fluem do Planilhas Google para o Salesforce, mas nunca através do modelo.Isso evita que o agente registre ou processe acidentalmente dados confidenciais.Você também pode usar isso para definir regras de segurança determinísticas, escolhendo para onde os dados podem fluir.\n\nPersistência e habilidades do estado\n\nA execução de código com acesso ao sistema de arquivos permite que os agentes mantenham o estado entre as operações.Os agentes podem gravar resultados intermediários em arquivos, permitindo-lhes retomar o trabalho e acompanhar o progresso:\n\n```\nconst leads = aguarda salesforce.query({\nconsulta: 'SELECT Id, Email FROM Lead LIMIT 1000'\n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\naguarde fs.writeFile('./workspace/leads.csv', csvData);\n\n// A execução posterior continua de onde parou\nconst salvo = aguarda fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nOs agentes também podem manter seu próprio código como funções reutilizáveis.Depois que um agente desenvolve um código funcional para uma tarefa, ele pode salvar essa implementação para uso futuro:\n\n```\n// Em ./skills/save-sheet-as-csv.ts\nimportar * como gdrive de './servers/google-drive';\nexportar função assíncrona saveSheetAsCsv(sheetId: string) {\ndados const = aguarda gdrive.getSheet({sheetId });\nconst csv = data.map(row => row.join(',')).join('\\n');\naguarde fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\nreturn `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Posteriormente, em qualquer execução do agente:\nimportar { saveSheetAsCsv } de './skills/save-sheet-as-csv';\nconst csvPath = aguarda saveSheetAsCsv('abc123');\n```\n\nIsso está intimamente ligado ao conceito de Skills, pastas de instruções reutilizáveis, scripts e recursos para modelos para melhorar o desempenho em tarefas especializadas.Adicionar um arquivo SKILL.md a essas funções salvas cria uma habilidade estruturada que os modelos podem referenciar e usar.Com o tempo, isso permite que seu agente construa uma caixa de ferramentas de recursos de nível superior, evoluindo a estrutura necessária para trabalhar com mais eficiência.\n\nObserve que a execução do código apresenta sua própria complexidade.A execução de código gerado pelo agente requer um ambiente de execução seguro com sandboxing, limites de recursos e monitoramento apropriados.Esses requisitos de infraestrutura acrescentam sobrecarga operacional e considerações de segurança que as chamadas diretas à ferramenta evitam.Os benefícios dos custos de token reduzidos na execução do código, menor latência e melhor composição da ferramenta devem ser avaliados em relação a esses custos de implementação.\n\nResumo O MCP fornece um protocolo básico para que os agentes se conectem a muitas ferramentas e sistemas.No entanto, quando muitos servidores estão conectados, as definições e os resultados da ferramenta podem consumir tokens excessivos, reduzindo a eficiência do agente.\n\nEmbora muitos dos problemas aqui pareçam gerenciamento de contexto novo, composição de ferramentas e persistência de estado - eles têm soluções conhecidas da engenharia de software.A execução de código aplica esses padrões estabelecidos aos agentes, permitindo-lhes usar construções de programação familiares para interagir com servidores MCP de forma mais eficiente.Se você implementar essa abordagem, encorajamos você a compartilhar suas descobertas com a comunidade MCP.\n\nAgradecimentos\n\nEste artigo foi escrito por Adam Jones e Conor Kelly.Obrigado a Jeremy Fox, Jerome Swannack, Stuart Ritchie, Molly Vorwerck, Matt Samuels e Maggie Vo pelos comentários sobre os rascunhos deste post.",
        "edited": false
      },
      "zh": {
        "title": "使用 MCP 执行代码：构建更高效的代理",
        "content": "模型上下文协议 (MCP) 是用于将 AI 代理连接到外部系统的开放标准。传统上，将代理连接到工具和数据需要为每个配对进行自定义集成，从而产生碎片和重复工作，从而难以扩展真正连接的系统。MCP 提供了一个通用协议，开发人员在其代理中实施 MCP 一次，即可解锁整个集成生态系统。\n\n自 2024 年 11 月推出 MCP 以来，采用速度很快：社区已经构建了数千台 MCP 服务器，SDK 可用于所有主要编程语言，并且业界已采用 MCP 作为将代理连接到工具和数据的事实上的标准。\n\n如今，开发人员通常会构建能够访问数十台 MCP 服务器上的数百或数千种工具的代理。然而，随着连接工具数量的增长，预先加载所有工具定义并通过上下文窗口传递中间结果会减慢代理速度并增加成本。\n\n在本博客中，我们将探讨代码执行如何使代理能够更有效地与 MCP 服务器交互，在使用更少令牌的同时处理更多工具。\n\n工具过度消耗代币会导致代理效率降低\n\n随着 MCP 使用规模的扩大，有两种常见模式可能会增加代理成本和延迟：\n\n- 工具定义使上下文窗口过载；\n\n- 中间工具结果消耗额外的代币。\n\n1. 工具定义使上下文窗口超载\n\n大多数 MCP 客户端将所有工具定义直接加载到上下文中，使用直接工具调用语法将它们暴露给模型。这些工具定义可能如下所示：\n\n````\ngdrive.getDocument\n描述：从 Google Drive 检索文档\n参数：\ndocumentId (required, string): 要检索的文档的 ID\nfields（可选，字符串）：要返回的特定字段\n返回：包含标题、正文内容、元数据、权限等的文档对象。\n````\n\n````\nsalesforce.updateRecord\n描述：更新 Salesforce 中的记录\n参数：\nobjectType（必填，字符串）：Salesforce 对象的类型（潜在客户、联系人、客户等）\nrecordId（必需，字符串）：要更新的记录的ID\n数据（必需，对象）：使用新值更新的字段\n返回：更新记录对象并确认\n````\n\n工具描述占用更多上下文窗口空间，增加响应时间和成本。如果代理连接到数千个工具，他们需要在读取请求之前处理数十万个令牌。\n\n2. 中间工具结果消耗额外代币\n\n大多数MCP客户端允许模型直接调用MCP工具。例如，您可能会询问您的代理：“从 Google 云端硬盘下载我的会议记录并将其附加给 Salesforce 领导。”\n\n该模型将进行如下调用：\n\n````\n工具调用：gdrive.getDocument（documentId：“abc123”）\n→ 返回“讨论的第四季度目标...\\n[完整记录文本]”\n（加载到模型上下文中）\n\n工具调用： salesforce.updateRecord(\n对象类型：“销售会议”，\n记录ID：“00Q5f000001abcXYZ”，\ndata: { \"Notes\": \"讨论第四季度目标...\\n[写出完整的文字记录文本]\" }\n）\n（模型需要再次将整个转录本写入上下文）\n````\n\n每个中间结果都必须经过模型。在此示例中，完整的通话记录经过两次。对于 2 小时的销售会议，这可能意味着额外处理 50,000 个代币。即使更大的文档也可能超出上下文窗口限制，从而破坏工作流程。\n\n对于大型文档或复杂的数据结构，模型在工具调用之间复制数据时可能更容易出错。\n\n[[IMAGE_1|MCP 客户端将工具定义加载到模型的上下文窗口中，并编排一个消息循环，其中每个工具调用和结果在操作之间通过模型。]]\n\n使用 MCP 执行代码可提高上下文效率\n\n随着代码执行环境对于代理来说变得越来越普遍，解决方案是将 MCP 服务器呈现为代码 API，而不是直接工具调用。然后，代理可以编写代码来与 MCP 服务器交互。这种方法解决了这两个挑战：代理只能加载他们需要的工具，并在将结果传递回模型之前在执行环境中处理数据。 有多种方法可以做到这一点。一种方法是从连接的 MCP 服务器生成所有可用工具的文件树。这是使用 TypeScript 的实现：\n\n````\n服务器\n├── 谷歌驱动器\n│ ├── getDocument.ts\n│ ├── ...（其他工具）\n│ └── 索引.ts\n├── 销售人员\n│ ├── updateRecord.ts\n│ ├── ...（其他工具）\n│ └── 索引.ts\n└── ...（其他服务器）\n````\n\n那么每个工具对应一个文件，类似于：\n\n````\n// ./servers/google-drive/getDocument.ts\n从“../../../client.js”导入{callMCPTool}；\n\n接口获取文档输入{\n文档ID：字符串；\n}\n\n接口获取文档响应{\n内容：字符串；\n}\n\n/* 从 Google Drive 读取文档 */\n导出异步函数 getDocument(输入: GetDocumentInput): Promise<GetDocumentResponse> {\n返回 callMCPTool<GetDocumentResponse>('google_drive__get_document', input);\n}\n````\n\n我们上面的 Google Drive 到 Salesforce 示例变成了代码：\n\n````\n// 从 Google Docs 读取文字记录并添加到 Salesforce 潜在客户\n从“./servers/google-drive”导入*作为gdrive；\n从 './servers/salesforce' 导入 * 作为 salesforce；\n\nconst 成绩单 = (await gdrive.getDocument({ documentId: 'abc123' })).content;\n等待 salesforce.updateRecord({\nobjectType: '销售会议',\n记录 ID: '00Q5f000001abcXYZ',\n数据：{注释：文字记录}\n});\n````\n\n代理通过探索文件系统来发现工具：列出 ./servers/ 目录以查找可用服务器（例如 google-drive 和 salesforce ），然后读取它需要的特定工具文件（例如 getDocument.ts 和 updateRecord.ts ）以了解每个工具的界面。这使得代理仅加载当前任务所需的定义。这将代币使用量从 150,000 个代币减少到 2,000 个代币，节省了 98.7% 的时间和成本。\n\nCloudflare 发布了类似的发现，将 MCP 的代码执行称为“代码模式”。核心见解是相同的：LLM 擅长编写代码，开发人员应该利用这一优势来构建能够更有效地与 MCP 服务器交互的代理。\n\n使用 MCP 执行代码的好处\n\n使用 MCP 执行代码使代理能够通过按需加载工具、在数据到达模型之前过滤数据以及在一个步骤中执行复杂的逻辑来更有效地使用上下文。使用这种方法还具有安全性和状态管理优势。\n\n渐进式披露\n\n模型非常擅长导航文件系统。将工具呈现为文件系统上的代码允许模型按需读取工具定义，而不是预先读取它们。\n\n或者，可以将 search_tools 工具添加到服务器来查找相关定义。例如，当使用上面使用的假设 Salesforce 服务器时，代理会搜索“salesforce”并仅加载当前任务所需的工具。在 search_tools 工具中包含一个详细级别参数，允许代理选择所需的详细级别（例如仅名称、名称和描述，或带有模式的完整定义），也有助于代理保存上下文并有效地查找工具。\n\n上下文有效的工具结果\n\n在处理大型数据集时，代理可以在返回结果之前过滤和转换代码中的结果。考虑获取一个 10,000 行的电子表格：\n\n````\n// 没有代码执行 - 所有行都流过上下文\n工具调用：gdrive.getSheet(sheetId: 'abc123')\n→ 在上下文中返回 10,000 行以手动过滤\n\n// 随着代码执行-执行环境中的过滤器\nconst allRows =等待 gdrive.getSheet({sheetId: 'abc123' });\nconstendingOrders = allRows.filter(行 =>\n行[“状态”] === '待处理'\n）；\nconsole.log(`发现 ${pendingOrders.length} 挂单`);\nconsole.log(pendingOrders.slice(0, 5));// 只记录前 5 个以供审核\n````\n\n代理看到的是 5 行而不是 10,000 行。类似的模式适用于聚合、跨多个数据源的联接或提取特定字段，所有这些都不会使上下文窗口膨胀。\n\n更强大且上下文高效的控制流\n\n循环、条件和错误处理可以使用熟悉的代码模式来完成，而不是链接单个工具调用。例如，如果您需要 Slack 中的部署通知，代理可以编写： ````\n让找到=假；\n而（！发现）{\nconst messages = wait slack.getChannelHistory({ 频道: 'C123456' });\nfind = messages.some(m => m.text.includes('部署完成'));\nif (!found) 等待新的 Promise(r => setTimeout(r, 5000));\n}\nconsole.log('收到部署通知');\n````\n\n这种方法比通过代理循环在 MCP 工具调用和睡眠命令之间交替进行更有效。\n\n此外，能够写出执行的条件树还可以节省“第一个令牌的时间”延迟：代理可以让代码执行环境执行此操作，而不必等待模型评估 if 语句。\n\n隐私保护操作\n\n当代理使用 MCP 执行代码时，中间结果默认保留在执行环境中。这样，代理只能看到您显式记录或返回的内容，这意味着您不希望与模型共享的数据可以流经您的工作流程，而无需进入模型的上下文。\n\n对于更敏感的工作负载，代理工具可以自动标记敏感数据。例如，假设您需要将客户联系详细信息从电子表格导入 Salesforce。代理人写道：\n\n````\nconstsheet=awaitgdrive.getSheet({sheetId:'abc123'});\nfor (sheet.rows 的常量行) {\n等待 salesforce.updateRecord({\nobjectType: '铅',\n记录Id：row.salesforceId，\n数据：{\n电子邮件：行.电子邮件，\n电话: row.phone,\n名称：行.名称\n}\n});\n}\nconsole.log(`更新了 ${sheet.rows.length} 线索`);\n````\n\nMCP 客户端在数据到达模型之前拦截数据并标记 PII：\n\n````\n// 如果代理记录了sheet.rows，它会看到什么：\n[\n{ salesforceId:“00Q...”，电子邮件：“[EMAIL_1]”，电话：“[PHONE_1]”，姓名：“[NAME_1]”},\n{ salesforceId: '00Q...', 电子邮件: '[EMAIL_2]', 电话: '[PHONE_2]', 姓名: '[NAME_2]' },\n...\n]\n````\n\n然后，当数据在另一个 MCP 工具调用中共享时，它会通过 MCP 客户端中的查找来取消标记。真实的电子邮件地址、电话号码和姓名从 Google Sheets 流向 Salesforce，但从未通过模型。这可以防止代理意外记录或处理敏感数据。您还可以使用它来定义确定性安全规则，选择数据可以流入和流出的位置。\n\n状态坚持和技能\n\n通过文件系统访问执行代码允许代理跨操作维护状态。代理可以将中间结果写入文件，使他们能够恢复工作并跟踪进度：\n\n````\nconst 线索 = 等待 salesforce.query({\n查询：“选择 ID，电子邮件来自潜在客户 LIMIT 1000”\n});\nconst csvData = Leads.map(l => `${l.Id},${l.Email}`).join('\\n');\n等待 fs.writeFile('./workspace/leads.csv', csvData);\n\n// 稍后从中断处继续执行\nconst 保存=等待 fs.readFile('./workspace/leads.csv', 'utf-8');\n````\n\n代理还可以将自己的代码保留为可重用函数。一旦代理为任务开发了工作代码，它就可以保存该实现以供将来使用：\n\n````\n// 在 ./skills/save-sheet-as-csv.ts 中\n从“./servers/google-drive”导入*作为gdrive；\n导出异步函数 saveSheetAsCsv(sheetId: string) {\nconst data =等待gdrive.getSheet({sheetId});\nconst csv = data.map(row => row.join(',')).join('\\n');\n等待 fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\n返回 `./workspace/sheet-${sheetId}.csv`;\n}\n\n// 稍后，在任何代理执行中：\n从 './skills/save-sheet-as-csv' 导入 { saveSheetAsCsv }；\nconst csvPath = 等待 saveSheetAsCsv('abc123');\n````\n\n这与技能、可重用指令的文件夹、脚本和模型资源的概念密切相关，以提高专门任务的性能。将 SKILL.md 文件添加到这些保存的函数中会创建模型可以参考和使用的结构化技能。随着时间的推移，这允许您的代理构建一个具有更高级别功能的工具箱，不断发展最有效工作所需的脚手架。\n\n请注意，代码执行会带来其自身的复杂性。运行代理生成的代码需要一个具有适当沙箱、资源限制和监控的安全执行环境。这些基础设施要求增加了直接工具调用所避免的操作开销和安全考虑。代码执行的好处——降低代币成本、降低延迟和改进工具组合——应该与这些实施成本进行权衡。\n\n概括 MCP 为代理连接到许多工具和系统提供了基础协议。然而，一旦连接太多服务器，工具定义和结果可能会消耗过多的令牌，从而降低代理效率。\n\n尽管这里的许多问题感觉很新颖——上下文管理、工具组合、状态持久性——但他们已经从软件工程中找到了已知的解决方案。代码执行将这些已建立的模式应用于代理，让它们使用熟悉的编程结构更有效地与 MCP 服务器交互。如果您实施此方法，我们鼓励您与 MCP 社区分享您的发现。\n\n致谢\n\n本文由亚当·琼斯和康纳·凯利撰写。感谢 Jeremy Fox、Jerome Swannack、Stuart Ritchie、Molly Vorwerck、Matt Samuels 和 Maggie Vo 对本文草稿的反馈。",
        "edited": false
      },
      "hi": {
        "title": "एमसीपी के साथ कोड निष्पादन: अधिक कुशल एजेंटों का निर्माण",
        "content": "मॉडल कॉन्टेक्स्ट प्रोटोकॉल (एमसीपी) एआई एजेंटों को बाहरी सिस्टम से जोड़ने के लिए एक खुला मानक है।एजेंटों को टूल और डेटा से कनेक्ट करने के लिए पारंपरिक रूप से प्रत्येक जोड़ी के लिए एक कस्टम एकीकरण की आवश्यकता होती है, जिससे विखंडन और दोहराव का प्रयास होता है जिससे वास्तव में कनेक्टेड सिस्टम को स्केल करना मुश्किल हो जाता है।एमसीपी एक सार्वभौमिक प्रोटोकॉल प्रदान करता है-डेवलपर्स अपने एजेंट में एक बार एमसीपी लागू करते हैं और यह एकीकरण के पूरे पारिस्थितिकी तंत्र को अनलॉक करता है।\n\nनवंबर 2024 में एमसीपी लॉन्च करने के बाद से, अपनाने में तेजी आई है: समुदाय ने हजारों एमसीपी सर्वर बनाए हैं, एसडीके सभी प्रमुख प्रोग्रामिंग भाषाओं के लिए उपलब्ध हैं, और उद्योग ने एजेंटों को टूल और डेटा से जोड़ने के लिए एमसीपी को वास्तविक मानक के रूप में अपनाया है।\n\nआज डेवलपर्स नियमित रूप से दर्जनों एमसीपी सर्वरों पर सैकड़ों या हजारों टूल तक पहुंच वाले एजेंट बनाते हैं।हालाँकि, जैसे-जैसे कनेक्टेड टूल की संख्या बढ़ती है, सभी टूल परिभाषाओं को अग्रिम रूप से लोड करना और संदर्भ विंडो के माध्यम से मध्यवर्ती परिणाम पास करना एजेंटों को धीमा कर देता है और लागत बढ़ा देता है।\n\nइस ब्लॉग में हम यह पता लगाएंगे कि कैसे कोड निष्पादन एजेंटों को एमसीपी सर्वर के साथ अधिक कुशलता से बातचीत करने में सक्षम बना सकता है, कम टोकन का उपयोग करते हुए अधिक टूल को संभाल सकता है।\n\nटूल से अत्यधिक टोकन खपत एजेंटों को कम कुशल बनाती है\n\nएमसीपी उपयोग पैमाने के रूप में, दो सामान्य पैटर्न हैं जो एजेंट लागत और विलंबता को बढ़ा सकते हैं:\n\n- टूल परिभाषाएँ संदर्भ विंडो को ओवरलोड करती हैं;\n\n- इंटरमीडिएट टूल परिणाम अतिरिक्त टोकन का उपभोग करते हैं।\n\n1. टूल परिभाषाएँ संदर्भ विंडो को ओवरलोड करती हैं\n\nअधिकांश एमसीपी क्लाइंट सभी टूल परिभाषाओं को सीधे संदर्भ में लोड करते हैं, उन्हें सीधे टूल-कॉलिंग सिंटैक्स का उपयोग करके मॉडल में उजागर करते हैं।ये टूल परिभाषाएँ इस तरह दिख सकती हैं:\n\n```\ngdrive.getDocument\nविवरण: Google ड्राइव से एक दस्तावेज़ पुनर्प्राप्त करता है\nपैरामीटर:\ndocumentId (आवश्यक, स्ट्रिंग): पुनर्प्राप्त करने के लिए दस्तावेज़ की आईडी\nफ़ील्ड (वैकल्पिक, स्ट्रिंग): लौटने के लिए विशिष्ट फ़ील्ड\nरिटर्न: शीर्षक, मुख्य सामग्री, मेटाडेटा, अनुमतियाँ आदि के साथ दस्तावेज़ ऑब्जेक्ट।\n```\n\n```\nसेल्सफोर्स.अपडेटरिकॉर्ड\nविवरण: सेल्सफोर्स में एक रिकॉर्ड अपडेट करता है\nपैरामीटर:\nऑब्जेक्ट प्रकार (आवश्यक, स्ट्रिंग): सेल्सफोर्स ऑब्जेक्ट का प्रकार (लीड, संपर्क, खाता, आदि)\nरिकॉर्डआईडी (आवश्यक, स्ट्रिंग): अद्यतन करने के लिए रिकॉर्ड की आईडी\nडेटा (आवश्यक, वस्तु): अपने नए मानों के साथ अद्यतन करने के लिए फ़ील्ड\nरिटर्न: पुष्टिकरण के साथ अद्यतन रिकॉर्ड ऑब्जेक्ट\n```\n\nटूल विवरण अधिक संदर्भ विंडो स्थान घेरते हैं, जिससे प्रतिक्रिया समय और लागत बढ़ जाती है।ऐसे मामलों में जहां एजेंट हजारों टूल से जुड़े हैं, उन्हें अनुरोध पढ़ने से पहले सैकड़ों हजारों टोकन संसाधित करने की आवश्यकता होगी।\n\n2. इंटरमीडिएट टूल परिणाम अतिरिक्त टोकन का उपभोग करते हैं\n\nअधिकांश एमसीपी क्लाइंट मॉडलों को सीधे एमसीपी टूल्स को कॉल करने की अनुमति देते हैं।उदाहरण के लिए, आप अपने एजेंट से पूछ सकते हैं: \"Google ड्राइव से मेरी मीटिंग ट्रांसक्रिप्ट डाउनलोड करें और इसे Salesforce लीड में संलग्न करें।\"\n\nमॉडल इस प्रकार कॉल करेगा:\n\n```\nटूल कॉल: gdrive.getDocument(documentId: \"abc123\")\n→ रिटर्न \"Q4 लक्ष्यों पर चर्चा की गई...\\n[पूर्ण प्रतिलेख पाठ]\"\n(मॉडल संदर्भ में लोड किया गया)\n\nटूल कॉल: salesforce.updateRecord(\nऑब्जेक्ट प्रकार: \"सेल्समीटिंग\",\nरिकॉर्ड आईडी: \"00Q5f000001abcXYZ\",\nडेटा: { \"नोट्स\": \"Q4 लक्ष्यों पर चर्चा की गई...\\n[पूरा प्रतिलेख पाठ लिखा गया]\" }\n)\n(मॉडल को संपूर्ण प्रतिलेख को संदर्भ में फिर से लिखने की आवश्यकता है)\n```\n\nप्रत्येक मध्यवर्ती परिणाम को मॉडल से गुजरना होगा।इस उदाहरण में, पूर्ण कॉल ट्रांस्क्रिप्ट दो बार प्रवाहित होती है।2 घंटे की बिक्री बैठक के लिए, इसका मतलब अतिरिक्त 50,000 टोकन संसाधित करना हो सकता है।यहां तक ​​कि बड़े दस्तावेज़ भी संदर्भ विंडो की सीमा को पार कर सकते हैं, जिससे वर्कफ़्लो बाधित हो सकता है।\n\nबड़े दस्तावेज़ों या जटिल डेटा संरचनाओं के साथ, टूल कॉल के बीच डेटा कॉपी करते समय मॉडल से गलतियाँ होने की अधिक संभावना हो सकती है।\n\n[[IMAGE_1|MCP क्लाइंट टूल परिभाषाओं को मॉडल की संदर्भ विंडो में लोड करता है और एक संदेश लूप को व्यवस्थित करता है जहां प्रत्येक टूल कॉल और परिणाम संचालन के बीच मॉडल से गुजरता है।]]\n\nएमसीपी के साथ कोड निष्पादन संदर्भ दक्षता में सुधार करता है\n\nएजेंटों के लिए कोड निष्पादन वातावरण अधिक सामान्य होने के साथ, एक समाधान एमसीपी सर्वर को सीधे टूल कॉल के बजाय कोड एपीआई के रूप में प्रस्तुत करना है।फिर एजेंट एमसीपी सर्वर के साथ इंटरैक्ट करने के लिए कोड लिख सकता है।यह दृष्टिकोण दोनों चुनौतियों का समाधान करता है: एजेंट केवल उन उपकरणों को लोड कर सकते हैं जिनकी उन्हें आवश्यकता है और परिणामों को मॉडल पर वापस भेजने से पहले निष्पादन वातावरण में डेटा को संसाधित कर सकते हैं। यह करने के कई तरीके हैं।एक दृष्टिकोण कनेक्टेड एमसीपी सर्वर से सभी उपलब्ध टूल का फ़ाइल ट्री तैयार करना है।यहां टाइपस्क्रिप्ट का उपयोग करके एक कार्यान्वयन दिया गया है:\n\n```\nसर्वर\n├── गूगल-ड्राइव\n│ ├── getDocument.ts\n│ ├── ... (अन्य उपकरण)\n│ └── Index.ts\n├── सेल्सफोर्स\n│ ├── updateRecord.ts\n│ ├── ... (अन्य उपकरण)\n│ └── Index.ts\n└── ... (अन्य सर्वर)\n```\n\nफिर प्रत्येक उपकरण एक फ़ाइल से मेल खाता है, कुछ इस प्रकार:\n\n```\n// ./servers/google-drive/getDocument.ts\n\"../../../client.js\" से आयात { callMCPTool };\n\nइंटरफ़ेस GetDocumentInput {\nदस्तावेज़ आईडी: स्ट्रिंग;\n}\n\nइंटरफ़ेस GetDocumentResponse {\nसामग्री: स्ट्रिंग;\n}\n\n/* Google ड्राइव से एक दस्तावेज़ पढ़ें */\nasync फ़ंक्शन getDocument निर्यात करें (इनपुट: GetDocumentInput): वादा<GetDocumentResponse> {\nरिटर्न कॉलMCPTool<GetDocumentResponse>('google_drive__get_document', इनपुट);\n}\n```\n\nउपरोक्त हमारा Google Drive to Salesforce उदाहरण कोड बन जाता है:\n\n```\n// Google डॉक्स से प्रतिलेख पढ़ें और Salesforce संभावना में जोड़ें\n'./servers/google-drive' से gdrive के रूप में आयात करें;\n'./सर्वर/सेल्सफोर्स' से सेल्सफोर्स के रूप में आयात करें;\n\nस्थिरांक प्रतिलेख = (प्रतीक्षा gdrive.getDocument({ documentId: 'abc123' })).सामग्री;\nsalesforce.updateRecord({ का इंतजार करें\nऑब्जेक्ट प्रकार: 'सेल्समीटिंग',\nरिकॉर्डआईडी: '00Q5f000001abcXYZ',\nडेटा: { नोट्स: प्रतिलेख }\n});\n```\n\nएजेंट फ़ाइल सिस्टम की खोज करके टूल खोजता है: उपलब्ध सर्वर (जैसे Google-ड्राइव और सेल्सफोर्स) को खोजने के लिए ./servers/ निर्देशिका को सूचीबद्ध करता है, फिर प्रत्येक टूल के इंटरफ़ेस को समझने के लिए आवश्यक विशिष्ट टूल फ़ाइलों को पढ़ता है (जैसे getDocument.ts और updateRecord.ts)।यह एजेंट को केवल वही परिभाषाएँ लोड करने देता है जिनकी उसे वर्तमान कार्य के लिए आवश्यकता है।इससे टोकन का उपयोग 150,000 टोकन से घटकर 2,000 टोकन हो जाता है - समय और लागत में 98.7% की बचत होती है।\n\nक्लाउडफ्लेयर ने एमसीपी के साथ कोड निष्पादन को \"कोड मोड\" के रूप में संदर्भित करते हुए इसी तरह के निष्कर्ष प्रकाशित किए।मूल अंतर्दृष्टि समान है: एलएलएम कोड लिखने में माहिर हैं और डेवलपर्स को ऐसे एजेंटों का निर्माण करने के लिए इस ताकत का लाभ उठाना चाहिए जो एमसीपी सर्वर के साथ अधिक कुशलता से बातचीत करते हैं।\n\nएमसीपी के साथ कोड निष्पादन के लाभ\n\nएमसीपी के साथ कोड निष्पादन एजेंटों को मांग पर टूल लोड करके, मॉडल तक पहुंचने से पहले डेटा को फ़िल्टर करके और एक ही चरण में जटिल तर्क निष्पादित करके संदर्भ का अधिक कुशलता से उपयोग करने में सक्षम बनाता है।इस दृष्टिकोण का उपयोग करने के सुरक्षा और राज्य प्रबंधन लाभ भी हैं।\n\nप्रगतिशील खुलासा\n\nफ़ाइल सिस्टम को नेविगेट करने में मॉडल बहुत अच्छे हैं।फ़ाइल सिस्टम पर टूल को कोड के रूप में प्रस्तुत करने से मॉडल को टूल परिभाषाओं को पहले से पढ़ने के बजाय ऑन-डिमांड पढ़ने की अनुमति मिलती है।\n\nवैकल्पिक रूप से, प्रासंगिक परिभाषाएँ खोजने के लिए सर्वर में एक search_tools टूल जोड़ा जा सकता है।उदाहरण के लिए, ऊपर उपयोग किए गए काल्पनिक सेल्सफोर्स सर्वर के साथ काम करते समय, एजेंट \"सेल्सफोर्स\" की खोज करता है और केवल उन उपकरणों को लोड करता है जिनकी उसे वर्तमान कार्य के लिए आवश्यकता होती है।search_tools टूल में एक विवरण स्तर पैरामीटर शामिल करना जो एजेंट को आवश्यक विवरण के स्तर (जैसे केवल नाम, नाम और विवरण, या स्कीमा के साथ पूर्ण परिभाषा) का चयन करने की अनुमति देता है, एजेंट को संदर्भ को संरक्षित करने और टूल को कुशलतापूर्वक ढूंढने में भी मदद करता है।\n\nप्रसंग कुशल उपकरण परिणाम\n\nबड़े डेटासेट के साथ काम करते समय, एजेंट परिणामों को वापस करने से पहले उन्हें फ़िल्टर और कोड में बदल सकते हैं।10,000-पंक्ति वाली स्प्रेडशीट लाने पर विचार करें:\n\n```\n// कोड निष्पादन के बिना - सभी पंक्तियाँ संदर्भ के माध्यम से प्रवाहित होती हैं\nटूल कॉल: gdrive.getSheet(शीटआईडी: 'abc123')\n→ मैन्युअल रूप से फ़िल्टर करने के लिए संदर्भ में 10,000 पंक्तियाँ लौटाता है\n\n// कोड निष्पादन के साथ - निष्पादन वातावरण में फ़िल्टर करें\nस्थिरांक allRows = प्रतीक्षा gdrive.getSheet({ शीटआईडी: 'abc123' });\nस्थिरांक लंबित आदेश = allRows.filter(पंक्ति =>\nपंक्ति[\"स्थिति\"] === 'लंबित'\n);\nकंसोल.लॉग(`${pendingOrders.length} लंबित ऑर्डर मिले`);\nकंसोल.लॉग(पेंडिंगऑर्डर्स.स्लाइस(0, 5));// समीक्षा के लिए केवल पहले 5 लॉग करें\n```\n\nएजेंट को 10,000 के बजाय पाँच पंक्तियाँ दिखाई देती हैं।समान पैटर्न एकत्रीकरण के लिए काम करते हैं, कई डेटा स्रोतों में जुड़ते हैं, या विशिष्ट फ़ील्ड को निकालते हैं - संदर्भ विंडो को फुलाए बिना।\n\nअधिक शक्तिशाली और संदर्भ-कुशल नियंत्रण प्रवाह\n\nलूप, कंडीशनल और त्रुटि प्रबंधन को अलग-अलग टूल कॉल को चेन करने के बजाय परिचित कोड पैटर्न के साथ किया जा सकता है।उदाहरण के लिए, यदि आपको स्लैक में परिनियोजन अधिसूचना की आवश्यकता है, तो एजेंट लिख सकता है: ```\nचलो पाया = झूठा;\nजबकि (!पाया गया) {\nस्थिरांक संदेश = प्रतीक्षा करें slack.getChannelHistory({चैनल: 'C123456' });\nमिला = messages.some(m => m.text.includes('तैनाती पूर्ण'));\nयदि (!पाया गया) नए वादे का इंतजार करें(आर => सेटटाइमआउट(आर, 5000));\n}\nकंसोल.लॉग ('परिनियोजन अधिसूचना प्राप्त हुई');\n```\n\nयह दृष्टिकोण एजेंट लूप के माध्यम से एमसीपी टूल कॉल और स्लीप कमांड के बीच वैकल्पिक करने से अधिक कुशल है।\n\nइसके अतिरिक्त, निष्पादित होने वाले एक सशर्त पेड़ को लिखने में सक्षम होने से \"पहले टोकन के समय\" विलंबता पर भी बचत होती है: किसी इफ-स्टेटमेंट का मूल्यांकन करने के लिए मॉडल की प्रतीक्षा करने के बजाय, एजेंट कोड निष्पादन वातावरण को ऐसा करने दे सकता है।\n\nगोपनीयता-संरक्षण संचालन\n\nजब एजेंट एमसीपी के साथ कोड निष्पादन का उपयोग करते हैं, तो मध्यवर्ती परिणाम डिफ़ॉल्ट रूप से निष्पादन वातावरण में रहते हैं।इस तरह, एजेंट केवल वही देखता है जो आप स्पष्ट रूप से लॉग करते हैं या लौटाते हैं, जिसका अर्थ है कि जिस डेटा को आप मॉडल के साथ साझा नहीं करना चाहते हैं वह मॉडल के संदर्भ में प्रवेश किए बिना आपके वर्कफ़्लो के माध्यम से प्रवाहित हो सकता है।\n\nऔर भी अधिक संवेदनशील कार्यभार के लिए, एजेंट हार्नेस संवेदनशील डेटा को स्वचालित रूप से टोकनाइज़ कर सकता है।उदाहरण के लिए, कल्पना करें कि आपको स्प्रेडशीट से सेल्सफोर्स में ग्राहक संपर्क विवरण आयात करने की आवश्यकता है।एजेंट लिखता है:\n\n```\nस्थिरांक शीट = प्रतीक्षा gdrive.getSheet({ शीटआईडी: 'एबीसी123' });\n(शीट.पंक्तियों की स्थिर पंक्ति) के लिए {\nsalesforce.updateRecord({ का इंतजार करें\nऑब्जेक्ट प्रकार: 'लीड',\nरिकॉर्डआईडी: row.salesforceId,\nडेटा: {\nईमेल: row.email,\nफ़ोन: पंक्ति.फ़ोन,\nनाम: पंक्ति.नाम\n}\n});\n}\nकंसोल.लॉग(`अपडेटेड ${शीट.रो.लेंथ} लीड`);\n```\n\nएमसीपी क्लाइंट डेटा को इंटरसेप्ट करता है और मॉडल तक पहुंचने से पहले पीआईआई को टोकनाइज़ करता है:\n\n```\n// एजेंट क्या देखेगा, यदि उसने शीट.पंक्तियों को लॉग किया है:\n[\n{ salesforceId: '00Q...', ईमेल: '[EMAIL_1]', फ़ोन: '[PHONE_1]', नाम: '[NAME_1]' },\n{ salesforceId: '00Q...', ईमेल: '[EMAIL_2]', फ़ोन: '[PHONE_2]', नाम: '[NAME_2]' },\n...\n]\n```\n\nफिर, जब डेटा को किसी अन्य MCP टूल कॉल में साझा किया जाता है, तो इसे MCP क्लाइंट में लुकअप के माध्यम से अनटोकनाइज़ किया जाता है।वास्तविक ईमेल पते, फ़ोन नंबर और नाम Google शीट से Salesforce तक प्रवाहित होते हैं, लेकिन मॉडल के माध्यम से कभी नहीं।यह एजेंट को संवेदनशील डेटा को गलती से लॉग करने या संसाधित करने से रोकता है।आप इसका उपयोग नियतात्मक सुरक्षा नियमों को परिभाषित करने के लिए भी कर सकते हैं, यह चुनकर कि डेटा कहाँ और कहाँ से प्रवाहित हो सकता है।\n\nराज्य दृढ़ता और कौशल\n\nफ़ाइल सिस्टम एक्सेस के साथ कोड निष्पादन एजेंटों को संचालन में स्थिति बनाए रखने की अनुमति देता है।एजेंट फ़ाइलों में मध्यवर्ती परिणाम लिख सकते हैं, जिससे वे काम फिर से शुरू करने और प्रगति को ट्रैक करने में सक्षम हो सकते हैं:\n\n```\nस्थिरांक लीड = प्रतीक्षा करें salesforce.query({\nक्वेरी: 'लीड सीमा 1000 से आईडी, ईमेल चुनें'\n});\nconst csvData = Leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nप्रतीक्षा करें fs.writeFile('./workspace/leads.csv', csvData);\n\n// बाद में निष्पादन वहीं से शुरू होता है जहां इसे छोड़ा गया था\nस्थिरांक सहेजा गया = प्रतीक्षा करें fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nएजेंट अपने स्वयं के कोड को पुन: प्रयोज्य कार्यों के रूप में भी जारी रख सकते हैं।एक बार जब कोई एजेंट किसी कार्य के लिए कार्यशील कोड विकसित कर लेता है, तो वह उस कार्यान्वयन को भविष्य में उपयोग के लिए सहेज सकता है:\n\n```\n// इन ./skills/save-शीट-as-csv.ts\n'./servers/google-drive' से gdrive के रूप में आयात करें;\nनिर्यात async फ़ंक्शन saveSheetAsCsv(शीटआईडी: स्ट्रिंग) {\nस्थिरांक डेटा = प्रतीक्षा gdrive.getSheet({ शीटआईडी });\nconst csv = data.map(row => row.join(',')).join('\\n');\nप्रतीक्षा करें fs.writeFile(`./workspace/शीट-${शीटआईडी}.csv`, csv);\nवापसी `./workspace/शीट-${शीटआईडी}.csv`;\n}\n\n// बाद में, किसी भी एजेंट निष्पादन में:\n'./skills/save-Sheet-as-csv' से आयात { saveSheetAsCsv };\nconst csvPath = प्रतीक्षा करें saveSheetAsCsv('abc123');\n```\n\nयह विशेष कार्यों पर प्रदर्शन को बेहतर बनाने के लिए कौशल, पुन: प्रयोज्य निर्देशों के फ़ोल्डर, स्क्रिप्ट और मॉडल के संसाधनों की अवधारणा से निकटता से जुड़ा हुआ है।इन सहेजे गए फ़ंक्शंस में SKILL.md फ़ाइल जोड़ने से एक संरचित कौशल बनता है जिसे मॉडल संदर्भित और उपयोग कर सकते हैं।समय के साथ, यह आपके एजेंट को उच्च-स्तरीय क्षमताओं का एक टूलबॉक्स बनाने की अनुमति देता है, जिससे वह मचान विकसित होता है जिसकी उसे सबसे प्रभावी ढंग से काम करने की आवश्यकता होती है।\n\nध्यान दें कि कोड निष्पादन अपनी जटिलता का परिचय देता है।एजेंट-जनरेटेड कोड चलाने के लिए उपयुक्त सैंडबॉक्सिंग, संसाधन सीमा और निगरानी के साथ एक सुरक्षित निष्पादन वातावरण की आवश्यकता होती है।इन बुनियादी ढाँचे की आवश्यकताओं में परिचालन ओवरहेड और सुरक्षा संबंधी विचार शामिल होते हैं जिनसे प्रत्यक्ष टूल कॉल से बचा जा सकता है।कोड निष्पादन-कम टोकन लागत, कम विलंबता और बेहतर उपकरण संरचना-के लाभों को इन कार्यान्वयन लागतों के विरुद्ध तौला जाना चाहिए।\n\nसारांश एमसीपी एजेंटों को कई टूल और सिस्टम से जुड़ने के लिए एक मूलभूत प्रोटोकॉल प्रदान करता है।हालाँकि, एक बार जब बहुत सारे सर्वर कनेक्ट हो जाते हैं, तो टूल परिभाषाएँ और परिणाम अत्यधिक टोकन का उपभोग कर सकते हैं, जिससे एजेंट की दक्षता कम हो जाती है।\n\nयद्यपि यहां कई समस्याएं नवीन हैं-संदर्भ प्रबंधन, उपकरण संरचना, राज्य दृढ़ता-उनके पास सॉफ्टवेयर इंजीनियरिंग से ज्ञात समाधान हैं।कोड निष्पादन इन स्थापित पैटर्न को एजेंटों पर लागू करता है, जिससे उन्हें एमसीपी सर्वर के साथ अधिक कुशलता से बातचीत करने के लिए परिचित प्रोग्रामिंग संरचनाओं का उपयोग करने की सुविधा मिलती है।यदि आप इस दृष्टिकोण को लागू करते हैं, तो हम आपको अपने निष्कर्षों को एमसीपी समुदाय के साथ साझा करने के लिए प्रोत्साहित करते हैं।\n\nआभार\n\nयह लेख एडम जोन्स और कॉनर केली द्वारा लिखा गया था।इस पोस्ट के ड्राफ्ट पर प्रतिक्रिया के लिए जेरेमी फॉक्स, जेरोम स्वानैक, स्टुअर्ट रिची, मौली वोरवर्क, मैट सैमुअल्स और मैगी वो को धन्यवाद।",
        "edited": false
      }
    },
    "metadata": {
      "tags": [
        "Anthropic",
        "MCP",
        "Engineering"
      ]
    }
  },
  {
    "id": "sample-arxiv-decision-making-agents",
    "source": "arXiv",
    "source_url": "https://arxiv.org/abs/2512.10937v1",
    "title": "On Decision-Making Agents and Higher-Order Causal Processes",
    "author": "arXiv",
    "published_date": "2025-12-11T00:00:00Z",
    "scraped_at": 1733875200000,
    "status": "published",
    "content": {
      "original_html": "",
      "text": "We establish a precise correspondence between decision-making agents in partially observable\nMarkov decision processes (POMDPs) and one-input process functions, the classical limit of higherorder quantum operations. In this identification an agent’s policy and memory update combine into\na process function w that interacts with a POMDP environment via the link product. This suggests\na dual interpretation: in the physics view, the process function acts as the environment into which\nlocal operations (agent interventions) are inserted, whereas in the AI view it encodes the agent and\nthe inserted functions represent environments",
      "images": []
    },
    "translations": {
      "es": {
        "title": "Sobre los agentes que toman decisiones y los procesos causales de orden superior",
        "content": "lectura rápida\n- Muestra una correspondencia uno a uno entre agentes POMDP de memoria finita y funciones de proceso de una entrada de la teoría cuántica de orden superior.\n- Las políticas más las actualizaciones de memoria se reformulan como una función de proceso única;Los entornos se convierten en mapas complementarios, o viceversa en la vista de física.\n- Los dec-POMDP independientes de la observación se asignan claramente a funciones de proceso de múltiples entradas, lo que permite estrategias sin un orden causal fijo.\n- Define recompensa con descuento para estrategias de función de proceso y la alinea con políticas de agente-estado cuando el orden es definitivo.\n- Preguntas abiertas: ¿puede el orden causal indefinido vencer a las políticas estándar?cómo iterar/aprender dichas estrategias;cómo extenderse a juegos y POMDP cuánticos.\n\nPor qué es importante\nUne el aprendizaje por refuerzo y la causalidad cuántica de orden superior, brindando un lenguaje común para agentes, entornos y recompensas, e insinuando ventajas cuánticas en problemas de decisión de múltiples agentes.\n\nSi necesita detalles matemáticos completos (fórmulas y pruebas), abra el enlace PDF en la parte superior;este resumen mantiene la página ligera y legible.",
        "edited": false
      },
      "ukr": {
        "title": "Про агентів прийняття рішень і причинно-наслідкові процеси вищого порядку",
        "content": "Швидке читання\n- Показує однозначну відповідність між агентами POMDP зі скінченною пам’яттю та функціями процесу з одним входом із квантової теорії вищого порядку.\n- Політики та оновлення пам'яті переробляються як єдина функція процесу;середовища стають плагінами карт або навпаки у фізичному поданні.\n- Незалежні від спостереження dec-POMDP чітко відображають функції процесу з кількома входами, що дозволяє використовувати стратегії без фіксованого причинно-наслідкового порядку.\n- Визначає знижену винагороду для стратегій процесу-функції та узгоджує її з політикою агента-держави, коли порядок визначений.\n- Відкриті питання: чи може невизначений причинно-наслідковий порядок перевершити стандартні політики;як ітерувати/вивчити такі стратегії;як поширити на квантові POMDP та ігри.\n\nЧому це важливо\nПоєднує підсилювальне навчання та квантову причинність вищого порядку, створюючи спільну мову для агентів, середовищ і винагород, а також натякаючи на квантові переваги в проблемах прийняття рішення кількома агентами.\n\nЯкщо вам потрібні повні математичні деталі (формули та докази), відкрийте посилання PDF у верхній частині;це резюме робить сторінку легкою та читабельною.",
        "edited": false
      },
      "pt": {
        "title": "Sobre Agentes Tomadores de Decisão e Processos Causais de Ordem Superior",
        "content": "Leitura rápida\n- Mostra uma correspondência um-para-um entre agentes POMDP de memória finita e funções de processo de entrada única da teoria quântica de ordem superior.\n- Políticas e atualizações de memória são reformuladas como uma única função de processo;os ambientes tornam-se mapas plug-in ou vice-versa na visualização física.\n- Os dec-POMDPs independentes de observação são mapeados de forma limpa para funções de processo com múltiplas entradas, permitindo estratégias sem uma ordem causal fixa.\n- Define recompensas com desconto para estratégias de função de processo e alinha-as com políticas agente-estado quando a ordem é definida.\n- Questões abertas: a ordem causal indefinida pode superar as políticas padrão;como iterar/aprender tais estratégias;como estender para POMDPs e jogos quânticos.\n\nPor que isso importa\nEstabelece uma ponte entre o aprendizado por reforço e a causalidade quântica de ordem superior, fornecendo uma linguagem comum para agentes, ambientes e recompensas, e sugerindo vantagens quânticas em problemas de decisão multiagentes.\n\nSe precisar de detalhes matemáticos completos (fórmulas e provas), abra o link do PDF no topo;este resumo mantém a página leve e legível.",
        "edited": false
      },
      "zh": {
        "title": "关于决策主体和高阶因果过程",
        "content": "快速阅读\n- 显示有限内存 POMDP 代理与高阶量子理论中的单输入过程函数之间的一对一对应关系。\n- 策略加上内存更新被重新构建为单个进程功能；在物理视图中，环境变成插件贴图，反之亦然。\n- 与观察无关的 dec-POMDP 清晰地映射到多输入过程函数，从而实现没有固定因果顺序的策略。\n- 定义流程功能策略的折扣奖励，并在订单明确时将其与代理状态策略保持一致。\n- 开放性问题：不确定的因果顺序能否击败标准政策；如何迭代/学习此类策略；如何扩展到量子 POMDP 和游戏。\n\n为什么这很重要\n连接强化学习和高阶量子因果关系，为代理、环境和奖励提供通用语言，并暗示多代理决策问题中的量子优势。\n\n如果您需要完整的数学细节（公式和证明），请打开顶部的 PDF 链接；此摘要使页面保持轻量级和可读性。",
        "edited": false
      },
      "hi": {
        "title": "निर्णय लेने वाले एजेंटों और उच्च-क्रम कारण प्रक्रियाओं पर",
        "content": "जल्दी पढ़ो\n- उच्च-क्रम क्वांटम सिद्धांत से परिमित-मेमोरी पीओएमडीपी एजेंटों और एक-इनपुट प्रक्रिया कार्यों के बीच एक-से-एक पत्राचार दिखाता है।\n- नीतियों और मेमोरी अपडेट को एकल प्रक्रिया फ़ंक्शन के रूप में पुनर्गठित किया जाता है;वातावरण प्लग-इन मानचित्र बन जाते हैं, या भौतिकी की दृष्टि से इसके विपरीत।\n- अवलोकन-स्वतंत्र dec-POMDPs मल्टी-इनपुट प्रक्रिया कार्यों के लिए स्पष्ट रूप से मैप करते हैं, एक निश्चित कारण क्रम के बिना रणनीतियों को सक्षम करते हैं।\n- प्रक्रिया-फ़ंक्शन रणनीतियों के लिए रियायती इनाम को परिभाषित करता है और ऑर्डर निश्चित होने पर इसे एजेंट-राज्य नीतियों के साथ संरेखित करता है।\n- खुले प्रश्न: क्या अनिश्चितकालीन कारण आदेश मानक नीतियों को मात दे सकता है;ऐसी रणनीतियों को कैसे दोहराया/सीखा जाए;क्वांटम पीओएमडीपी और गेम तक कैसे विस्तार करें।\n\nयह क्यों मायने रखता है?\nसुदृढीकरण सीखने और उच्च-क्रम क्वांटम कार्य-कारण को पुल करता है, एजेंटों, वातावरण और पुरस्कारों के लिए एक आम भाषा देता है, और बहु-एजेंट निर्णय समस्याओं में क्वांटम फायदे पर संकेत देता है।\n\nयदि आपको पूर्ण गणितीय विवरण (सूत्र और प्रमाण) चाहिए, तो शीर्ष पर पीडीएफ लिंक खोलें;यह सारांश पृष्ठ को हल्का और पठनीय रखता है।",
        "edited": false
      }
    },
    "metadata": {
      "tags": [
        "arXiv",
        "Causality",
        "Agents"
      ]
    }
  }
]
