{
  "id": "sample-anthropic-code-execution",
  "source": "Anthropic",
  "source_url": "https://www.anthropic.com/engineering/code-execution-with-mcp",
  "title": "Code execution with MCP: Building more efficient agents",
  "author": "Anthropic Engineering",
  "published_date": "2025-11-04T00:00:00Z",
  "scraped_at": 1733203200000,
  "status": "published",
  "content": {
    "original_html": "",
    "text": "The Model Context Protocol (MCP) is an open standard for connecting AI agents to external systems. Connecting agents to tools and data traditionally requires a custom integration for each pairing, creating fragmentation and duplicated effort that makes it difficult to scale truly connected systems. MCP provides a universal protocol-developers implement MCP once in their agent and it unlocks an entire ecosystem of integrations.\n\nSince launching MCP in November 2024, adoption has been rapid: the community has built thousands of MCP servers , SDKs are available for all major programming languages, and the industry has adopted MCP as the de-facto standard for connecting agents to tools and data.\n\nToday developers routinely build agents with access to hundreds or thousands of tools across dozens of MCP servers. However, as the number of connected tools grows, loading all tool definitions upfront and passing intermediate results through the context window slows down agents and increases costs.\n\nIn this blog we'll explore how code execution can enable agents to interact with MCP servers more efficiently, handling more tools while using fewer tokens.\n\nExcessive token consumption from tools makes agents less efficient\n\nAs MCP usage scales, there are two common patterns that can increase agent cost and latency:\n\n- Tool definitions overload the context window;\n\n- Intermediate tool results consume additional tokens.\n\n1. Tool definitions overload the context window\n\nMost MCP clients load all tool definitions upfront directly into context, exposing them to the model using a direct tool-calling syntax. These tool definitions might look like:\n\n```\ngdrive.getDocument\n     Description: Retrieves a document from Google Drive\n     Parameters:\n                documentId (required, string): The ID of the document to retrieve\n                fields (optional, string): Specific fields to return\n     Returns: Document object with title, body content, metadata, permissions, etc.\n```\n\n```\nsalesforce.updateRecord\n    Description: Updates a record in Salesforce\n    Parameters:\n               objectType (required, string): Type of Salesforce object (Lead, Contact,      Account, etc.)\n               recordId (required, string): The ID of the record to update\n               data (required, object): Fields to update with their new values\n     Returns: Updated record object with confirmation\n```\n\nTool descriptions occupy more context window space, increasing response time and costs. In cases where agents are connected to thousands of tools, they'll need to process hundreds of thousands of tokens before reading a request.\n\n2. Intermediate tool results consume additional tokens\n\nMost MCP clients allow models to directly call MCP tools. For example, you might ask your agent: \"Download my meeting transcript from Google Drive and attach it to the Salesforce lead.\"\n\nThe model will make calls like:\n\n```\nTOOL CALL: gdrive.getDocument(documentId: \"abc123\")\n        → returns \"Discussed Q4 goals...\\n[full transcript text]\"\n           (loaded into model context)\n\nTOOL CALL: salesforce.updateRecord(\n\t\t\tobjectType: \"SalesMeeting\",\n\t\t\trecordId: \"00Q5f000001abcXYZ\",\n  \t\t\tdata: { \"Notes\": \"Discussed Q4 goals...\\n[full transcript text written out]\" }\n\t\t)\n\t\t(model needs to write entire transcript into context again)\n```\n\nEvery intermediate result must pass through the model. In this example, the full call transcript flows through twice. For a 2-hour sales meeting, that could mean processing an additional 50,000 tokens. Even larger documents may exceed context window limits, breaking the workflow.\n\nWith large documents or complex data structures, models may be more likely to make mistakes when copying data between tool calls.\n\n[[IMAGE_1|The MCP client loads tool definitions into the model's context window and orchestrates a message loop where each tool call and result passes through the model between operations.]]\n\nCode execution with MCP improves context efficiency\n\nWith code execution environments becoming more common for agents, a solution is to present MCP servers as code APIs rather than direct tool calls. The agent can then write code to interact with MCP servers. This approach addresses both challenges: agents can load only the tools they need and process data in the execution environment before passing results back to the model.\n\nThere are a number of ways to do this. One approach is to generate a file tree of all available tools from connected MCP servers. Here's an implementation using TypeScript:\n\n```\nservers\n├── google-drive\n│   ├── getDocument.ts\n│   ├── ... (other tools)\n│   └── index.ts\n├── salesforce\n│   ├── updateRecord.ts\n│   ├── ... (other tools)\n│   └── index.ts\n└── ... (other servers)\n```\n\nThen each tool corresponds to a file, something like:\n\n```\n// ./servers/google-drive/getDocument.ts\nimport { callMCPTool } from \"../../../client.js\";\n\ninterface GetDocumentInput {\n  documentId: string;\n}\n\ninterface GetDocumentResponse {\n  content: string;\n}\n\n/* Read a document from Google Drive */\nexport async function getDocument(input: GetDocumentInput): Promise<GetDocumentResponse> {\n  return callMCPTool<GetDocumentResponse>('google_drive__get_document', input);\n}\n```\n\nOur Google Drive to Salesforce example above becomes the code:\n\n```\n// Read transcript from Google Docs and add to Salesforce prospect\nimport * as gdrive from './servers/google-drive';\nimport * as salesforce from './servers/salesforce';\n\nconst transcript = (await gdrive.getDocument({ documentId: 'abc123' })).content;\nawait salesforce.updateRecord({\n  objectType: 'SalesMeeting',\n  recordId: '00Q5f000001abcXYZ',\n  data: { Notes: transcript }\n});\n```\n\nThe agent discovers tools by exploring the filesystem: listing the ./servers/ directory to find available servers (like google-drive and salesforce ), then reading the specific tool files it needs (like getDocument.ts and updateRecord.ts ) to understand each tool's interface. This lets the agent load only the definitions it needs for the current task. This reduces the token usage from 150,000 tokens to 2,000 tokens-a time and cost saving of 98.7% .\n\nCloudflare published similar findings , referring to code execution with MCP as \"Code Mode.\" The core insight is the same: LLMs are adept at writing code and developers should take advantage of this strength to build agents that interact with MCP servers more efficiently.\n\nBenefits of code execution with MCP\n\nCode execution with MCP enables agents to use context more efficiently by loading tools on demand, filtering data before it reaches the model, and executing complex logic in a single step. There are also security and state management benefits to using this approach.\n\nProgressive disclosure\n\nModels are great at navigating filesystems. Presenting tools as code on a filesystem allows models to read tool definitions on-demand, rather than reading them all up-front.\n\nAlternatively, a search_tools tool can be added to the server to find relevant definitions. For example, when working with the hypothetical Salesforce server used above, the agent searches for \"salesforce\" and loads only those tools that it needs for the current task. Including a detail level parameter in the search_tools tool that allows the agent to select the level of detail required (such as name only, name and description, or the full definition with schemas) also helps the agent conserve context and find tools efficiently.\n\nContext efficient tool results\n\nWhen working with large datasets, agents can filter and transform results in code before returning them. Consider fetching a 10,000-row spreadsheet:\n\n```\n// Without code execution - all rows flow through context\nTOOL CALL: gdrive.getSheet(sheetId: 'abc123')\n        → returns 10,000 rows in context to filter manually\n\n// With code execution - filter in the execution environment\nconst allRows = await gdrive.getSheet({ sheetId: 'abc123' });\nconst pendingOrders = allRows.filter(row => \n  row[\"Status\"] === 'pending'\n);\nconsole.log(`Found ${pendingOrders.length} pending orders`);\nconsole.log(pendingOrders.slice(0, 5)); // Only log first 5 for review\n```\n\nThe agent sees five rows instead of 10,000. Similar patterns work for aggregations, joins across multiple data sources, or extracting specific fields-all without bloating the context window.\n\nMore powerful and context-efficient control flow\n\nLoops, conditionals, and error handling can be done with familiar code patterns rather than chaining individual tool calls. For example, if you need a deployment notification in Slack, the agent can write:\n\n```\nlet found = false;\nwhile (!found) {\n  const messages = await slack.getChannelHistory({ channel: 'C123456' });\n  found = messages.some(m => m.text.includes('deployment complete'));\n  if (!found) await new Promise(r => setTimeout(r, 5000));\n}\nconsole.log('Deployment notification received');\n```\n\nThis approach is more efficient than alternating between MCP tool calls and sleep commands through the agent loop.\n\nAdditionally, being able to write out a conditional tree that gets executed also saves on \"time to first token\" latency: rather than having to wait for a model to evaluate an if-statement, the agent can let the code execution environment do this.\n\nPrivacy-preserving operations\n\nWhen agents use code execution with MCP, intermediate results stay in the execution environment by default. This way, the agent only sees what you explicitly log or return, meaning data you don't wish to share with the model can flow through your workflow without ever entering the model's context.\n\nFor even more sensitive workloads, the agent harness can tokenize sensitive data automatically. For example, imagine you need to import customer contact details from a spreadsheet into Salesforce. The agent writes:\n\n```\nconst sheet = await gdrive.getSheet({ sheetId: 'abc123' });\nfor (const row of sheet.rows) {\n  await salesforce.updateRecord({\n    objectType: 'Lead',\n    recordId: row.salesforceId,\n    data: { \n      Email: row.email,\n      Phone: row.phone,\n      Name: row.name\n    }\n  });\n}\nconsole.log(`Updated ${sheet.rows.length} leads`);\n```\n\nThe MCP client intercepts the data and tokenizes PII before it reaches the model:\n\n```\n// What the agent would see, if it logged the sheet.rows:\n[\n  { salesforceId: '00Q...', email: '[EMAIL_1]', phone: '[PHONE_1]', name: '[NAME_1]' },\n  { salesforceId: '00Q...', email: '[EMAIL_2]', phone: '[PHONE_2]', name: '[NAME_2]' },\n  ...\n]\n```\n\nThen, when the data is shared in another MCP tool call, it is untokenized via a lookup in the MCP client. The real email addresses, phone numbers, and names flow from Google Sheets to Salesforce, but never through the model. This prevents the agent from accidentally logging or processing sensitive data. You can also use this to define deterministic security rules, choosing where data can flow to and from.\n\nState persistence and skills\n\nCode execution with filesystem access allows agents to maintain state across operations. Agents can write intermediate results to files, enabling them to resume work and track progress:\n\n```\nconst leads = await salesforce.query({ \n  query: 'SELECT Id, Email FROM Lead LIMIT 1000' \n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nawait fs.writeFile('./workspace/leads.csv', csvData);\n\n// Later execution picks up where it left off\nconst saved = await fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nAgents can also persist their own code as reusable functions. Once an agent develops working code for a task, it can save that implementation for future use:\n\n```\n// In ./skills/save-sheet-as-csv.ts\nimport * as gdrive from './servers/google-drive';\nexport async function saveSheetAsCsv(sheetId: string) {\n  const data = await gdrive.getSheet({ sheetId });\n  const csv = data.map(row => row.join(',')).join('\\n');\n  await fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\n  return `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Later, in any agent execution:\nimport { saveSheetAsCsv } from './skills/save-sheet-as-csv';\nconst csvPath = await saveSheetAsCsv('abc123');\n```\n\nThis ties in closely to the concept of Skills , folders of reusable instructions, scripts, and resources for models to improve performance on specialized tasks. Adding a SKILL.md file to these saved functions creates a structured skill that models can reference and use. Over time, this allows your agent to build a toolbox of higher-level capabilities, evolving the scaffolding that it needs to work most effectively.\n\nNote that code execution introduces its own complexity. Running agent-generated code requires a secure execution environment with appropriate sandboxing , resource limits, and monitoring. These infrastructure requirements add operational overhead and security considerations that direct tool calls avoid. The benefits of code execution-reduced token costs, lower latency, and improved tool composition-should be weighed against these implementation costs.\n\nSummary\n\nMCP provides a foundational protocol for agents to connect to many tools and systems. However, once too many servers are connected, tool definitions and results can consume excessive tokens, reducing agent efficiency.\n\nAlthough many of the problems here feel novel-context management, tool composition, state persistence-they have known solutions from software engineering. Code execution applies these established patterns to agents, letting them use familiar programming constructs to interact with MCP servers more efficiently. If you implement this approach, we encourage you to share your findings with the MCP community .\n\nAcknowledgments\n\nThis article was written by Adam Jones and Conor Kelly. Thanks to Jeremy Fox, Jerome Swannack, Stuart Ritchie, Molly Vorwerck, Matt Samuels, and Maggie Vo for feedback on drafts of this post.",
    "images": [
      "https://www-cdn.anthropic.com/images/4zrzovbb/website/42f40f6fae9ec2d7cf2e5a98908a16d0216b91be-1000x1000.svg",
      "https://www-cdn.anthropic.com/images/4zrzovbb/website/9ecf165020005c09a22a9472cee6309555485619-1920x1080.png"
    ]
  },
  "translations": {
    "es": {
      "title": "Ejecución de código con MCP: creación de agentes más eficientes",
      "content": "El Model Context Protocol (MCP) es un estándar abierto para conectar agentes de IA a sistemas externos.Conectar agentes a herramientas y datos tradicionalmente requiere una integración personalizada para cada emparejamiento, lo que genera fragmentación y esfuerzos duplicados que dificultan la ampliación de sistemas verdaderamente conectados.MCP proporciona un protocolo universal: los desarrolladores implementan MCP una vez en su agente y desbloquea un ecosistema completo de integraciones.\n\nDesde el lanzamiento de MCP en noviembre de 2024, la adopción ha sido rápida: la comunidad ha creado miles de servidores MCP, hay SDK disponibles para todos los principales lenguajes de programación y la industria ha adoptado MCP como el estándar de facto para conectar agentes a herramientas y datos.\n\nHoy en día, los desarrolladores crean rutinariamente agentes con acceso a cientos o miles de herramientas en docenas de servidores MCP.Sin embargo, a medida que crece el número de herramientas conectadas, cargar todas las definiciones de herramientas por adelantado y pasar resultados intermedios a través de la ventana contextual ralentiza a los agentes y aumenta los costos.\n\nEn este blog exploraremos cómo la ejecución de código puede permitir que los agentes interactúen con los servidores MCP de manera más eficiente, manejando más herramientas y usando menos tokens.\n\nEl consumo excesivo de tokens de las herramientas hace que los agentes sean menos eficientes\n\nA medida que aumenta el uso de MCP, existen dos patrones comunes que pueden aumentar el costo y la latencia del agente:\n\n- Las definiciones de herramientas sobrecargan la ventana contextual;\n\n- Los resultados de la herramienta intermedia consumen tokens adicionales.\n\n1. Las definiciones de herramientas sobrecargan la ventana contextual\n\nLa mayoría de los clientes MCP cargan todas las definiciones de herramientas por adelantado directamente en el contexto, exponiéndolas al modelo mediante una sintaxis de llamada directa a herramientas.Estas definiciones de herramientas podrían verse así:\n\n```\ngdrive.getDocumento\nDescripción: Recupera un documento de Google Drive\nParámetros:\ndocumentId (obligatorio, cadena): el ID del documento a recuperar\ncampos (opcional, cadena): campos específicos para devolver\nDevuelve: Objeto de documento con título, contenido del cuerpo, metadatos, permisos, etc.\n```\n\n```\nsalesforce.updateRecord\nDescripción: Actualiza un registro en Salesforce\nParámetros:\nobjectType (obligatorio, cadena): tipo de objeto de Salesforce (cliente potencial, contacto, cuenta, etc.)\nrecordId (obligatorio, cadena): el ID del registro a actualizar\ndatos (obligatorio, objeto): Campos para actualizar con sus nuevos valores\nDevoluciones: objeto de registro actualizado con confirmación\n```\n\nLas descripciones de las herramientas ocupan más espacio en la ventana contextual, lo que aumenta el tiempo de respuesta y los costos.En los casos en que los agentes estén conectados a miles de herramientas, necesitarán procesar cientos de miles de tokens antes de leer una solicitud.\n\n2. Los resultados de la herramienta intermedia consumen tokens adicionales\n\nLa mayoría de los clientes MCP permiten que los modelos llamen directamente a las herramientas MCP.Por ejemplo, podría preguntarle a su agente: \"Descargue la transcripción de mi reunión desde Google Drive y adjúntela al cliente potencial de Salesforce\".\n\nEl modelo hará llamadas como:\n\n```\nLLAMADA DE HERRAMIENTA: gdrive.getDocument(documentId: \"abc123\")\n→ devuelve \"Se discutieron los objetivos del cuarto trimestre...\\n[texto de la transcripción completa]\"\n(cargado en el contexto del modelo)\n\nLLAMADA DE HERRAMIENTA: salesforce.updateRecord(\ntipo de objeto: \"Reunión de ventas\",\nID de registro: \"00Q5f000001abcXYZ\",\ndata: { \"Notas\": \"Se discutieron los objetivos del cuarto trimestre...\\n[texto de la transcripción completa escrito]\" }\n)\n(El modelo necesita volver a escribir la transcripción completa en contexto)\n```\n\nCada resultado intermedio debe pasar por el modelo.En este ejemplo, la transcripción completa de la llamada se transmite dos veces.Para una reunión de ventas de 2 horas, eso podría significar procesar 50.000 tokens adicionales.Incluso los documentos más grandes pueden exceder los límites de la ventana contextual, interrumpiendo el flujo de trabajo.\n\nCon documentos grandes o estructuras de datos complejas, es más probable que los modelos cometan errores al copiar datos entre llamadas a herramientas.\n\n[[IMAGE_1|El cliente MCP carga definiciones de herramientas en la ventana contextual del modelo y organiza un bucle de mensajes donde cada llamada de herramienta y resultado pasa a través del modelo entre operaciones.]]\n\nLa ejecución de código con MCP mejora la eficiencia del contexto\n\nDado que los entornos de ejecución de código se vuelven más comunes para los agentes, una solución es presentar los servidores MCP como API de código en lugar de llamadas directas a herramientas.Luego, el agente puede escribir código para interactuar con los servidores MCP.Este enfoque aborda ambos desafíos: los agentes pueden cargar solo las herramientas que necesitan y procesar datos en el entorno de ejecución antes de devolver los resultados al modelo. Hay varias formas de hacer esto.Un enfoque es generar un árbol de archivos de todas las herramientas disponibles desde los servidores MCP conectados.Aquí hay una implementación usando TypeScript:\n\n```\nservidores\n├── google-drive\n│ ├── getDocument.ts\n│ ├── ... (otras herramientas)\n│ └── index.ts\n├── fuerza de ventas\n│ ├── actualizarRecord.ts\n│ ├── ... (otras herramientas)\n│ └── index.ts\n└──... (otros servidores)\n```\n\nEntonces cada herramienta corresponde a un archivo, algo así como:\n\n```\n// ./servers/google-drive/getDocument.ts\nimportar { callMCPTool } desde \"../../../client.js\";\n\ninterfaz GetDocumentInput {\nID de documento: cadena;\n}\n\ninterfaz GetDocumentResponse {\ncontenido: cadena;\n}\n\n/* Leer un documento de Google Drive */\nexportar función asíncrona getDocument(entrada: GetDocumentInput): Promesa<GetDocumentResponse> {\ndevolver callMCPTool<GetDocumentResponse>('google_drive__get_document', entrada);\n}\n```\n\nNuestro ejemplo anterior de Google Drive a Salesforce se convierte en el código:\n\n```\n// Leer la transcripción de Google Docs y agregarla al prospecto de Salesforce\nimportar * como gdrive desde './servers/google-drive';\nimportar * como Salesforce desde './servers/salesforce';\n\nconst transcript = (await gdrive.getDocument({ documentId: 'abc123' })).content;\nespere salesforce.updateRecord({\ntipo de objeto: 'Reunión de ventas',\nID de registro: '00Q5f000001abcXYZ',\ndatos: { Notas: transcripción }\n});\n```\n\nEl agente descubre herramientas explorando el sistema de archivos: enumera el directorio ./servers/ para encontrar servidores disponibles (como google-drive y salesforce) y luego lee los archivos de herramientas específicos que necesita (como getDocument.ts y updateRecord.ts) para comprender la interfaz de cada herramienta.Esto permite que el agente cargue solo las definiciones que necesita para la tarea actual.Esto reduce el uso de tokens de 150.000 tokens a 2.000 tokens, un ahorro de tiempo y costos del 98,7%.\n\nCloudflare publicó hallazgos similares, refiriéndose a la ejecución de código con MCP como \"Modo de código\".La idea central es la misma: los LLM son expertos en escribir código y los desarrolladores deberían aprovechar esta fortaleza para crear agentes que interactúen con los servidores MCP de manera más eficiente.\n\nBeneficios de la ejecución de código con MCP\n\nLa ejecución de código con MCP permite a los agentes utilizar el contexto de manera más eficiente al cargar herramientas bajo demanda, filtrar datos antes de que lleguen al modelo y ejecutar lógica compleja en un solo paso.También existen beneficios de seguridad y gestión del estado al utilizar este enfoque.\n\nDivulgación progresiva\n\nLos modelos son excelentes para navegar por sistemas de archivos.Presentar herramientas como código en un sistema de archivos permite a los modelos leer definiciones de herramientas bajo demanda, en lugar de leerlas todas por adelantado.\n\nAlternativamente, se puede agregar una herramienta search_tools al servidor para encontrar definiciones relevantes.Por ejemplo, cuando se trabaja con el servidor hipotético de Salesforce utilizado anteriormente, el agente busca \"salesforce\" y carga solo aquellas herramientas que necesita para la tarea actual.Incluir un parámetro de nivel de detalle en la herramienta search_tools que permita al agente seleccionar el nivel de detalle requerido (como solo nombre, nombre y descripción, o la definición completa con esquemas) también ayuda al agente a conservar el contexto y encontrar herramientas de manera eficiente.\n\nResultados de herramientas contextualmente eficientes\n\nCuando trabajan con grandes conjuntos de datos, los agentes pueden filtrar y transformar los resultados en código antes de devolverlos.Considere buscar una hoja de cálculo de 10.000 filas:\n\n```\n// Sin ejecución de código: todas las filas fluyen a través del contexto\nLLAMADA DE HERRAMIENTA: gdrive.getSheet(sheetId: 'abc123')\n→ devuelve 10.000 filas en contexto para filtrar manualmente\n\n// Con ejecución de código - filtrar en el entorno de ejecución\nconst allRows = await gdrive.getSheet({ hojaId: 'abc123' });\nconst pedidos pendientes = todas las filas.filtro (fila =>\nfila[\"Estado\"] === 'pendiente'\n);\nconsole.log(`Se encontraron ${pendingOrders.length} pedidos pendientes`);\nconsole.log(pendingOrders.slice(0, 5));// Registra solo los primeros 5 para revisión\n```\n\nEl agente ve cinco filas en lugar de 10.000.Patrones similares funcionan para agregaciones, uniones entre múltiples fuentes de datos o extracción de campos específicos, todo sin inflar la ventana contextual.\n\nFlujo de control más potente y contextualmente eficiente\n\nLos bucles, los condicionales y el manejo de errores se pueden realizar con patrones de código familiares en lugar de encadenar llamadas a herramientas individuales.Por ejemplo, si necesita una notificación de implementación en Slack, el agente puede escribir: ```\ndejar encontrado = falso;\nmientras (! encontrado) {\nmensajes constantes = await slack.getChannelHistory({ canal: 'C123456' });\nencontrado = mensajes.algunos(m => m.text.includes('implementación completa'));\nif (!found) espera nueva Promesa(r => setTimeout(r, 5000));\n}\nconsole.log('Notificación de implementación recibida');\n```\n\nEste enfoque es más eficiente que alternar entre llamadas a herramientas MCP y comandos de suspensión a través del bucle del agente.\n\nAdemás, poder escribir un árbol condicional que se ejecuta también ahorra latencia de \"tiempo hasta el primer token\": en lugar de tener que esperar a que un modelo evalúe una declaración if, el agente puede dejar que el entorno de ejecución de código haga esto.\n\nOperaciones que preservan la privacidad\n\nCuando los agentes utilizan la ejecución de código con MCP, los resultados intermedios permanecen en el entorno de ejecución de forma predeterminada.De esta manera, el agente solo ve lo que usted registra o devuelve explícitamente, lo que significa que los datos que no desea compartir con el modelo pueden fluir a través de su flujo de trabajo sin siquiera ingresar al contexto del modelo.\n\nPara cargas de trabajo aún más confidenciales, el arnés del agente puede tokenizar datos confidenciales automáticamente.Por ejemplo, imagine que necesita importar datos de contacto de un cliente desde una hoja de cálculo a Salesforce.El agente escribe:\n\n```\nhoja const = espera gdrive.getSheet({ hojaId: 'abc123' });\npara (fila constante de hoja.filas) {\nespere salesforce.updateRecord({\ntipo de objeto: 'plomo',\nrecordId: fila.salesforceId,\ndatos: {\nCorreo electrónico: fila.correo electrónico,\nTeléfono: fila.teléfono,\nNombre: fila.nombre\n}\n});\n}\nconsole.log(`Clientes potenciales ${sheet.rows.length} actualizados`);\n```\n\nEl cliente MCP intercepta los datos y tokeniza la PII antes de que llegue al modelo:\n\n```\n// Lo que vería el agente si registrara la hoja.filas:\n[\n{ salesforceId: '00Q...', correo electrónico: '[EMAIL_1]', teléfono: '[PHONE_1]', nombre: '[NAME_1]' },\n{ salesforceId: '00Q...', correo electrónico: '[EMAIL_2]', teléfono: '[PHONE_2]', nombre: '[NAME_2]' },\n...\n]\n```\n\nLuego, cuando los datos se comparten en otra llamada a la herramienta MCP, se destokenizan mediante una búsqueda en el cliente MCP.Las direcciones de correo electrónico, números de teléfono y nombres reales fluyen desde Google Sheets a Salesforce, pero nunca a través del modelo.Esto evita que el agente registre o procese datos confidenciales accidentalmente.También puede utilizar esto para definir reglas de seguridad deterministas, eligiendo hacia dónde y desde dónde pueden fluir los datos.\n\nEstado de persistencia y habilidades.\n\nLa ejecución de código con acceso al sistema de archivos permite a los agentes mantener el estado en todas las operaciones.Los agentes pueden escribir resultados intermedios en archivos, lo que les permite reanudar el trabajo y realizar un seguimiento del progreso:\n\n```\nclientes potenciales constantes = esperar salesforce.query({\nconsulta: 'SELECCIONAR ID, correo electrónico DESDE LÍMITE de cliente potencial 1000'\n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nespere fs.writeFile('./workspace/leads.csv', csvData);\n\n// La ejecución posterior continúa donde lo dejó\nconst guardado = await fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nLos agentes también pueden conservar su propio código como funciones reutilizables.Una vez que un agente desarrolla un código de trabajo para una tarea, puede guardar esa implementación para uso futuro:\n\n```\n// En ./skills/save-sheet-as-csv.ts\nimportar * como gdrive desde './servers/google-drive';\nexportar función asíncrona saveSheetAsCsv (sheetId: cadena) {\ndatos constantes = esperar gdrive.getSheet({sheetId});\nconst csv = data.map(fila => fila.join(',')).join('\\n');\nespere fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\nreturn `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Posteriormente, en cualquier ejecución de agente:\nimportar { saveSheetAsCsv } desde './skills/save-sheet-as-csv';\nconst csvPath = espera saveSheetAsCsv('abc123');\n```\n\nEsto está estrechamente relacionado con el concepto de Habilidades, carpetas de instrucciones, scripts y recursos reutilizables para que los modelos mejoren el desempeño en tareas especializadas.Agregar un archivo SKILL.md a estas funciones guardadas crea una habilidad estructurada a la que los modelos pueden hacer referencia y usar.Con el tiempo, esto le permite a su agente crear una caja de herramientas con capacidades de nivel superior, evolucionando el andamiaje que necesita para funcionar de manera más efectiva.\n\nTenga en cuenta que la ejecución del código introduce su propia complejidad.La ejecución de código generado por agentes requiere un entorno de ejecución seguro con espacio aislado, límites de recursos y supervisión adecuados.Estos requisitos de infraestructura añaden gastos operativos y consideraciones de seguridad que las llamadas directas a herramientas evitan.Los beneficios de la ejecución de código (costos de token reducidos, menor latencia y composición mejorada de herramientas) deben sopesarse con estos costos de implementación.\n\nResumen MCP proporciona un protocolo fundamental para que los agentes se conecten a muchas herramientas y sistemas.Sin embargo, una vez que se conectan demasiados servidores, las definiciones y resultados de las herramientas pueden consumir tokens excesivos, lo que reduce la eficiencia del agente.\n\nAunque muchos de los problemas aquí parecen novedosos (gestión del contexto, composición de herramientas, persistencia del estado), tienen soluciones conocidas de la ingeniería de software.La ejecución de código aplica estos patrones establecidos a los agentes, permitiéndoles utilizar construcciones de programación familiares para interactuar con los servidores MCP de manera más eficiente.Si implementa este enfoque, lo alentamos a compartir sus hallazgos con la comunidad de MCP.\n\nAgradecimientos\n\nEste artículo fue escrito por Adam Jones y Conor Kelly.Gracias a Jeremy Fox, Jerome Swannack, Stuart Ritchie, Molly Vorwerck, Matt Samuels y Maggie Vo por sus comentarios sobre los borradores de esta publicación.",
      "edited": false
    },
    "ukr": {
      "title": "Виконання коду за допомогою MCP: створення більш ефективних агентів",
      "content": "Model Context Protocol (MCP) — це відкритий стандарт для підключення агентів AI до зовнішніх систем.Підключення агентів до інструментів і даних традиційно вимагає спеціальної інтеграції для кожної пари, створюючи фрагментацію та дублюючі зусилля, що ускладнює масштабування справді підключених систем.MCP надає універсальний протокол — розробники впроваджують MCP один раз у своїх агентах, і це відкриває цілу екосистему інтеграцій.\n\nЗ моменту запуску MCP у листопаді 2024 року впровадження було швидким: спільнота створила тисячі серверів MCP, SDK доступні для всіх основних мов програмування, а галузь прийняла MCP як фактичний стандарт для підключення агентів до інструментів і даних.\n\nСьогодні розробники регулярно створюють агенти з доступом до сотень або тисяч інструментів на десятках серверів MCP.Однак, оскільки кількість підключених інструментів зростає, завантаження всіх визначень інструментів наперед і передача проміжних результатів через контекстне вікно сповільнюють роботу агентів і збільшують витрати.\n\nУ цьому блозі ми дослідимо, як виконання коду може дозволити агентам ефективніше взаємодіяти з серверами MCP, обробляючи більше інструментів і використовуючи менше маркерів.\n\nНадмірне споживання маркерів інструментами робить агентів менш ефективними\n\nУ зв’язку з масштабами використання MCP існують дві загальні моделі, які можуть збільшити вартість агента та затримку:\n\n- Визначення інструментів перевантажують контекстне вікно;\n\n- Проміжні результати інструменту споживають додаткові жетони.\n\n1. Визначення інструментів перевантажують контекстне вікно\n\nБільшість клієнтів MCP завантажують усі визначення інструментів безпосередньо в контекст, відкриваючи їх для моделі за допомогою синтаксису прямого виклику інструментів.Ці визначення інструментів можуть виглядати так:\n\n```\ngdrive.getDocument\nОпис: отримує документ із Google Drive\nПараметри:\ndocumentId (обов’язково, рядок): ідентифікатор документа, який потрібно отримати\nполя (необов’язкові, рядок): певні поля для повернення\nПовертає: об’єкт документа із заголовком, основним вмістом, метаданими, дозволами тощо.\n```\n\n```\nsalesforce.updateRecord\nОпис: оновлює запис у Salesforce\nПараметри:\nobjectType (обов’язково, рядок): Тип об’єкта Salesforce (Lead, Contact, Account тощо)\nrecordId (обов’язково, рядок): ідентифікатор запису для оновлення\nдані (обов’язково, об’єкт): поля для оновлення з новими значеннями\nПовертає: оновлений об’єкт запису з підтвердженням\n```\n\nОписи інструментів займають більше контекстного вікна, збільшуючи час відповіді та витрати.У випадках, коли агенти підключені до тисяч інструментів, їм потрібно буде обробити сотні тисяч токенів, перш ніж прочитати запит.\n\n2. Проміжні результати інструменту споживають додаткові токени\n\nБільшість клієнтів MCP дозволяють моделям безпосередньо викликати інструменти MCP.Наприклад, ви можете попросити свого агента: «Завантажте стенограму моєї зустрічі з Диска Google і прикріпіть її до потенційного клієнта Salesforce».\n\nМодель здійснюватиме такі дзвінки:\n\n```\nВИКЛИК ІНСТРУМЕНТУ: gdrive.getDocument(documentId: \"abc123\")\n→ повертає \"Обговорювані цілі Q4...\\n[повний текст стенограми]\"\n(завантажується в контекст моделі)\n\nВИКЛИК ІНСТРУМЕНТА: salesforce.updateRecord(\nobjectType: \"SalesMeeting\",\nrecordId: \"00Q5f000001abcXYZ\",\ndata: { \"Примітки\": \"Обговорювані цілі Q4...\\n[виписаний повний текст стенограми]\" }\n)\n(моделі потрібно знову записати всю транскрипцію в контекст)\n```\n\nКожен проміжний результат повинен пройти через модель.У цьому прикладі повна стенограма виклику проходить двічі.Для 2-годинної зустрічі з продажу це може означати обробку додаткових 50 000 токенів.Навіть більші документи можуть перевищувати межі вікон контексту, порушуючи робочий процес.\n\nЗ великими документами або складними структурами даних моделі можуть частіше робити помилки під час копіювання даних між викликами інструментів.\n\n[[IMAGE_1|Клієнт MCP завантажує визначення інструментів у контекстне вікно моделі та організовує цикл повідомлень, у якому кожен виклик інструмента та результат проходять через модель між операціями.]]\n\nВиконання коду за допомогою MCP покращує ефективність контексту\n\nОскільки середовища виконання коду стають все більш поширеними для агентів, рішенням є представлення серверів MCP як кодових API, а не прямих викликів інструментів.Потім агент може написати код для взаємодії з серверами MCP.Цей підхід вирішує обидві проблеми: агенти можуть завантажувати лише ті інструменти, які їм потрібні, і обробляти дані в середовищі виконання, перш ніж передати результати назад у модель. Для цього існує кілька способів.Одним із підходів є створення дерева файлів усіх доступних інструментів із підключених серверів MCP.Ось реалізація з використанням TypeScript:\n\n```\nсерверів\n├── гугл-диск\n│ ├── getDocument.ts\n│ ├── ... (інші інструменти)\n│ └── індекс.ц\n├── відділ продажів\n│ ├── updateRecord.ts\n│ ├── ... (інші інструменти)\n│ └── індекс.ц\n└── ... (інші сервери)\n```\n\nТоді кожен інструмент відповідає файлу, приблизно так:\n\n```\n// ./servers/google-drive/getDocument.ts\nімпорт { callMCPTool } із \"../../../client.js\";\n\nінтерфейс GetDocumentInput {\ndocumentId: рядок;\n}\n\nінтерфейс GetDocumentResponse {\nвміст: рядок;\n}\n\n/* Читання документа з Google Drive */\nекспорт асинхронної функції getDocument(вхід: GetDocumentInput): Promise<GetDocumentResponse> {\nreturn callMCPTool<GetDocumentResponse>('google_drive__get_document', введення);\n}\n```\n\nНаш приклад Google Drive to Salesforce, наведений вище, стає кодом:\n\n```\n// Читання стенограми з Документів Google і додавання до перспективи Salesforce\nімпорт * як gdrive з './servers/google-drive';\nімпорт * як salesforce з './servers/salesforce';\n\nconst transcript = (очікуйте gdrive.getDocument({ documentId: 'abc123' })).content;\nawait salesforce.updateRecord({\nobjectType: 'SalesMeeting',\nrecordId: '00Q5f000001abcXYZ',\nдані: {Примітки: розшифровка}\n});\n```\n\nАгент знаходить інструменти, досліджуючи файлову систему: перераховуючи каталог ./servers/, щоб знайти доступні сервери (наприклад, google-drive і salesforce), а потім читаючи файли конкретних інструментів, які йому потрібні (наприклад, getDocument.ts і updateRecord.ts), щоб зрозуміти інтерфейс кожного інструменту.Це дозволяє агенту завантажувати лише визначення, необхідні для поточного завдання.Це зменшує використання токенів зі 150 000 до 2 000 токенів — економія часу та витрат становить 98,7%.\n\nCloudflare опублікував подібні висновки, називаючи виконання коду за допомогою MCP «режимом коду».Основне розуміння те ж саме: магістратури вміють писати код, і розробники повинні скористатися цією перевагою для створення агентів, які ефективніше взаємодіють із серверами MCP.\n\nПереваги виконання коду за допомогою MCP\n\nВиконання коду за допомогою MCP дозволяє агентам ефективніше використовувати контекст шляхом завантаження інструментів на вимогу, фільтрації даних до того, як вони потраплять до моделі, і виконання складної логіки за один крок.Використання цього підходу також має переваги для безпеки та управління станом.\n\nПрогресивне розкриття\n\nМоделі чудово підходять для навігації файловими системами.Представлення інструментів у вигляді коду у файловій системі дозволяє моделям читати визначення інструментів на вимогу, а не читати їх усі заздалегідь.\n\nКрім того, на сервер можна додати інструмент search_tools для пошуку відповідних визначень.Наприклад, під час роботи з гіпотетичним сервером Salesforce, використаним вище, агент шукає \"salesforce\" і завантажує лише ті інструменти, які йому потрібні для поточного завдання.Включення параметра рівня деталізації в інструмент search_tools, який дозволяє агенту вибирати необхідний рівень деталізації (наприклад, лише ім’я, ім’я та опис або повне визначення зі схемами), також допомагає агенту зберегти контекст і ефективно знаходити інструменти.\n\nКонтекстно ефективний інструмент результати\n\nПрацюючи з великими наборами даних, агенти можуть фільтрувати та перетворювати результати в код, перш ніж повертати їх.Спробуйте отримати електронну таблицю на 10 000 рядків:\n\n```\n// Без виконання коду - усі рядки проходять через контекст\nВИКЛИК ІНСТРУМЕНТУ: gdrive.getSheet(sheetId: 'abc123')\n→ повертає 10 000 рядків у контексті для ручного фільтрування\n\n// З виконанням коду - фільтр у середовищі виконання\nconst allRows = await gdrive.getSheet({ sheetId: 'abc123' });\nconst pendingOrders = allRows.filter(row =>\nrow[\"Status\"] === 'очікує на розгляд'\n);\nconsole.log(`Знайдено ${pendingOrders.length} відкладених ордерів`);\nconsole.log(pendingOrders.slice(0, 5));// Зареєструйте лише перші 5 для перегляду\n```\n\nАгент бачить п'ять рядків замість 10 000.Подібні шаблони працюють для агрегацій, об’єднань у кількох джерелах даних або вилучення певних полів – і все це без роздування вікна контексту.\n\nБільш потужний і контекстно-ефективний потік керування\n\nЦикли, умови й обробку помилок можна виконати за допомогою знайомих шаблонів коду, а не згрупувати окремі виклики інструментів.Наприклад, якщо вам потрібно сповіщення про розгортання в Slack, агент може написати: ```\nlet found = false;\nwhile (!знайдено) {\nconst messages = await slack.getChannelHistory({ канал: 'C123456' });\nзнайдено = messages.some(m => m.text.includes('розгортання завершено'));\nif (!found) await new Promise(r => setTimeout(r, 5000));\n}\nconsole.log('Отримано сповіщення про розгортання');\n```\n\nЦей підхід більш ефективний, ніж чергування між викликами інструментів MCP і командами сну через цикл агента.\n\nКрім того, можливість написати умовне дерево, яке виконується, також економить затримку «часу до першого маркера»: замість того, щоб чекати, поки модель оцінить інструкцію if, агент може дозволити середовищу виконання коду зробити це.\n\nОперації збереження конфіденційності\n\nКоли агенти використовують виконання коду з MCP, проміжні результати за замовчуванням залишаються в середовищі виконання.Таким чином, агент бачить лише те, що ви явно реєструєте або повертаєте, тобто дані, якими ви не бажаєте ділитися з моделлю, можуть проходити через ваш робочий процес без входження в контекст моделі.\n\nДля ще більш конфіденційних робочих навантажень джгут агентів може автоматично токенізувати конфіденційні дані.Наприклад, уявіть, що вам потрібно імпортувати контактні дані клієнта з електронної таблиці в Salesforce.Агент пише:\n\n```\nconst sheet = await gdrive.getSheet({ sheetId: 'abc123' });\nfor (const row of sheet.rows) {\nawait salesforce.updateRecord({\nobjectType: 'Lead',\nrecordId: row.salesforceId,\nдані: {\nЕлектронна пошта: row.email,\nТелефон: row.phone,\nНазва: row.name\n}\n});\n}\nconsole.log(`Оновлені потенційні клієнти ${sheet.rows.length}`);\n```\n\nКлієнт MCP перехоплює дані та токенізує ідентифікаційну інформацію, перш ніж вона досягне моделі:\n\n```\n// Що побачить агент, якщо він зареєструє sheet.rows:\n[\n{ salesforceId: '00Q...', електронна адреса: '[EMAIL_1]', телефон: '[PHONE_1]', ім'я: '[NAME_1]' },\n{ salesforceId: '00Q...', електронна адреса: '[EMAIL_2]', телефон: '[PHONE_2]', ім'я: '[NAME_2]' },\n...\n]\n```\n\nПотім, коли дані передаються під час іншого виклику інструменту MCP, вони скасовуються через пошук у клієнті MCP.Справжні електронні адреси, номери телефонів та імена надходять із Google Таблиць до Salesforce, але не через модель.Це запобігає випадковому реєстрації чи обробці конфіденційних даних агентом.Ви також можете використовувати це для визначення детермінованих правил безпеки, вибираючи, куди і звідки можуть надходити дані.\n\nДержавна наполегливість і вміння\n\nВиконання коду з доступом до файлової системи дозволяє агентам підтримувати стан між операціями.Агенти можуть записувати проміжні результати у файли, що дозволяє їм відновити роботу та відстежувати прогрес:\n\n```\nconst leads = await salesforce.query({\nзапит: \"SELECT Id, Email FROM Lead LIMIT 1000\"\n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nawait fs.writeFile('./workspace/leads.csv', csvData);\n\n// Пізніше виконання продовжується з того місця, де воно зупинилося\nconst saved = await fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nАгенти також можуть зберігати свій власний код як функції для повторного використання.Коли агент розробляє робочий код для завдання, він може зберегти цю реалізацію для майбутнього використання:\n\n```\n// У ./skills/save-sheet-as-csv.ts\nімпорт * як gdrive з './servers/google-drive';\nекспорт асинхронної функції saveSheetAsCsv(sheetId: рядок) {\nconst data = await gdrive.getSheet({sheetId});\nconst csv = data.map(row => row.join(',')).join('\\n');\nawait fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\nreturn `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Пізніше, у будь-якому виконанні агента:\nімпорт { saveSheetAsCsv } із './skills/save-sheet-as-csv';\nconst csvPath = очікувати saveSheetAsCsv('abc123');\n```\n\nЦе тісно пов’язане з концепцією навичок, папок багаторазових інструкцій, сценаріїв і ресурсів для моделей для підвищення ефективності виконання спеціалізованих завдань.Додавання файлу SKILL.md до цих збережених функцій створює структурований навик, на який моделі можуть посилатися та використовувати.Згодом це дозволить вашому агенту створити набір інструментів із можливостями вищого рівня, розвиваючи каркас, необхідний для найбільш ефективної роботи.\n\nЗауважте, що виконання коду вносить власну складність.Для запуску створеного агентом коду потрібне безпечне середовище виконання з відповідним ізольованим програмним середовищем, обмеженнями ресурсів і моніторингом.Ці вимоги до інфраструктури додають додаткові робочі витрати та міркування щодо безпеки, яких уникають прямі виклики інструментів.Переваги виконання коду — зменшення витрат на токени, меншу затримку та покращену композицію інструментів — слід порівняти з цими витратами на впровадження.\n\nРезюме MCP надає базовий протокол для підключення агентів до багатьох інструментів і систем.Однак, як тільки підключено занадто багато серверів, визначення інструментів і результати можуть споживати надмірну кількість маркерів, що знижує ефективність агента.\n\nХоча багато проблем тут здаються новими — керування контекстом, композиція інструментів, збереження стану — вони мають відомі рішення з інженерії програмного забезпечення.Виконання коду застосовує ці встановлені шаблони до агентів, дозволяючи їм використовувати знайомі конструкції програмування для більш ефективної взаємодії з серверами MCP.Якщо ви застосовуєте цей підхід, ми радимо вам поділитися своїми висновками зі спільнотою MCP.\n\nПодяки\n\nЦю статтю написали Адам Джонс і Конор Келлі.Дякуємо Джеремі Фоксу, Джерому Суоннеку, Стюарту Річі, Моллі Форверк, Метту Семюелсу та Меггі Во за відгуки про чернетки цієї публікації.",
      "edited": false
    },
    "pt": {
      "title": "Execução de código com MCP: Construindo agentes mais eficientes",
      "content": "O Model Context Protocol (MCP) é um padrão aberto para conectar agentes de IA a sistemas externos.Conectar agentes a ferramentas e dados tradicionalmente requer uma integração personalizada para cada emparelhamento, criando fragmentação e esforço duplicado que dificulta o dimensionamento de sistemas verdadeiramente conectados.O MCP fornece um protocolo universal: os desenvolvedores implementam o MCP uma vez em seu agente e isso desbloqueia todo um ecossistema de integrações.\n\nDesde o lançamento do MCP em novembro de 2024, a adoção tem sido rápida: a comunidade construiu milhares de servidores MCP, os SDKs estão disponíveis para todas as principais linguagens de programação e a indústria adotou o MCP como o padrão de fato para conectar agentes a ferramentas e dados.\n\nHoje, os desenvolvedores criam rotineiramente agentes com acesso a centenas ou milhares de ferramentas em dezenas de servidores MCP.No entanto, à medida que o número de ferramentas conectadas cresce, carregar todas as definições de ferramentas antecipadamente e passar resultados intermediários pela janela de contexto desacelera os agentes e aumenta os custos.\n\nNeste blog exploraremos como a execução de código pode permitir que os agentes interajam com servidores MCP de forma mais eficiente, lidando com mais ferramentas e usando menos tokens.\n\nO consumo excessivo de tokens das ferramentas torna os agentes menos eficientes\n\nÀ medida que o uso do MCP aumenta, há dois padrões comuns que podem aumentar o custo e a latência do agente:\n\n- As definições de ferramentas sobrecarregam a janela de contexto;\n\n- Os resultados da ferramenta intermediária consomem tokens adicionais.\n\n1. As definições de ferramentas sobrecarregam a janela de contexto\n\nA maioria dos clientes MCP carrega antecipadamente todas as definições de ferramentas diretamente no contexto, expondo-as ao modelo usando uma sintaxe de chamada direta de ferramentas.Essas definições de ferramentas podem ser semelhantes a:\n\n```\ngdrive.getDocument\nDescrição: Recupera um documento do Google Drive\nParâmetros:\ndocumentId (obrigatório, string): o ID do documento a ser recuperado\ncampos (opcional, string): campos específicos para retornar\nRetorna: Objeto de documento com título, conteúdo do corpo, metadados, permissões, etc.\n```\n\n```\nsalesforce.updateRecord\nDescrição: Atualiza um registro no Salesforce\nParâmetros:\nobjectType (obrigatório, string): Tipo de objeto do Salesforce (Lead, Contato, Conta, etc.)\nrecordId (obrigatório, string): o ID do registro a ser atualizado\ndados (obrigatório, objeto): Campos a serem atualizados com seus novos valores\nRetorna: Objeto de registro atualizado com confirmação\n```\n\nAs descrições das ferramentas ocupam mais espaço na janela de contexto, aumentando o tempo de resposta e os custos.Nos casos em que os agentes estão conectados a milhares de ferramentas, eles precisarão processar centenas de milhares de tokens antes de ler uma solicitação.\n\n2. Os resultados intermediários da ferramenta consomem tokens adicionais\n\nA maioria dos clientes MCP permite que os modelos chamem diretamente as ferramentas MCP.Por exemplo, você pode perguntar ao seu agente: “Baixe a transcrição da minha reunião do Google Drive e anexe-a ao lead do Salesforce”.\n\nO modelo fará chamadas como:\n\n```\nCHAMADA DE FERRAMENTA: gdrive.getDocument(documentId: \"abc123\")\n→ retorna \"Metas discutidas no quarto trimestre...\\n[texto da transcrição completa]\"\n(carregado no contexto do modelo)\n\nCHAMADA DE FERRAMENTA: salesforce.updateRecord(\nobjectType: \"SalesMeeting\",\nrecordId: \"00Q5f000001abcXYZ\",\ndata: { \"Notas\": \"Metas discutidas no quarto trimestre...\\n[texto completo da transcrição escrito]\" }\n)\n(o modelo precisa escrever toda a transcrição no contexto novamente)\n```\n\nTodo resultado intermediário deve passar pelo modelo.Neste exemplo, a transcrição completa da chamada flui duas vezes.Para uma reunião de vendas de 2 horas, isso pode significar o processamento de 50.000 tokens adicionais.Documentos ainda maiores podem exceder os limites da janela de contexto, interrompendo o fluxo de trabalho.\n\nCom documentos grandes ou estruturas de dados complexas, os modelos podem ter maior probabilidade de cometer erros ao copiar dados entre chamadas de ferramentas.\n\n[[IMAGE_1|O cliente MCP carrega definições de ferramenta na janela de contexto do modelo e orquestra um loop de mensagens onde cada chamada de ferramenta e resultado passa pelo modelo entre as operações.]]\n\nA execução de código com MCP melhora a eficiência do contexto\n\nCom os ambientes de execução de código se tornando mais comuns para os agentes, uma solução é apresentar os servidores MCP como APIs de código, em vez de chamadas diretas de ferramentas.O agente pode então escrever código para interagir com os servidores MCP.Essa abordagem aborda ambos os desafios: os agentes podem carregar apenas as ferramentas necessárias e processar os dados no ambiente de execução antes de transmitir os resultados de volta ao modelo. Existem várias maneiras de fazer isso.Uma abordagem é gerar uma árvore de arquivos de todas as ferramentas disponíveis nos servidores MCP conectados.Aqui está uma implementação usando TypeScript:\n\n```\nservidores\n├── google-drive\n│ ├── getDocument.ts\n│ ├── ... (outras ferramentas)\n│ └── index.ts\n├── força de vendas\n│ ├── updateRecord.ts\n│ ├── ... (outras ferramentas)\n│ └── index.ts\n└── ... (outros servidores)\n```\n\nEntão cada ferramenta corresponde a um arquivo, algo como:\n\n```\n// ./servers/google-drive/getDocument.ts\nimportar { callMCPTool } de \"../../../client.js\";\n\ninterfaceGetDocumentInput {\ndocumentID: string;\n}\n\ninterfaceGetDocumentResponse{\nconteúdo: sequência;\n}\n\n/* Ler um documento do Google Drive */\nexportar função assíncrona getDocument(input: GetDocumentInput): Promise<GetDocumentResponse> {\nreturn callMCPTool<GetDocumentResponse>('google_drive__get_document', input);\n}\n```\n\nNosso exemplo do Google Drive para Salesforce acima se torna o código:\n\n```\n// Leia a transcrição do Google Docs e adicione ao cliente potencial do Salesforce\nimportar * como gdrive de './servers/google-drive';\nimportar * como força de vendas de './servers/salesforce';\n\ntranscrição const = (aguarde gdrive.getDocument({documentId: 'abc123' })).content;\naguardar salesforce.updateRecord({\nobjectType: 'SalesMeeting',\nID de registro: '00Q5f000001abcXYZ',\ndados: {Notas: transcrição}\n});\n```\n\nO agente descobre ferramentas explorando o sistema de arquivos: listando o diretório ./servers/ para encontrar servidores disponíveis (como google-drive e salesforce ) e, em seguida, lendo os arquivos de ferramentas específicos necessários (como getDocument.ts e updateRecord.ts ) para entender a interface de cada ferramenta.Isso permite que o agente carregue apenas as definições necessárias para a tarefa atual.Isso reduz o uso de tokens de 150.000 tokens para 2.000 tokens – uma economia de tempo e custos de 98,7%.\n\nA Cloudflare publicou descobertas semelhantes, referindo-se à execução de código com MCP como “Modo de Código”.O insight principal é o mesmo: os LLMs são adeptos da escrita de código e os desenvolvedores devem aproveitar essa vantagem para criar agentes que interajam com os servidores MCP de maneira mais eficiente.\n\nBenefícios da execução de código com MCP\n\nA execução de código com MCP permite que os agentes usem o contexto de forma mais eficiente, carregando ferramentas sob demanda, filtrando dados antes que cheguem ao modelo e executando lógica complexa em uma única etapa.Há também benefícios de segurança e gerenciamento de estado ao usar essa abordagem.\n\nDivulgação progressiva\n\nOs modelos são ótimos para navegar em sistemas de arquivos.Apresentar ferramentas como código em um sistema de arquivos permite que os modelos leiam as definições de ferramentas sob demanda, em vez de lê-las todas antecipadamente.\n\nAlternativamente, uma ferramenta search_tools pode ser adicionada ao servidor para encontrar definições relevantes.Por exemplo, ao trabalhar com o servidor Salesforce hipotético usado acima, o agente procura por \"força de vendas\" e carrega apenas as ferramentas necessárias para a tarefa atual.Incluir um parâmetro de nível de detalhe na ferramenta search_tools que permite ao agente selecionar o nível de detalhe necessário (como apenas nome, nome e descrição ou a definição completa com esquemas) também ajuda o agente a conservar o contexto e encontrar ferramentas com eficiência.\n\nResultados de ferramentas com eficiência de contexto\n\nAo trabalhar com grandes conjuntos de dados, os agentes podem filtrar e transformar os resultados em código antes de retorná-los.Considere buscar uma planilha de 10.000 linhas:\n\n```\n// Sem execução de código - todas as linhas fluem através do contexto\nCHAMADA DE FERRAMENTA: gdrive.getSheet(sheetId: 'abc123')\n→ retorna 10.000 linhas no contexto para filtrar manualmente\n\n// Com execução de código - filtro no ambiente de execução\nconst allRows = aguarda gdrive.getSheet({sheetId: 'abc123' });\nconst pendenteOrders = allRows.filter(linha =>\nlinha[\"Status\"] === 'pendente'\n);\nconsole.log(`Encontrados ${pendingOrders.length} pedidos pendentes`);\nconsole.log(pendingOrders.slice(0, 5));// Registra apenas os 5 primeiros para revisão\n```\n\nO agente vê cinco linhas em vez de 10.000.Padrões semelhantes funcionam para agregações, junções em diversas fontes de dados ou extração de campos específicos - tudo isso sem sobrecarregar a janela de contexto.\n\nFluxo de controle mais poderoso e eficiente em termos de contexto\n\nLoops, condicionais e tratamento de erros podem ser feitos com padrões de código familiares, em vez de encadear chamadas de ferramentas individuais.Por exemplo, se você precisar de uma notificação de implantação no Slack, o agente poderá escrever: ```\ndeixe encontrado = falso;\nenquanto (!encontrado) {\nmensagens const = aguarda slack.getChannelHistory({canal: 'C123456' });\nencontrado = mensagens.some(m => m.text.includes('implantação concluída'));\nif (!found) aguarda new Promise(r => setTimeout(r, 5000));\n}\nconsole.log('Notificação de implantação recebida');\n```\n\nEssa abordagem é mais eficiente do que alternar entre chamadas de ferramenta MCP e comandos de suspensão por meio do loop do agente.\n\nAlém disso, ser capaz de escrever uma árvore condicional que é executada também economiza na latência do \"tempo até o primeiro token\": em vez de ter que esperar que um modelo avalie uma instrução if, o agente pode deixar o ambiente de execução de código fazer isso.\n\nOperações de preservação de privacidade\n\nQuando os agentes usam a execução de código com o MCP, os resultados intermediários permanecem no ambiente de execução por padrão.Dessa forma, o agente só vê o que você registra ou retorna explicitamente, o que significa que os dados que você não deseja compartilhar com o modelo podem fluir pelo seu fluxo de trabalho sem nunca entrar no contexto do modelo.\n\nPara cargas de trabalho ainda mais confidenciais, o equipamento do agente pode tokenizar dados confidenciais automaticamente.Por exemplo, imagine que você precise importar detalhes de contato do cliente de uma planilha para o Salesforce.O agente escreve:\n\n```\nplanilha const = aguarda gdrive.getSheet({sheetId: 'abc123' });\nfor (const linha de planilha.rows) {\naguardar salesforce.updateRecord({\nobjectType: 'Lead',\nrecordId: linha.salesforceId,\ndados: {\nE-mail: linha.email,\nTelefone: row.phone,\nNome: linha.nome\n}\n});\n}\nconsole.log(`Leads ${sheet.rows.length} atualizados`);\n```\n\nO cliente MCP intercepta os dados e tokeniza PII antes que cheguem ao modelo:\n\n```\n// O que o agente veria se registrasse o sheet.rows:\n[\n{ salesforceId: '00Q...', email: '[EMAIL_1]', telefone: '[PHONE_1]', nome: '[NAME_1]' },\n{ salesforceId: '00Q...', email: '[EMAIL_2]', telefone: '[PHONE_2]', nome: '[NAME_2]' },\n...\n]\n```\n\nEntão, quando os dados são compartilhados em outra chamada de ferramenta MCP, eles não são tokenizados por meio de uma consulta no cliente MCP.Os endereços de e-mail, números de telefone e nomes reais fluem do Planilhas Google para o Salesforce, mas nunca através do modelo.Isso evita que o agente registre ou processe acidentalmente dados confidenciais.Você também pode usar isso para definir regras de segurança determinísticas, escolhendo para onde os dados podem fluir.\n\nPersistência e habilidades do estado\n\nA execução de código com acesso ao sistema de arquivos permite que os agentes mantenham o estado entre as operações.Os agentes podem gravar resultados intermediários em arquivos, permitindo-lhes retomar o trabalho e acompanhar o progresso:\n\n```\nconst leads = aguarda salesforce.query({\nconsulta: 'SELECT Id, Email FROM Lead LIMIT 1000'\n});\nconst csvData = leads.map(l => `${l.Id},${l.Email}`).join('\\n');\naguarde fs.writeFile('./workspace/leads.csv', csvData);\n\n// A execução posterior continua de onde parou\nconst salvo = aguarda fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nOs agentes também podem manter seu próprio código como funções reutilizáveis.Depois que um agente desenvolve um código funcional para uma tarefa, ele pode salvar essa implementação para uso futuro:\n\n```\n// Em ./skills/save-sheet-as-csv.ts\nimportar * como gdrive de './servers/google-drive';\nexportar função assíncrona saveSheetAsCsv(sheetId: string) {\ndados const = aguarda gdrive.getSheet({sheetId });\nconst csv = data.map(row => row.join(',')).join('\\n');\naguarde fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\nreturn `./workspace/sheet-${sheetId}.csv`;\n}\n\n// Posteriormente, em qualquer execução do agente:\nimportar { saveSheetAsCsv } de './skills/save-sheet-as-csv';\nconst csvPath = aguarda saveSheetAsCsv('abc123');\n```\n\nIsso está intimamente ligado ao conceito de Skills, pastas de instruções reutilizáveis, scripts e recursos para modelos para melhorar o desempenho em tarefas especializadas.Adicionar um arquivo SKILL.md a essas funções salvas cria uma habilidade estruturada que os modelos podem referenciar e usar.Com o tempo, isso permite que seu agente construa uma caixa de ferramentas de recursos de nível superior, evoluindo a estrutura necessária para trabalhar com mais eficiência.\n\nObserve que a execução do código apresenta sua própria complexidade.A execução de código gerado pelo agente requer um ambiente de execução seguro com sandboxing, limites de recursos e monitoramento apropriados.Esses requisitos de infraestrutura acrescentam sobrecarga operacional e considerações de segurança que as chamadas diretas à ferramenta evitam.Os benefícios dos custos de token reduzidos na execução do código, menor latência e melhor composição da ferramenta devem ser avaliados em relação a esses custos de implementação.\n\nResumo O MCP fornece um protocolo básico para que os agentes se conectem a muitas ferramentas e sistemas.No entanto, quando muitos servidores estão conectados, as definições e os resultados da ferramenta podem consumir tokens excessivos, reduzindo a eficiência do agente.\n\nEmbora muitos dos problemas aqui pareçam gerenciamento de contexto novo, composição de ferramentas e persistência de estado - eles têm soluções conhecidas da engenharia de software.A execução de código aplica esses padrões estabelecidos aos agentes, permitindo-lhes usar construções de programação familiares para interagir com servidores MCP de forma mais eficiente.Se você implementar essa abordagem, encorajamos você a compartilhar suas descobertas com a comunidade MCP.\n\nAgradecimentos\n\nEste artigo foi escrito por Adam Jones e Conor Kelly.Obrigado a Jeremy Fox, Jerome Swannack, Stuart Ritchie, Molly Vorwerck, Matt Samuels e Maggie Vo pelos comentários sobre os rascunhos deste post.",
      "edited": false
    },
    "zh": {
      "title": "使用 MCP 执行代码：构建更高效的代理",
      "content": "模型上下文协议 (MCP) 是用于将 AI 代理连接到外部系统的开放标准。传统上，将代理连接到工具和数据需要为每个配对进行自定义集成，从而产生碎片和重复工作，从而难以扩展真正连接的系统。MCP 提供了一个通用协议，开发人员在其代理中实施 MCP 一次，即可解锁整个集成生态系统。\n\n自 2024 年 11 月推出 MCP 以来，采用速度很快：社区已经构建了数千台 MCP 服务器，SDK 可用于所有主要编程语言，并且业界已采用 MCP 作为将代理连接到工具和数据的事实上的标准。\n\n如今，开发人员通常会构建能够访问数十台 MCP 服务器上的数百或数千种工具的代理。然而，随着连接工具数量的增长，预先加载所有工具定义并通过上下文窗口传递中间结果会减慢代理速度并增加成本。\n\n在本博客中，我们将探讨代码执行如何使代理能够更有效地与 MCP 服务器交互，在使用更少令牌的同时处理更多工具。\n\n工具过度消耗代币会导致代理效率降低\n\n随着 MCP 使用规模的扩大，有两种常见模式可能会增加代理成本和延迟：\n\n- 工具定义使上下文窗口过载；\n\n- 中间工具结果消耗额外的代币。\n\n1. 工具定义使上下文窗口超载\n\n大多数 MCP 客户端将所有工具定义直接加载到上下文中，使用直接工具调用语法将它们暴露给模型。这些工具定义可能如下所示：\n\n````\ngdrive.getDocument\n描述：从 Google Drive 检索文档\n参数：\ndocumentId (required, string): 要检索的文档的 ID\nfields（可选，字符串）：要返回的特定字段\n返回：包含标题、正文内容、元数据、权限等的文档对象。\n````\n\n````\nsalesforce.updateRecord\n描述：更新 Salesforce 中的记录\n参数：\nobjectType（必填，字符串）：Salesforce 对象的类型（潜在客户、联系人、客户等）\nrecordId（必需，字符串）：要更新的记录的ID\n数据（必需，对象）：使用新值更新的字段\n返回：更新记录对象并确认\n````\n\n工具描述占用更多上下文窗口空间，增加响应时间和成本。如果代理连接到数千个工具，他们需要在读取请求之前处理数十万个令牌。\n\n2. 中间工具结果消耗额外代币\n\n大多数MCP客户端允许模型直接调用MCP工具。例如，您可能会询问您的代理：“从 Google 云端硬盘下载我的会议记录并将其附加给 Salesforce 领导。”\n\n该模型将进行如下调用：\n\n````\n工具调用：gdrive.getDocument（documentId：“abc123”）\n→ 返回“讨论的第四季度目标...\\n[完整记录文本]”\n（加载到模型上下文中）\n\n工具调用： salesforce.updateRecord(\n对象类型：“销售会议”，\n记录ID：“00Q5f000001abcXYZ”，\ndata: { \"Notes\": \"讨论第四季度目标...\\n[写出完整的文字记录文本]\" }\n）\n（模型需要再次将整个转录本写入上下文）\n````\n\n每个中间结果都必须经过模型。在此示例中，完整的通话记录经过两次。对于 2 小时的销售会议，这可能意味着额外处理 50,000 个代币。即使更大的文档也可能超出上下文窗口限制，从而破坏工作流程。\n\n对于大型文档或复杂的数据结构，模型在工具调用之间复制数据时可能更容易出错。\n\n[[IMAGE_1|MCP 客户端将工具定义加载到模型的上下文窗口中，并编排一个消息循环，其中每个工具调用和结果在操作之间通过模型。]]\n\n使用 MCP 执行代码可提高上下文效率\n\n随着代码执行环境对于代理来说变得越来越普遍，解决方案是将 MCP 服务器呈现为代码 API，而不是直接工具调用。然后，代理可以编写代码来与 MCP 服务器交互。这种方法解决了这两个挑战：代理只能加载他们需要的工具，并在将结果传递回模型之前在执行环境中处理数据。 有多种方法可以做到这一点。一种方法是从连接的 MCP 服务器生成所有可用工具的文件树。这是使用 TypeScript 的实现：\n\n````\n服务器\n├── 谷歌驱动器\n│ ├── getDocument.ts\n│ ├── ...（其他工具）\n│ └── 索引.ts\n├── 销售人员\n│ ├── updateRecord.ts\n│ ├── ...（其他工具）\n│ └── 索引.ts\n└── ...（其他服务器）\n````\n\n那么每个工具对应一个文件，类似于：\n\n````\n// ./servers/google-drive/getDocument.ts\n从“../../../client.js”导入{callMCPTool}；\n\n接口获取文档输入{\n文档ID：字符串；\n}\n\n接口获取文档响应{\n内容：字符串；\n}\n\n/* 从 Google Drive 读取文档 */\n导出异步函数 getDocument(输入: GetDocumentInput): Promise<GetDocumentResponse> {\n返回 callMCPTool<GetDocumentResponse>('google_drive__get_document', input);\n}\n````\n\n我们上面的 Google Drive 到 Salesforce 示例变成了代码：\n\n````\n// 从 Google Docs 读取文字记录并添加到 Salesforce 潜在客户\n从“./servers/google-drive”导入*作为gdrive；\n从 './servers/salesforce' 导入 * 作为 salesforce；\n\nconst 成绩单 = (await gdrive.getDocument({ documentId: 'abc123' })).content;\n等待 salesforce.updateRecord({\nobjectType: '销售会议',\n记录 ID: '00Q5f000001abcXYZ',\n数据：{注释：文字记录}\n});\n````\n\n代理通过探索文件系统来发现工具：列出 ./servers/ 目录以查找可用服务器（例如 google-drive 和 salesforce ），然后读取它需要的特定工具文件（例如 getDocument.ts 和 updateRecord.ts ）以了解每个工具的界面。这使得代理仅加载当前任务所需的定义。这将代币使用量从 150,000 个代币减少到 2,000 个代币，节省了 98.7% 的时间和成本。\n\nCloudflare 发布了类似的发现，将 MCP 的代码执行称为“代码模式”。核心见解是相同的：LLM 擅长编写代码，开发人员应该利用这一优势来构建能够更有效地与 MCP 服务器交互的代理。\n\n使用 MCP 执行代码的好处\n\n使用 MCP 执行代码使代理能够通过按需加载工具、在数据到达模型之前过滤数据以及在一个步骤中执行复杂的逻辑来更有效地使用上下文。使用这种方法还具有安全性和状态管理优势。\n\n渐进式披露\n\n模型非常擅长导航文件系统。将工具呈现为文件系统上的代码允许模型按需读取工具定义，而不是预先读取它们。\n\n或者，可以将 search_tools 工具添加到服务器来查找相关定义。例如，当使用上面使用的假设 Salesforce 服务器时，代理会搜索“salesforce”并仅加载当前任务所需的工具。在 search_tools 工具中包含一个详细级别参数，允许代理选择所需的详细级别（例如仅名称、名称和描述，或带有模式的完整定义），也有助于代理保存上下文并有效地查找工具。\n\n上下文有效的工具结果\n\n在处理大型数据集时，代理可以在返回结果之前过滤和转换代码中的结果。考虑获取一个 10,000 行的电子表格：\n\n````\n// 没有代码执行 - 所有行都流过上下文\n工具调用：gdrive.getSheet(sheetId: 'abc123')\n→ 在上下文中返回 10,000 行以手动过滤\n\n// 随着代码执行-执行环境中的过滤器\nconst allRows =等待 gdrive.getSheet({sheetId: 'abc123' });\nconstendingOrders = allRows.filter(行 =>\n行[“状态”] === '待处理'\n）；\nconsole.log(`发现 ${pendingOrders.length} 挂单`);\nconsole.log(pendingOrders.slice(0, 5));// 只记录前 5 个以供审核\n````\n\n代理看到的是 5 行而不是 10,000 行。类似的模式适用于聚合、跨多个数据源的联接或提取特定字段，所有这些都不会使上下文窗口膨胀。\n\n更强大且上下文高效的控制流\n\n循环、条件和错误处理可以使用熟悉的代码模式来完成，而不是链接单个工具调用。例如，如果您需要 Slack 中的部署通知，代理可以编写： ````\n让找到=假；\n而（！发现）{\nconst messages = wait slack.getChannelHistory({ 频道: 'C123456' });\nfind = messages.some(m => m.text.includes('部署完成'));\nif (!found) 等待新的 Promise(r => setTimeout(r, 5000));\n}\nconsole.log('收到部署通知');\n````\n\n这种方法比通过代理循环在 MCP 工具调用和睡眠命令之间交替进行更有效。\n\n此外，能够写出执行的条件树还可以节省“第一个令牌的时间”延迟：代理可以让代码执行环境执行此操作，而不必等待模型评估 if 语句。\n\n隐私保护操作\n\n当代理使用 MCP 执行代码时，中间结果默认保留在执行环境中。这样，代理只能看到您显式记录或返回的内容，这意味着您不希望与模型共享的数据可以流经您的工作流程，而无需进入模型的上下文。\n\n对于更敏感的工作负载，代理工具可以自动标记敏感数据。例如，假设您需要将客户联系详细信息从电子表格导入 Salesforce。代理人写道：\n\n````\nconstsheet=awaitgdrive.getSheet({sheetId:'abc123'});\nfor (sheet.rows 的常量行) {\n等待 salesforce.updateRecord({\nobjectType: '铅',\n记录Id：row.salesforceId，\n数据：{\n电子邮件：行.电子邮件，\n电话: row.phone,\n名称：行.名称\n}\n});\n}\nconsole.log(`更新了 ${sheet.rows.length} 线索`);\n````\n\nMCP 客户端在数据到达模型之前拦截数据并标记 PII：\n\n````\n// 如果代理记录了sheet.rows，它会看到什么：\n[\n{ salesforceId:“00Q...”，电子邮件：“[EMAIL_1]”，电话：“[PHONE_1]”，姓名：“[NAME_1]”},\n{ salesforceId: '00Q...', 电子邮件: '[EMAIL_2]', 电话: '[PHONE_2]', 姓名: '[NAME_2]' },\n...\n]\n````\n\n然后，当数据在另一个 MCP 工具调用中共享时，它会通过 MCP 客户端中的查找来取消标记。真实的电子邮件地址、电话号码和姓名从 Google Sheets 流向 Salesforce，但从未通过模型。这可以防止代理意外记录或处理敏感数据。您还可以使用它来定义确定性安全规则，选择数据可以流入和流出的位置。\n\n状态坚持和技能\n\n通过文件系统访问执行代码允许代理跨操作维护状态。代理可以将中间结果写入文件，使他们能够恢复工作并跟踪进度：\n\n````\nconst 线索 = 等待 salesforce.query({\n查询：“选择 ID，电子邮件来自潜在客户 LIMIT 1000”\n});\nconst csvData = Leads.map(l => `${l.Id},${l.Email}`).join('\\n');\n等待 fs.writeFile('./workspace/leads.csv', csvData);\n\n// 稍后从中断处继续执行\nconst 保存=等待 fs.readFile('./workspace/leads.csv', 'utf-8');\n````\n\n代理还可以将自己的代码保留为可重用函数。一旦代理为任务开发了工作代码，它就可以保存该实现以供将来使用：\n\n````\n// 在 ./skills/save-sheet-as-csv.ts 中\n从“./servers/google-drive”导入*作为gdrive；\n导出异步函数 saveSheetAsCsv(sheetId: string) {\nconst data =等待gdrive.getSheet({sheetId});\nconst csv = data.map(row => row.join(',')).join('\\n');\n等待 fs.writeFile(`./workspace/sheet-${sheetId}.csv`, csv);\n返回 `./workspace/sheet-${sheetId}.csv`;\n}\n\n// 稍后，在任何代理执行中：\n从 './skills/save-sheet-as-csv' 导入 { saveSheetAsCsv }；\nconst csvPath = 等待 saveSheetAsCsv('abc123');\n````\n\n这与技能、可重用指令的文件夹、脚本和模型资源的概念密切相关，以提高专门任务的性能。将 SKILL.md 文件添加到这些保存的函数中会创建模型可以参考和使用的结构化技能。随着时间的推移，这允许您的代理构建一个具有更高级别功能的工具箱，不断发展最有效工作所需的脚手架。\n\n请注意，代码执行会带来其自身的复杂性。运行代理生成的代码需要一个具有适当沙箱、资源限制和监控的安全执行环境。这些基础设施要求增加了直接工具调用所避免的操作开销和安全考虑。代码执行的好处——降低代币成本、降低延迟和改进工具组合——应该与这些实施成本进行权衡。\n\n概括 MCP 为代理连接到许多工具和系统提供了基础协议。然而，一旦连接太多服务器，工具定义和结果可能会消耗过多的令牌，从而降低代理效率。\n\n尽管这里的许多问题感觉很新颖——上下文管理、工具组合、状态持久性——但他们已经从软件工程中找到了已知的解决方案。代码执行将这些已建立的模式应用于代理，让它们使用熟悉的编程结构更有效地与 MCP 服务器交互。如果您实施此方法，我们鼓励您与 MCP 社区分享您的发现。\n\n致谢\n\n本文由亚当·琼斯和康纳·凯利撰写。感谢 Jeremy Fox、Jerome Swannack、Stuart Ritchie、Molly Vorwerck、Matt Samuels 和 Maggie Vo 对本文草稿的反馈。",
      "edited": false
    },
    "hi": {
      "title": "एमसीपी के साथ कोड निष्पादन: अधिक कुशल एजेंटों का निर्माण",
      "content": "मॉडल कॉन्टेक्स्ट प्रोटोकॉल (एमसीपी) एआई एजेंटों को बाहरी सिस्टम से जोड़ने के लिए एक खुला मानक है।एजेंटों को टूल और डेटा से कनेक्ट करने के लिए पारंपरिक रूप से प्रत्येक जोड़ी के लिए एक कस्टम एकीकरण की आवश्यकता होती है, जिससे विखंडन और दोहराव का प्रयास होता है जिससे वास्तव में कनेक्टेड सिस्टम को स्केल करना मुश्किल हो जाता है।एमसीपी एक सार्वभौमिक प्रोटोकॉल प्रदान करता है-डेवलपर्स अपने एजेंट में एक बार एमसीपी लागू करते हैं और यह एकीकरण के पूरे पारिस्थितिकी तंत्र को अनलॉक करता है।\n\nनवंबर 2024 में एमसीपी लॉन्च करने के बाद से, अपनाने में तेजी आई है: समुदाय ने हजारों एमसीपी सर्वर बनाए हैं, एसडीके सभी प्रमुख प्रोग्रामिंग भाषाओं के लिए उपलब्ध हैं, और उद्योग ने एजेंटों को टूल और डेटा से जोड़ने के लिए एमसीपी को वास्तविक मानक के रूप में अपनाया है।\n\nआज डेवलपर्स नियमित रूप से दर्जनों एमसीपी सर्वरों पर सैकड़ों या हजारों टूल तक पहुंच वाले एजेंट बनाते हैं।हालाँकि, जैसे-जैसे कनेक्टेड टूल की संख्या बढ़ती है, सभी टूल परिभाषाओं को अग्रिम रूप से लोड करना और संदर्भ विंडो के माध्यम से मध्यवर्ती परिणाम पास करना एजेंटों को धीमा कर देता है और लागत बढ़ा देता है।\n\nइस ब्लॉग में हम यह पता लगाएंगे कि कैसे कोड निष्पादन एजेंटों को एमसीपी सर्वर के साथ अधिक कुशलता से बातचीत करने में सक्षम बना सकता है, कम टोकन का उपयोग करते हुए अधिक टूल को संभाल सकता है।\n\nटूल से अत्यधिक टोकन खपत एजेंटों को कम कुशल बनाती है\n\nएमसीपी उपयोग पैमाने के रूप में, दो सामान्य पैटर्न हैं जो एजेंट लागत और विलंबता को बढ़ा सकते हैं:\n\n- टूल परिभाषाएँ संदर्भ विंडो को ओवरलोड करती हैं;\n\n- इंटरमीडिएट टूल परिणाम अतिरिक्त टोकन का उपभोग करते हैं।\n\n1. टूल परिभाषाएँ संदर्भ विंडो को ओवरलोड करती हैं\n\nअधिकांश एमसीपी क्लाइंट सभी टूल परिभाषाओं को सीधे संदर्भ में लोड करते हैं, उन्हें सीधे टूल-कॉलिंग सिंटैक्स का उपयोग करके मॉडल में उजागर करते हैं।ये टूल परिभाषाएँ इस तरह दिख सकती हैं:\n\n```\ngdrive.getDocument\nविवरण: Google ड्राइव से एक दस्तावेज़ पुनर्प्राप्त करता है\nपैरामीटर:\ndocumentId (आवश्यक, स्ट्रिंग): पुनर्प्राप्त करने के लिए दस्तावेज़ की आईडी\nफ़ील्ड (वैकल्पिक, स्ट्रिंग): लौटने के लिए विशिष्ट फ़ील्ड\nरिटर्न: शीर्षक, मुख्य सामग्री, मेटाडेटा, अनुमतियाँ आदि के साथ दस्तावेज़ ऑब्जेक्ट।\n```\n\n```\nसेल्सफोर्स.अपडेटरिकॉर्ड\nविवरण: सेल्सफोर्स में एक रिकॉर्ड अपडेट करता है\nपैरामीटर:\nऑब्जेक्ट प्रकार (आवश्यक, स्ट्रिंग): सेल्सफोर्स ऑब्जेक्ट का प्रकार (लीड, संपर्क, खाता, आदि)\nरिकॉर्डआईडी (आवश्यक, स्ट्रिंग): अद्यतन करने के लिए रिकॉर्ड की आईडी\nडेटा (आवश्यक, वस्तु): अपने नए मानों के साथ अद्यतन करने के लिए फ़ील्ड\nरिटर्न: पुष्टिकरण के साथ अद्यतन रिकॉर्ड ऑब्जेक्ट\n```\n\nटूल विवरण अधिक संदर्भ विंडो स्थान घेरते हैं, जिससे प्रतिक्रिया समय और लागत बढ़ जाती है।ऐसे मामलों में जहां एजेंट हजारों टूल से जुड़े हैं, उन्हें अनुरोध पढ़ने से पहले सैकड़ों हजारों टोकन संसाधित करने की आवश्यकता होगी।\n\n2. इंटरमीडिएट टूल परिणाम अतिरिक्त टोकन का उपभोग करते हैं\n\nअधिकांश एमसीपी क्लाइंट मॉडलों को सीधे एमसीपी टूल्स को कॉल करने की अनुमति देते हैं।उदाहरण के लिए, आप अपने एजेंट से पूछ सकते हैं: \"Google ड्राइव से मेरी मीटिंग ट्रांसक्रिप्ट डाउनलोड करें और इसे Salesforce लीड में संलग्न करें।\"\n\nमॉडल इस प्रकार कॉल करेगा:\n\n```\nटूल कॉल: gdrive.getDocument(documentId: \"abc123\")\n→ रिटर्न \"Q4 लक्ष्यों पर चर्चा की गई...\\n[पूर्ण प्रतिलेख पाठ]\"\n(मॉडल संदर्भ में लोड किया गया)\n\nटूल कॉल: salesforce.updateRecord(\nऑब्जेक्ट प्रकार: \"सेल्समीटिंग\",\nरिकॉर्ड आईडी: \"00Q5f000001abcXYZ\",\nडेटा: { \"नोट्स\": \"Q4 लक्ष्यों पर चर्चा की गई...\\n[पूरा प्रतिलेख पाठ लिखा गया]\" }\n)\n(मॉडल को संपूर्ण प्रतिलेख को संदर्भ में फिर से लिखने की आवश्यकता है)\n```\n\nप्रत्येक मध्यवर्ती परिणाम को मॉडल से गुजरना होगा।इस उदाहरण में, पूर्ण कॉल ट्रांस्क्रिप्ट दो बार प्रवाहित होती है।2 घंटे की बिक्री बैठक के लिए, इसका मतलब अतिरिक्त 50,000 टोकन संसाधित करना हो सकता है।यहां तक ​​कि बड़े दस्तावेज़ भी संदर्भ विंडो की सीमा को पार कर सकते हैं, जिससे वर्कफ़्लो बाधित हो सकता है।\n\nबड़े दस्तावेज़ों या जटिल डेटा संरचनाओं के साथ, टूल कॉल के बीच डेटा कॉपी करते समय मॉडल से गलतियाँ होने की अधिक संभावना हो सकती है।\n\n[[IMAGE_1|MCP क्लाइंट टूल परिभाषाओं को मॉडल की संदर्भ विंडो में लोड करता है और एक संदेश लूप को व्यवस्थित करता है जहां प्रत्येक टूल कॉल और परिणाम संचालन के बीच मॉडल से गुजरता है।]]\n\nएमसीपी के साथ कोड निष्पादन संदर्भ दक्षता में सुधार करता है\n\nएजेंटों के लिए कोड निष्पादन वातावरण अधिक सामान्य होने के साथ, एक समाधान एमसीपी सर्वर को सीधे टूल कॉल के बजाय कोड एपीआई के रूप में प्रस्तुत करना है।फिर एजेंट एमसीपी सर्वर के साथ इंटरैक्ट करने के लिए कोड लिख सकता है।यह दृष्टिकोण दोनों चुनौतियों का समाधान करता है: एजेंट केवल उन उपकरणों को लोड कर सकते हैं जिनकी उन्हें आवश्यकता है और परिणामों को मॉडल पर वापस भेजने से पहले निष्पादन वातावरण में डेटा को संसाधित कर सकते हैं। यह करने के कई तरीके हैं।एक दृष्टिकोण कनेक्टेड एमसीपी सर्वर से सभी उपलब्ध टूल का फ़ाइल ट्री तैयार करना है।यहां टाइपस्क्रिप्ट का उपयोग करके एक कार्यान्वयन दिया गया है:\n\n```\nसर्वर\n├── गूगल-ड्राइव\n│ ├── getDocument.ts\n│ ├── ... (अन्य उपकरण)\n│ └── Index.ts\n├── सेल्सफोर्स\n│ ├── updateRecord.ts\n│ ├── ... (अन्य उपकरण)\n│ └── Index.ts\n└── ... (अन्य सर्वर)\n```\n\nफिर प्रत्येक उपकरण एक फ़ाइल से मेल खाता है, कुछ इस प्रकार:\n\n```\n// ./servers/google-drive/getDocument.ts\n\"../../../client.js\" से आयात { callMCPTool };\n\nइंटरफ़ेस GetDocumentInput {\nदस्तावेज़ आईडी: स्ट्रिंग;\n}\n\nइंटरफ़ेस GetDocumentResponse {\nसामग्री: स्ट्रिंग;\n}\n\n/* Google ड्राइव से एक दस्तावेज़ पढ़ें */\nasync फ़ंक्शन getDocument निर्यात करें (इनपुट: GetDocumentInput): वादा<GetDocumentResponse> {\nरिटर्न कॉलMCPTool<GetDocumentResponse>('google_drive__get_document', इनपुट);\n}\n```\n\nउपरोक्त हमारा Google Drive to Salesforce उदाहरण कोड बन जाता है:\n\n```\n// Google डॉक्स से प्रतिलेख पढ़ें और Salesforce संभावना में जोड़ें\n'./servers/google-drive' से gdrive के रूप में आयात करें;\n'./सर्वर/सेल्सफोर्स' से सेल्सफोर्स के रूप में आयात करें;\n\nस्थिरांक प्रतिलेख = (प्रतीक्षा gdrive.getDocument({ documentId: 'abc123' })).सामग्री;\nsalesforce.updateRecord({ का इंतजार करें\nऑब्जेक्ट प्रकार: 'सेल्समीटिंग',\nरिकॉर्डआईडी: '00Q5f000001abcXYZ',\nडेटा: { नोट्स: प्रतिलेख }\n});\n```\n\nएजेंट फ़ाइल सिस्टम की खोज करके टूल खोजता है: उपलब्ध सर्वर (जैसे Google-ड्राइव और सेल्सफोर्स) को खोजने के लिए ./servers/ निर्देशिका को सूचीबद्ध करता है, फिर प्रत्येक टूल के इंटरफ़ेस को समझने के लिए आवश्यक विशिष्ट टूल फ़ाइलों को पढ़ता है (जैसे getDocument.ts और updateRecord.ts)।यह एजेंट को केवल वही परिभाषाएँ लोड करने देता है जिनकी उसे वर्तमान कार्य के लिए आवश्यकता है।इससे टोकन का उपयोग 150,000 टोकन से घटकर 2,000 टोकन हो जाता है - समय और लागत में 98.7% की बचत होती है।\n\nक्लाउडफ्लेयर ने एमसीपी के साथ कोड निष्पादन को \"कोड मोड\" के रूप में संदर्भित करते हुए इसी तरह के निष्कर्ष प्रकाशित किए।मूल अंतर्दृष्टि समान है: एलएलएम कोड लिखने में माहिर हैं और डेवलपर्स को ऐसे एजेंटों का निर्माण करने के लिए इस ताकत का लाभ उठाना चाहिए जो एमसीपी सर्वर के साथ अधिक कुशलता से बातचीत करते हैं।\n\nएमसीपी के साथ कोड निष्पादन के लाभ\n\nएमसीपी के साथ कोड निष्पादन एजेंटों को मांग पर टूल लोड करके, मॉडल तक पहुंचने से पहले डेटा को फ़िल्टर करके और एक ही चरण में जटिल तर्क निष्पादित करके संदर्भ का अधिक कुशलता से उपयोग करने में सक्षम बनाता है।इस दृष्टिकोण का उपयोग करने के सुरक्षा और राज्य प्रबंधन लाभ भी हैं।\n\nप्रगतिशील खुलासा\n\nफ़ाइल सिस्टम को नेविगेट करने में मॉडल बहुत अच्छे हैं।फ़ाइल सिस्टम पर टूल को कोड के रूप में प्रस्तुत करने से मॉडल को टूल परिभाषाओं को पहले से पढ़ने के बजाय ऑन-डिमांड पढ़ने की अनुमति मिलती है।\n\nवैकल्पिक रूप से, प्रासंगिक परिभाषाएँ खोजने के लिए सर्वर में एक search_tools टूल जोड़ा जा सकता है।उदाहरण के लिए, ऊपर उपयोग किए गए काल्पनिक सेल्सफोर्स सर्वर के साथ काम करते समय, एजेंट \"सेल्सफोर्स\" की खोज करता है और केवल उन उपकरणों को लोड करता है जिनकी उसे वर्तमान कार्य के लिए आवश्यकता होती है।search_tools टूल में एक विवरण स्तर पैरामीटर शामिल करना जो एजेंट को आवश्यक विवरण के स्तर (जैसे केवल नाम, नाम और विवरण, या स्कीमा के साथ पूर्ण परिभाषा) का चयन करने की अनुमति देता है, एजेंट को संदर्भ को संरक्षित करने और टूल को कुशलतापूर्वक ढूंढने में भी मदद करता है।\n\nप्रसंग कुशल उपकरण परिणाम\n\nबड़े डेटासेट के साथ काम करते समय, एजेंट परिणामों को वापस करने से पहले उन्हें फ़िल्टर और कोड में बदल सकते हैं।10,000-पंक्ति वाली स्प्रेडशीट लाने पर विचार करें:\n\n```\n// कोड निष्पादन के बिना - सभी पंक्तियाँ संदर्भ के माध्यम से प्रवाहित होती हैं\nटूल कॉल: gdrive.getSheet(शीटआईडी: 'abc123')\n→ मैन्युअल रूप से फ़िल्टर करने के लिए संदर्भ में 10,000 पंक्तियाँ लौटाता है\n\n// कोड निष्पादन के साथ - निष्पादन वातावरण में फ़िल्टर करें\nस्थिरांक allRows = प्रतीक्षा gdrive.getSheet({ शीटआईडी: 'abc123' });\nस्थिरांक लंबित आदेश = allRows.filter(पंक्ति =>\nपंक्ति[\"स्थिति\"] === 'लंबित'\n);\nकंसोल.लॉग(`${pendingOrders.length} लंबित ऑर्डर मिले`);\nकंसोल.लॉग(पेंडिंगऑर्डर्स.स्लाइस(0, 5));// समीक्षा के लिए केवल पहले 5 लॉग करें\n```\n\nएजेंट को 10,000 के बजाय पाँच पंक्तियाँ दिखाई देती हैं।समान पैटर्न एकत्रीकरण के लिए काम करते हैं, कई डेटा स्रोतों में जुड़ते हैं, या विशिष्ट फ़ील्ड को निकालते हैं - संदर्भ विंडो को फुलाए बिना।\n\nअधिक शक्तिशाली और संदर्भ-कुशल नियंत्रण प्रवाह\n\nलूप, कंडीशनल और त्रुटि प्रबंधन को अलग-अलग टूल कॉल को चेन करने के बजाय परिचित कोड पैटर्न के साथ किया जा सकता है।उदाहरण के लिए, यदि आपको स्लैक में परिनियोजन अधिसूचना की आवश्यकता है, तो एजेंट लिख सकता है: ```\nचलो पाया = झूठा;\nजबकि (!पाया गया) {\nस्थिरांक संदेश = प्रतीक्षा करें slack.getChannelHistory({चैनल: 'C123456' });\nमिला = messages.some(m => m.text.includes('तैनाती पूर्ण'));\nयदि (!पाया गया) नए वादे का इंतजार करें(आर => सेटटाइमआउट(आर, 5000));\n}\nकंसोल.लॉग ('परिनियोजन अधिसूचना प्राप्त हुई');\n```\n\nयह दृष्टिकोण एजेंट लूप के माध्यम से एमसीपी टूल कॉल और स्लीप कमांड के बीच वैकल्पिक करने से अधिक कुशल है।\n\nइसके अतिरिक्त, निष्पादित होने वाले एक सशर्त पेड़ को लिखने में सक्षम होने से \"पहले टोकन के समय\" विलंबता पर भी बचत होती है: किसी इफ-स्टेटमेंट का मूल्यांकन करने के लिए मॉडल की प्रतीक्षा करने के बजाय, एजेंट कोड निष्पादन वातावरण को ऐसा करने दे सकता है।\n\nगोपनीयता-संरक्षण संचालन\n\nजब एजेंट एमसीपी के साथ कोड निष्पादन का उपयोग करते हैं, तो मध्यवर्ती परिणाम डिफ़ॉल्ट रूप से निष्पादन वातावरण में रहते हैं।इस तरह, एजेंट केवल वही देखता है जो आप स्पष्ट रूप से लॉग करते हैं या लौटाते हैं, जिसका अर्थ है कि जिस डेटा को आप मॉडल के साथ साझा नहीं करना चाहते हैं वह मॉडल के संदर्भ में प्रवेश किए बिना आपके वर्कफ़्लो के माध्यम से प्रवाहित हो सकता है।\n\nऔर भी अधिक संवेदनशील कार्यभार के लिए, एजेंट हार्नेस संवेदनशील डेटा को स्वचालित रूप से टोकनाइज़ कर सकता है।उदाहरण के लिए, कल्पना करें कि आपको स्प्रेडशीट से सेल्सफोर्स में ग्राहक संपर्क विवरण आयात करने की आवश्यकता है।एजेंट लिखता है:\n\n```\nस्थिरांक शीट = प्रतीक्षा gdrive.getSheet({ शीटआईडी: 'एबीसी123' });\n(शीट.पंक्तियों की स्थिर पंक्ति) के लिए {\nsalesforce.updateRecord({ का इंतजार करें\nऑब्जेक्ट प्रकार: 'लीड',\nरिकॉर्डआईडी: row.salesforceId,\nडेटा: {\nईमेल: row.email,\nफ़ोन: पंक्ति.फ़ोन,\nनाम: पंक्ति.नाम\n}\n});\n}\nकंसोल.लॉग(`अपडेटेड ${शीट.रो.लेंथ} लीड`);\n```\n\nएमसीपी क्लाइंट डेटा को इंटरसेप्ट करता है और मॉडल तक पहुंचने से पहले पीआईआई को टोकनाइज़ करता है:\n\n```\n// एजेंट क्या देखेगा, यदि उसने शीट.पंक्तियों को लॉग किया है:\n[\n{ salesforceId: '00Q...', ईमेल: '[EMAIL_1]', फ़ोन: '[PHONE_1]', नाम: '[NAME_1]' },\n{ salesforceId: '00Q...', ईमेल: '[EMAIL_2]', फ़ोन: '[PHONE_2]', नाम: '[NAME_2]' },\n...\n]\n```\n\nफिर, जब डेटा को किसी अन्य MCP टूल कॉल में साझा किया जाता है, तो इसे MCP क्लाइंट में लुकअप के माध्यम से अनटोकनाइज़ किया जाता है।वास्तविक ईमेल पते, फ़ोन नंबर और नाम Google शीट से Salesforce तक प्रवाहित होते हैं, लेकिन मॉडल के माध्यम से कभी नहीं।यह एजेंट को संवेदनशील डेटा को गलती से लॉग करने या संसाधित करने से रोकता है।आप इसका उपयोग नियतात्मक सुरक्षा नियमों को परिभाषित करने के लिए भी कर सकते हैं, यह चुनकर कि डेटा कहाँ और कहाँ से प्रवाहित हो सकता है।\n\nराज्य दृढ़ता और कौशल\n\nफ़ाइल सिस्टम एक्सेस के साथ कोड निष्पादन एजेंटों को संचालन में स्थिति बनाए रखने की अनुमति देता है।एजेंट फ़ाइलों में मध्यवर्ती परिणाम लिख सकते हैं, जिससे वे काम फिर से शुरू करने और प्रगति को ट्रैक करने में सक्षम हो सकते हैं:\n\n```\nस्थिरांक लीड = प्रतीक्षा करें salesforce.query({\nक्वेरी: 'लीड सीमा 1000 से आईडी, ईमेल चुनें'\n});\nconst csvData = Leads.map(l => `${l.Id},${l.Email}`).join('\\n');\nप्रतीक्षा करें fs.writeFile('./workspace/leads.csv', csvData);\n\n// बाद में निष्पादन वहीं से शुरू होता है जहां इसे छोड़ा गया था\nस्थिरांक सहेजा गया = प्रतीक्षा करें fs.readFile('./workspace/leads.csv', 'utf-8');\n```\n\nएजेंट अपने स्वयं के कोड को पुन: प्रयोज्य कार्यों के रूप में भी जारी रख सकते हैं।एक बार जब कोई एजेंट किसी कार्य के लिए कार्यशील कोड विकसित कर लेता है, तो वह उस कार्यान्वयन को भविष्य में उपयोग के लिए सहेज सकता है:\n\n```\n// इन ./skills/save-शीट-as-csv.ts\n'./servers/google-drive' से gdrive के रूप में आयात करें;\nनिर्यात async फ़ंक्शन saveSheetAsCsv(शीटआईडी: स्ट्रिंग) {\nस्थिरांक डेटा = प्रतीक्षा gdrive.getSheet({ शीटआईडी });\nconst csv = data.map(row => row.join(',')).join('\\n');\nप्रतीक्षा करें fs.writeFile(`./workspace/शीट-${शीटआईडी}.csv`, csv);\nवापसी `./workspace/शीट-${शीटआईडी}.csv`;\n}\n\n// बाद में, किसी भी एजेंट निष्पादन में:\n'./skills/save-Sheet-as-csv' से आयात { saveSheetAsCsv };\nconst csvPath = प्रतीक्षा करें saveSheetAsCsv('abc123');\n```\n\nयह विशेष कार्यों पर प्रदर्शन को बेहतर बनाने के लिए कौशल, पुन: प्रयोज्य निर्देशों के फ़ोल्डर, स्क्रिप्ट और मॉडल के संसाधनों की अवधारणा से निकटता से जुड़ा हुआ है।इन सहेजे गए फ़ंक्शंस में SKILL.md फ़ाइल जोड़ने से एक संरचित कौशल बनता है जिसे मॉडल संदर्भित और उपयोग कर सकते हैं।समय के साथ, यह आपके एजेंट को उच्च-स्तरीय क्षमताओं का एक टूलबॉक्स बनाने की अनुमति देता है, जिससे वह मचान विकसित होता है जिसकी उसे सबसे प्रभावी ढंग से काम करने की आवश्यकता होती है।\n\nध्यान दें कि कोड निष्पादन अपनी जटिलता का परिचय देता है।एजेंट-जनरेटेड कोड चलाने के लिए उपयुक्त सैंडबॉक्सिंग, संसाधन सीमा और निगरानी के साथ एक सुरक्षित निष्पादन वातावरण की आवश्यकता होती है।इन बुनियादी ढाँचे की आवश्यकताओं में परिचालन ओवरहेड और सुरक्षा संबंधी विचार शामिल होते हैं जिनसे प्रत्यक्ष टूल कॉल से बचा जा सकता है।कोड निष्पादन-कम टोकन लागत, कम विलंबता और बेहतर उपकरण संरचना-के लाभों को इन कार्यान्वयन लागतों के विरुद्ध तौला जाना चाहिए।\n\nसारांश एमसीपी एजेंटों को कई टूल और सिस्टम से जुड़ने के लिए एक मूलभूत प्रोटोकॉल प्रदान करता है।हालाँकि, एक बार जब बहुत सारे सर्वर कनेक्ट हो जाते हैं, तो टूल परिभाषाएँ और परिणाम अत्यधिक टोकन का उपभोग कर सकते हैं, जिससे एजेंट की दक्षता कम हो जाती है।\n\nयद्यपि यहां कई समस्याएं नवीन हैं-संदर्भ प्रबंधन, उपकरण संरचना, राज्य दृढ़ता-उनके पास सॉफ्टवेयर इंजीनियरिंग से ज्ञात समाधान हैं।कोड निष्पादन इन स्थापित पैटर्न को एजेंटों पर लागू करता है, जिससे उन्हें एमसीपी सर्वर के साथ अधिक कुशलता से बातचीत करने के लिए परिचित प्रोग्रामिंग संरचनाओं का उपयोग करने की सुविधा मिलती है।यदि आप इस दृष्टिकोण को लागू करते हैं, तो हम आपको अपने निष्कर्षों को एमसीपी समुदाय के साथ साझा करने के लिए प्रोत्साहित करते हैं।\n\nआभार\n\nयह लेख एडम जोन्स और कॉनर केली द्वारा लिखा गया था।इस पोस्ट के ड्राफ्ट पर प्रतिक्रिया के लिए जेरेमी फॉक्स, जेरोम स्वानैक, स्टुअर्ट रिची, मौली वोरवर्क, मैट सैमुअल्स और मैगी वो को धन्यवाद।",
      "edited": false
    }
  },
  "metadata": {
    "tags": [
      "Anthropic",
      "MCP",
      "Engineering"
    ]
  }
}
