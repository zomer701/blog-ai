{
  "id": "sample-anthropic-advanced-tool-use",
  "source": "Anthropic",
  "source_url": "https://www.anthropic.com/engineering/advanced-tool-use",
  "title": "Introducing advanced tool use on the Claude Developer Platform",
  "author": "Anthropic Engineering",
  "published_date": "2025-11-24T00:00:00Z",
  "scraped_at": 1733203200000,
  "status": "published",
  "content": {
    "original_html": "",
    "text": "The future of AI agents is one where models work seamlessly across hundreds or thousands of tools. An IDE assistant that integrates git operations, file manipulation, package managers, testing frameworks, and deployment pipelines. An operations coordinator that connects Slack, GitHub, Google Drive, Jira, company databases, and dozens of MCP servers simultaneously.\n\nTo build effective agents , they need to work with unlimited tool libraries without stuffing every definition into context upfront. Our blog article on using code execution with MCP discussed how tool results and definitions can sometimes consume 50,000+ tokens before an agent reads a request. Agents should discover and load tools on-demand, keeping only what's relevant for the current task.\n\nAgents also need the ability to call tools from code. When using natural language tool calling, each invocation requires a full inference pass, and intermediate results pile up in context whether they're useful or not. Code is a natural fit for orchestration logic, such as loops, conditionals, and data transformations. Agents need the flexibility to choose between code execution and inference based on the task at hand.\n\nAgents also need to learn correct tool usage from examples, not just schema definitions. JSON schemas define what's structurally valid, but can't express usage patterns: when to include optional parameters, which combinations make sense, or what conventions your API expects.\n\nToday, we're releasing three features that make this possible:\n\n- Tool Search Tool, which allows Claude to use search tools to access thousands of tools without consuming its context window\n\n- Programmatic Tool Calling , which allows Claude to invoke tools in a code execution environment reducing the impact on the model's context window\n\n- Tool Use Examples , which provides a universal standard for demonstrating how to effectively use a given tool\n\nIn internal testing, we've found these features have helped us build things that wouldn't have been possible with conventional tool use patterns. For example, Claude for Excel uses Programmatic Tool Calling to read and modify spreadsheets with thousands of rows without overloading the model's context window.\n\nBased on our experience, we believe these features open up new possibilities for what you can build with Claude.\n\nTool Search Tool\n\nThe challenge\n\nMCP tool definitions provide important context, but as more servers connect, those tokens can add up. Consider a five-server setup:\n\n- GitHub: 35 tools (~26K tokens)\n\n- Slack: 11 tools (~21K tokens)\n\n- Sentry: 5 tools (~3K tokens)\n\n- Grafana: 5 tools (~3K tokens)\n\n- Splunk: 2 tools (~2K tokens)\n\nThat's 58 tools consuming approximately 55K tokens before the conversation even starts. Add more servers like Jira (which alone uses ~17K tokens) and you're quickly approaching 100K+ token overhead. At Anthropic, we've seen tool definitions consume 134K tokens before optimization.\n\nBut token cost isn't the only issue. The most common failures are wrong tool selection and incorrect parameters, especially when tools have similar names like notification-send-user vs. notification-send-channel .\n\nOur solution\n\nInstead of loading all tool definitions upfront, the Tool Search Tool discovers tools on-demand. Claude only sees the tools it actually needs for the current task.\n\n[[IMAGE_1|Tool Search Tool preserves 191,300 tokens of context compared to 122,800 with Claude's traditional approach.]]\n\nTraditional approach:\n\n- All tool definitions loaded upfront (~72K tokens for 50+ MCP tools)\n\n- Conversation history and system prompt compete for remaining space\n\n- Total context consumption: ~77K tokens before any work begins\n\nWith the Tool Search Tool:\n\n- Only the Tool Search Tool loaded upfront (~500 tokens)\n\n- Tools discovered on-demand as needed (3-5 relevant tools, ~3K tokens)\n\n- Total context consumption: ~8.7K tokens, preserving 95% of context window\n\nThis represents an 85% reduction in token usage while maintaining access to your full tool library. Internal testing showed significant accuracy improvements on MCP evaluations when working with large tool libraries. Opus 4 improved from 49% to 74%, and Opus 4.5 improved from 79.5% to 88.1% with Tool Search Tool enabled.\n\nHow the Tool Search Tool works\n\nThe Tool Search Tool lets Claude dynamically discover tools instead of loading all definitions upfront. You provide all your tool definitions to the API, but mark tools with defer_loading: true to make them discoverable on-demand. Deferred tools aren't loaded into Claude's context initially. Claude only sees the Tool Search Tool itself plus any tools with defer_loading: false (your most critical, frequently-used tools).\n\nWhen Claude needs specific capabilities, it searches for relevant tools. The Tool Search Tool returns references to matching tools, which get expanded into full definitions in Claude's context.\n\nFor example, if Claude needs to interact with GitHub, it searches for \"github,\" and only github.createPullRequest and github.listIssues get loaded-not your other 50+ tools from Slack, Jira, and Google Drive.\n\nThis way, Claude has access to your full tool library while only paying the token cost for tools it actually needs.\n\nPrompt caching note: Tool Search Tool doesn't break prompt caching because deferred tools are excluded from the initial prompt entirely. They're only added to context after Claude searches for them, so your system prompt and core tool definitions remain cacheable.\n\nImplementation:\n\n```\n{\n  \"tools\": [\n    // Include a tool search tool (regex, BM25, or custom)\n    {\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n\n    // Mark tools for on-demand discovery\n    {\n      \"name\": \"github.createPullRequest\",\n      \"description\": \"Create a pull request\",\n      \"input_schema\": {...},\n      \"defer_loading\": true\n    }\n    // ... hundreds more deferred tools with defer_loading: true\n  ]\n}\n```\n\nFor MCP servers, you can defer loading entire servers while keeping specific high-use tools loaded:\n\n```\n{\n  \"type\": \"mcp_toolset\",\n  \"mcp_server_name\": \"google-drive\",\n  \"default_config\": {\"defer_loading\": true}, # defer loading the entire server\n  \"configs\": {\n    \"search_files\": {\n\"defer_loading\": false\n    }  // Keep most used tool loaded\n  }\n}\n```\n\nThe Claude Developer Platform provides regex-based and BM25-based search tools out of the box, but you can also implement custom search tools using embeddings or other strategies.\n\nWhen to use the Tool Search Tool\n\nLike any architectural decision, enabling the Tool Search Tool involves trade-offs. The feature adds a search step before tool invocation, so it delivers the best ROI when the context savings and accuracy improvements outweigh additional latency.\n\nUse it when:\n\n- Tool definitions consuming >10K tokens\n\n- Experiencing tool selection accuracy issues\n\n- Building MCP-powered systems with multiple servers\n\n- 10+ tools available\n\nLess beneficial when:\n\n- Small tool library (<10 tools)\n\n- All tools used frequently in every session\n\n- Tool definitions are compact\n\nProgrammatic Tool Calling\n\nThe challenge\n\nTraditional tool calling creates two fundamental problems as workflows become more complex:\n\n- Context pollution from intermediate results : When Claude analyzes a 10MB log file for error patterns, the entire file enters its context window, even though Claude only needs a summary of error frequencies. When fetching customer data across multiple tables, every record accumulates in context regardless of relevance. These intermediate results consume massive token budgets and can push important information out of the context window entirely.\n\n- Inference overhead and manual synthesis : Each tool call requires a full model inference pass. After receiving results, Claude must \"eyeball\" the data to extract relevant information, reason about how pieces fit together, and decide what to do next-all through natural language processing. A five tool workflow means five inference passes plus Claude parsing each result, comparing values, and synthesizing conclusions. This is both slow and error-prone.\n\nOur solution\n\nProgrammatic Tool Calling enables Claude to orchestrate tools through code rather than through individual API round-trips. Instead of Claude requesting tools one at a time with each result being returned to its context, Claude writes code that calls multiple tools, processes their outputs, and controls what information actually enters its context window.\n\nClaude excels at writing code and by letting it express orchestration logic in Python rather than through natural language tool invocations, you get more reliable, precise control flow. Loops, conditionals, data transformations, and error handling are all explicit in code rather than implicit in Claude's reasoning.\n\nExample: Budget compliance check\n\nConsider a common business task: \"Which team members exceeded their Q3 travel budget?\"\n\nYou have three tools available:\n\n- get_team_members(department) - Returns team member list with IDs and levels\n\n- get_expenses(user_id, quarter) - Returns expense line items for a user\n\n- get_budget_by_level(level) - Returns budget limits for an employee level\n\nTraditional approach :\n\n- Fetch team members 20 people\n\n- For each person, fetch their Q3 expenses 20 tool calls, each returning 50-100 line items (flights, hotels, meals, receipts)\n\n- Fetch budget limits by employee level\n\n- All of this enters Claude's context: 2,000+ expense line items (50 KB+)\n\n- Claude manually sums each person's expenses, looks up their budget, compares expenses against budget limits\n\n- More round-trips to the model, significant context consumption\n\nWith Programmatic Tool Calling :\n\nInstead of each tool result returning to Claude, Claude writes a Python script that orchestrates the entire workflow. The script runs in the Code Execution tool (a sandboxed environment), pausing when it needs results from your tools. When you return tool results via the API, they're processed by the script rather than consumed by the model. The script continues executing, and Claude only sees the final output.\n\n[[IMAGE_2|Programmatic Tool Calling enables Claude to orchestrate tools through code rather than through individual API round-trips, allowing for parallel tool execution.]]\n\nHere's what Claude's orchestration code looks like for the budget compliance task:\n\n```\nteam = await get_team_members(\"engineering\")\n\n# Fetch budgets for each unique level\nlevels = list(set(m[\"level\"] for m in team))\nbudget_results = await asyncio.gather(*[\n    get_budget_by_level(level) for level in levels\n])\n\n# Create a lookup dictionary: {\"junior\": budget1, \"senior\": budget2, ...}\nbudgets = {level: budget for level, budget in zip(levels, budget_results)}\n\n# Fetch all expenses in parallel\nexpenses = await asyncio.gather(*[\n    get_expenses(m[\"id\"], \"Q3\") for m in team\n])\n\n# Find employees who exceeded their travel budget\nexceeded = []\nfor member, exp in zip(team, expenses):\n    budget = budgets[member[\"level\"]]\n    total = sum(e[\"amount\"] for e in exp)\n    if total > budget[\"travel_limit\"]:\n        exceeded.append({\n            \"name\": member[\"name\"],\n            \"spent\": total,\n            \"limit\": budget[\"travel_limit\"]\n        })\n\nprint(json.dumps(exceeded))\n```\n\nClaude's context receives only the final result: the two to three people who exceeded their budget. The 2,000+ line items, the intermediate sums, and the budget lookups do not affect Claude's context, reducing consumption from 200KB of raw expense data to just 1KB of results.\n\nThe efficiency gains are substantial:\n\n- Token savings : By keeping intermediate results out of Claude's context, PTC dramatically reduces token consumption. Average usage dropped from 43,588 to 27,297 tokens, a 37% reduction on complex research tasks.\n\n- Reduced latency : Each API round-trip requires model inference (hundreds of milliseconds to seconds). When Claude orchestrates 20+ tool calls in a single code block, you eliminate 19+ inference passes. The API handles tool execution without returning to the model each time.\n\n- Improved accuracy : By writing explicit orchestration logic, Claude makes fewer errors than when juggling multiple tool results in natural language. Internal knowledge retrieval improved from 25.6% to 28.5%; GIA benchmarks from 46.5% to 51.2%.\n\nProduction workflows involve messy data, conditional logic, and operations that need to scale. Programmatic Tool Calling lets Claude handle that complexity programmatically while keeping its focus on actionable results rather than raw data processing.\n\nHow Programmatic Tool Calling works\n\n1. Mark tools as callable from code\n\nAdd code_execution to tools, and set allowed_callers to opt-in tools for programmatic execution:\n\n```\n{\n  \"tools\": [\n    {\n      \"type\": \"code_execution_20250825\",\n      \"name\": \"code_execution\"\n    },\n    {\n      \"name\": \"get_team_members\",\n      \"description\": \"Get all members of a department...\",\n      \"input_schema\": {...},\n      \"allowed_callers\": [\"code_execution_20250825\"] # opt-in to programmatic tool calling\n    },\n    {\n      \"name\": \"get_expenses\",\n \t...\n    },\n    {\n      \"name\": \"get_budget_by_level\",\n\t...\n    }\n  ]\n}\n```\n\nThe API converts these tool definitions into Python functions that Claude can call.\n\n2. Claude writes orchestration code\n\nInstead of requesting tools one at a time, Claude generates Python code:\n\n```\n{\n  \"type\": \"server_tool_use\",\n  \"id\": \"srvtoolu_abc\",\n  \"name\": \"code_execution\",\n  \"input\": {\n    \"code\": \"team = get_team_members('engineering')\\n...\" # the code example above\n  }\n}\n```\n\n3. Tools execute without hitting Claude's context\n\nWhen the code calls get_expenses(), you receive a tool request with a caller field:\n\n```\n{\n  \"type\": \"tool_use\",\n  \"id\": \"toolu_xyz\",\n  \"name\": \"get_expenses\",\n  \"input\": {\"user_id\": \"emp_123\", \"quarter\": \"Q3\"},\n  \"caller\": {\n    \"type\": \"code_execution_20250825\",\n    \"tool_id\": \"srvtoolu_abc\"\n  }\n}\n```\n\nYou provide the result, which is processed in the Code Execution environment rather than Claude's context. This request-response cycle repeats for each tool call in the code.\n\n4. Only final output enters context\n\nWhen the code finishes running, only the results of the code are returned to Claude:\n\n```\n{\n  \"type\": \"code_execution_tool_result\",\n  \"tool_use_id\": \"srvtoolu_abc\",\n  \"content\": {\n    \"stdout\": \"[{\\\"name\\\": \\\"Alice\\\", \\\"spent\\\": 12500, \\\"limit\\\": 10000}...]\"\n  }\n}\n```\n\nThis is all Claude sees, not the 2000+ expense line items processed along the way.\n\nWhen to use Programmatic Tool Calling\n\nProgrammatic Tool Calling adds a code execution step to your workflow. This extra overhead pays off when the token savings, latency improvements, and accuracy gains are substantial.\n\nMost beneficial when:\n\n- Processing large datasets where you only need aggregates or summaries\n\n- Running multi-step workflows with three or more dependent tool calls\n\n- Filtering, sorting, or transforming tool results before Claude sees them\n\n- Handling tasks where intermediate data shouldn't influence Claude's reasoning\n\n- Running parallel operations across many items (checking 50 endpoints, for example)\n\nLess beneficial when:\n\n- Making simple single-tool invocations\n\n- Working on tasks where Claude should see and reason about all intermediate results\n\n- Running quick lookups with small responses\n\nTool Use Examples\n\nThe challenge\n\nJSON Schema excels at defining structure-types, required fields, allowed enums-but it can't express usage patterns: when to include optional parameters, which combinations make sense, or what conventions your API expects.\n\nConsider a support ticket API:\n\n```\n{\n  \"name\": \"create_ticket\",\n  \"input_schema\": {\n    \"properties\": {\n      \"title\": {\"type\": \"string\"},\n      \"priority\": {\"enum\": [\"low\", \"medium\", \"high\", \"critical\"]},\n      \"labels\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n      \"reporter\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\"type\": \"string\"},\n          \"name\": {\"type\": \"string\"},\n          \"contact\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"email\": {\"type\": \"string\"},\n              \"phone\": {\"type\": \"string\"}\n            }\n          }\n        }\n      },\n      \"due_date\": {\"type\": \"string\"},\n      \"escalation\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"level\": {\"type\": \"integer\"},\n          \"notify_manager\": {\"type\": \"boolean\"},\n          \"sla_hours\": {\"type\": \"integer\"}\n        }\n      }\n    },\n    \"required\": [\"title\"]\n  }\n}\n```\n\nThe schema defines what's valid, but leaves critical questions unanswered:\n\n- Format ambiguity: Should due_date use \"2024-11-06\", \"Nov 6, 2024\", or \"2024-11-06T00:00:00Z\"?\n\n- ID conventions: Is reporter.id a UUID, \"USR-12345\", or just \"12345\"?\n\n- Nested structure usage: When should Claude populate reporter.contact ?\n\n- Parameter correlations: How do escalation.level and escalation.sla_hours relate to priority?\n\nThese ambiguities can lead to malformed tool calls and inconsistent parameter usage.\n\nOur solution\n\nTool Use Examples let you provide sample tool calls directly in your tool definitions. Instead of relying on schema alone, you show Claude concrete usage patterns:\n\n```\n{\n    \"name\": \"create_ticket\",\n    \"input_schema\": { /* same schema as above */ },\n    \"input_examples\": [\n      {\n        \"title\": \"Login page returns 500 error\",\n        \"priority\": \"critical\",\n        \"labels\": [\"bug\", \"authentication\", \"production\"],\n        \"reporter\": {\n          \"id\": \"USR-12345\",\n          \"name\": \"Jane Smith\",\n          \"contact\": {\n            \"email\": \"jane@acme.com\",\n            \"phone\": \"+1-555-0123\"\n          }\n        },\n        \"due_date\": \"2024-11-06\",\n        \"escalation\": {\n          \"level\": 2,\n          \"notify_manager\": true,\n          \"sla_hours\": 4\n        }\n      },\n      {\n        \"title\": \"Add dark mode support\",\n        \"labels\": [\"feature-request\", \"ui\"],\n        \"reporter\": {\n          \"id\": \"USR-67890\",\n          \"name\": \"Alex Chen\"\n        }\n      },\n      {\n        \"title\": \"Update API documentation\"\n      }\n    ]\n  }\n```\n\nFrom these three examples, Claude learns:\n\n- Format conventions : Dates use YYYY-MM-DD, user IDs follow USR-XXXXX, labels use kebab-case\n\n- Nested structure patterns : How to construct the reporter object with its nested contact object\n\n- Optional parameter correlations : Critical bugs have full contact info + escalation with tight SLAs; feature requests have reporter but no contact/escalation; internal tasks have title only\n\nIn our own internal testing, tool use examples improved accuracy from 72% to 90% on complex parameter handling.\n\nWhen to use Tool Use Examples\n\nTool Use Examples add tokens to your tool definitions, so they're most valuable when accuracy improvements outweigh the additional cost.\n\nMost beneficial when:\n\n- Complex nested structures where valid JSON doesn't imply correct usage\n\n- Tools with many optional parameters and inclusion patterns matter\n\n- APIs with domain-specific conventions not captured in schemas\n\n- Similar tools where examples clarify which one to use (e.g., create_ticket vs create_incident )\n\nLess beneficial when:\n\n- Simple single-parameter tools with obvious usage\n\n- Standard formats like URLs or emails that Claude already understands\n\n- Validation concerns better handled by JSON Schema constraints\n\nBest practices\n\nBuilding agents that take real-world actions means handling scale, complexity, and precision simultaneously. These three features work together to solve different bottlenecks in tool use workflows. Here's how to combine them effectively.\n\nLayer features strategically\n\nNot every agent needs to use all three features for a given task. Start with your biggest bottleneck:\n\n- Context bloat from tool definitions Tool Search Tool\n\n- Large intermediate results polluting context Programmatic Tool Calling\n\n- Parameter errors and malformed calls Tool Use Examples\n\nThis focused approach lets you address the specific constraint limiting your agent's performance, rather than adding complexity upfront.\n\nThen layer additional features as needed. They're complementary: Tool Search Tool ensures the right tools are found, Programmatic Tool Calling ensures efficient execution, and Tool Use Examples ensure correct invocation.\n\nSet up Tool Search Tool for better discovery\n\nTool search matches against names and descriptions, so clear, descriptive definitions improve discovery accuracy.\n\n```\n// Good\n{\n    \"name\": \"search_customer_orders\",\n    \"description\": \"Search for customer orders by date range, status, or total amount. Returns order details including items, shipping, and payment info.\"\n}\n\n// Bad\n{\n    \"name\": \"query_db_orders\",\n    \"description\": \"Execute order query\"\n}\n```\n\nAdd system prompt guidance so Claude knows what's available:\n\n```\nYou have access to tools for Slack messaging, Google Drive file management, \nJira ticket tracking, and GitHub repository operations. Use the tool search \nto find specific capabilities.\n```\n\nKeep your three to five most-used tools always loaded, defer the rest. This balances immediate access for common operations with on-demand discovery for everything else.\n\nSet up Programmatic Tool Calling for correct execution\n\nSince Claude writes code to parse tool outputs, document return formats clearly. This helps Claude write correct parsing logic:\n\n```\n{\n    \"name\": \"get_orders\",\n    \"description\": \"Retrieve orders for a customer.\nReturns:\n    List of order objects, each containing:\n    - id (str): Order identifier\n    - total (float): Order total in USD\n    - status (str): One of 'pending', 'shipped', 'delivered'\n    - items (list): Array of {sku, quantity, price}\n    - created_at (str): ISO 8601 timestamp\"\n}\n```\n\nSee below for opt-in tools that benefit from programmatic orchestration:\n\n- Tools that can run in parallel (independent operations)\n\n- Operations safe to retry (idempotent)\n\nSet up Tool Use Examples for parameter accuracy\n\nCraft examples for behavioral clarity:\n\n- Use realistic data (real city names, plausible prices, not \"string\" or \"value\")\n\n- Show variety with minimal, partial, and full specification patterns\n\n- Keep it concise: 1-5 examples per tool\n\n- Focus on ambiguity (only add examples where correct usage isn't obvious from schema)\n\nGetting started\n\nThese features are available in beta. To enable them, add the beta header and include the tools you need:\n\n```\nclient.beta.messages.create(\n    betas=[\"advanced-tool-use-2025-11-20\"],\n    model=\"claude-sonnet-4-5-20250929\",\n    max_tokens=4096,\n    tools=[\n        {\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n        {\"type\": \"code_execution_20250825\", \"name\": \"code_execution\"},\n        # Your tools with defer_loading, allowed_callers, and input_examples\n    ]\n)\n```\n\nFor detailed API documentation and SDK examples, see our:\n\n- D ocumentation and cookbook for Tool Search Tool\n\n- Documentation and cookbook for Programmatic Tool Calling\n\n- Documentation for Tool Use Examples\n\nThese features move tool use from simple function calling toward intelligent orchestration. As agents tackle more complex workflows spanning dozens of tools and large datasets, dynamic discovery, efficient execution, and reliable invocation become foundational.\n\nWe're excited to see what you build.\n\nAcknowledgements\n\nWritten by Bin Wu, with contributions from Adam Jones, Artur Renault, Henry Tay, Jake Noble, Nathan McCandlish, Noah Picard, Sam Jiang, and the Claude Developer Platform team. This work builds on foundational research by Chris Gorgolewski, Daniel Jiang, Jeremy Fox and Mike Lambert. We also drew inspiration from across the AI ecosystem, including Joel Pobar's LLMVM , Cloudflare's Code Mode and Code Execution as MCP . Special thanks to Andy Schumeister, Hamish Kerr, Keir Bradwell, Matt Bleifer and Molly Vorwerck for their support.",
    "images": [
      "https://www-cdn.anthropic.com/images/4zrzovbb/website/151600be7f9c23247aad8dcb6aacb2e1ab024f44-1000x1000.svg",
      "https://www-cdn.anthropic.com/images/4zrzovbb/website/f359296f770706608901eadaffbff4ca0b67874c-1999x1125.png",
      "https://www-cdn.anthropic.com/images/4zrzovbb/website/65737d69a3290ed5c1f3c3b8dc873645a9dcc2eb-1999x1491.png"
    ]
  },
  "translations": {
    "es": {
      "title": "Presentamos el uso avanzado de herramientas en Claude Developer Platform",
      "content": "El futuro de los agentes de IA es uno en el que los modelos funcionen a la perfección en cientos o miles de herramientas.Un asistente IDE que integra operaciones de git, manipulación de archivos, administradores de paquetes, marcos de prueba y canales de implementación.Un coordinador de operaciones que conecta Slack, GitHub, Google Drive, Jira, bases de datos de la empresa y decenas de servidores MCP simultáneamente.\n\nPara crear agentes eficaces, necesitan trabajar con bibliotecas de herramientas ilimitadas sin meter cada definición en contexto desde el principio.Nuestro artículo de blog sobre el uso de la ejecución de código con MCP analiza cómo los resultados y las definiciones de las herramientas a veces pueden consumir más de 50 000 tokens antes de que un agente lea una solicitud.Los agentes deben descubrir y cargar herramientas según demanda, conservando solo lo que sea relevante para la tarea actual.\n\nLos agentes también necesitan la capacidad de llamar herramientas desde el código.Cuando se utilizan llamadas a herramientas de lenguaje natural, cada invocación requiere un pase de inferencia completo y los resultados intermedios se acumulan en contexto, sean útiles o no.El código es una opción natural para la lógica de orquestación, como bucles, condicionales y transformaciones de datos.Los agentes necesitan flexibilidad para elegir entre ejecución de código e inferencia según la tarea en cuestión.\n\nLos agentes también necesitan aprender el uso correcto de las herramientas a partir de ejemplos, no solo de definiciones de esquemas.Los esquemas JSON definen lo que es estructuralmente válido, pero no pueden expresar patrones de uso: cuándo incluir parámetros opcionales, qué combinaciones tienen sentido o qué convenciones espera su API.\n\nHoy lanzamos tres funciones que lo hacen posible:\n\n- Herramienta de búsqueda de herramientas, que permite a Claude utilizar herramientas de búsqueda para acceder a miles de herramientas sin consumir su ventana contextual.\n\n- Llamada programática a herramientas, que permite a Claude invocar herramientas en un entorno de ejecución de código, lo que reduce el impacto en la ventana contextual del modelo.\n\n- Ejemplos de uso de herramientas, que proporciona un estándar universal para demostrar cómo utilizar eficazmente una herramienta determinada.\n\nEn pruebas internas, descubrimos que estas características nos han ayudado a crear cosas que no hubieran sido posibles con los patrones de uso de herramientas convencionales.Por ejemplo, Claude para Excel utiliza llamadas a herramientas programáticas para leer y modificar hojas de cálculo con miles de filas sin sobrecargar la ventana contextual del modelo.\n\nSegún nuestra experiencia, creemos que estas características abren nuevas posibilidades para lo que puede crear con Claude.\n\nHerramienta de búsqueda de herramientas\n\nEl desafío\n\nLas definiciones de las herramientas MCP proporcionan un contexto importante, pero a medida que se conectan más servidores, esos tokens pueden acumularse.Considere una configuración de cinco servidores:\n\n- GitHub: 35 herramientas (~26.000 tokens)\n\n- Slack: 11 herramientas (~21.000 tokens)\n\n- Sentry: 5 herramientas (~3K tokens)\n\n- Grafana: 5 herramientas (~3K tokens)\n\n- Splunk: 2 herramientas (~2K tokens)\n\nSon 58 herramientas que consumen aproximadamente 55.000 tokens incluso antes de que comience la conversación.Agregue más servidores como Jira (que por sí solo usa ~17.000 tokens) y se acercará rápidamente a una sobrecarga de tokens de más de 100.000.En Anthropic, hemos visto que las definiciones de herramientas consumen 134.000 tokens antes de la optimización.\n\nPero el costo simbólico no es el único problema.Las fallas más comunes son la selección incorrecta de herramientas y parámetros incorrectos, especialmente cuando las herramientas tienen nombres similares como notificación-envío-usuario versus notificación-envío-canal.\n\nNuestra solución\n\nEn lugar de cargar todas las definiciones de herramientas por adelantado, la herramienta de búsqueda de herramientas descubre herramientas a pedido.Claude sólo ve las herramientas que realmente necesita para la tarea actual.\n\n[[IMAGE_1|La herramienta de búsqueda conserva 191.300 tokens de contexto en comparación con los 122.800 del enfoque tradicional de Claude.]]\n\nEnfoque tradicional:\n\n- Todas las definiciones de herramientas cargadas por adelantado (~72.000 tokens para más de 50 herramientas MCP)\n\n- El historial de conversaciones y el mensaje del sistema compiten por el espacio restante\n\n- Consumo total de contexto: ~77.000 tokens antes de que comience cualquier trabajo\n\nCon la herramienta de búsqueda de herramientas:\n\n- Solo la herramienta de búsqueda de herramientas se carga por adelantado (~500 tokens)\n\n- Herramientas descubiertas bajo demanda según sea necesario (3-5 herramientas relevantes, ~3K tokens)\n\n- Consumo total de contexto: ~8.7K tokens, preservando el 95% de la ventana de contexto\n\nEsto representa una reducción del 85 % en el uso de tokens y al mismo tiempo mantiene el acceso a su biblioteca completa de herramientas.Las pruebas internas mostraron mejoras significativas en la precisión de las evaluaciones de MCP cuando se trabaja con grandes bibliotecas de herramientas.Opus 4 mejoró del 49% al 74%, y Opus 4.5 mejoró del 79,5% al ​​88,1% con la herramienta de búsqueda habilitada.\n\nCómo funciona la herramienta de búsqueda de herramientas La herramienta de búsqueda de herramientas le permite a Claude descubrir herramientas dinámicamente en lugar de cargar todas las definiciones por adelantado.Usted proporciona todas las definiciones de sus herramientas a la API, pero marca las herramientas con defer_loading: true para que sean reconocibles bajo demanda.Las herramientas diferidas no se cargan inicialmente en el contexto de Claude.Claude solo ve la herramienta de búsqueda de herramientas más cualquier herramienta con defer_loading: false (sus herramientas más importantes y de uso más frecuente).\n\nCuando Claude necesita capacidades específicas, busca herramientas relevantes.La herramienta de búsqueda de herramientas devuelve referencias a herramientas coincidentes, que se amplían a definiciones completas en el contexto de Claude.\n\nPor ejemplo, si Claude necesita interactuar con GitHub, busca \"github\" y solo se cargan github.createPullRequest y github.listIssues, no las otras más de 50 herramientas de Slack, Jira y Google Drive.\n\nDe esta manera, Claude tiene acceso a su biblioteca completa de herramientas y solo paga el costo simbólico de las herramientas que realmente necesita.\n\nNota sobre el almacenamiento en caché de mensajes: la herramienta de búsqueda de herramientas no interrumpe el almacenamiento en caché de mensajes porque las herramientas diferidas se excluyen por completo del mensaje inicial.Solo se agregan al contexto después de que Claude los busca, por lo que las definiciones de las herramientas principales y del sistema se pueden almacenar en caché.\n\nImplementación:\n\n```\n{\n\"herramientas\": [\n// Incluir una herramienta de búsqueda de herramientas (regex, BM25 o personalizada)\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nombre\": \"tool_search_tool_regex\"},\n\n// Marcar herramientas para descubrimiento bajo demanda\n{\n\"nombre\": \"github.createPullRequest\",\n\"description\": \"Crear una solicitud de extracción\",\n\"esquema_entrada\": {...},\n\"defer_loading\": verdadero\n}\n// ... cientos de herramientas más diferidas con defer_loading: true\n]\n}\n```\n\nPara servidores MCP, puede diferir la carga de servidores completos mientras mantiene cargadas herramientas específicas de alto uso:\n\n```\n{\n\"tipo\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-drive\",\n\"default_config\": {\"defer_loading\": true}, # posponer la carga de todo el servidor\n\"configuraciones\": {\n\"archivos_de búsqueda\": {\n\"defer_loading\": falso\n} // Mantiene cargada la herramienta más utilizada\n}\n}\n```\n\nClaude Developer Platform proporciona herramientas de búsqueda listas para usar basadas en expresiones regulares y basadas en BM25, pero también puede implementar herramientas de búsqueda personalizadas mediante incrustaciones u otras estrategias.\n\nCuándo utilizar la herramienta de búsqueda de herramientas\n\nComo cualquier decisión arquitectónica, habilitar la herramienta de búsqueda de herramientas implica compensaciones.La característica agrega un paso de búsqueda antes de la invocación de la herramienta, por lo que ofrece el mejor retorno de la inversión cuando los ahorros de contexto y las mejoras de precisión superan la latencia adicional.\n\nÚselo cuando:\n\n- Definiciones de herramientas que consumen >10K tokens\n\n- Experimentar problemas de precisión en la selección de herramientas\n\n- Creación de sistemas impulsados por MCP con múltiples servidores\n\n- Más de 10 herramientas disponibles\n\nMenos beneficioso cuando:\n\n- Pequeña biblioteca de herramientas (<10 herramientas)\n\n- Todas las herramientas utilizadas con frecuencia en cada sesión.\n\n- Las definiciones de herramientas son compactas.\n\nLlamada a herramientas programáticas\n\nEl desafío\n\nLa llamada a herramientas tradicionales crea dos problemas fundamentales a medida que los flujos de trabajo se vuelven más complejos:\n\n- Contaminación del contexto a partir de resultados intermedios: cuando Claude analiza un archivo de registro de 10 MB en busca de patrones de error, el archivo completo ingresa a su ventana de contexto, aunque Claude solo necesita un resumen de las frecuencias de error.Al recuperar datos de clientes en varias tablas, cada registro se acumula en contexto independientemente de su relevancia.Estos resultados intermedios consumen presupuestos simbólicos masivos y pueden sacar información importante fuera de la ventana contextual por completo.\n\n- Gastos generales de inferencia y síntesis manual: cada llamada a la herramienta requiere un pase de inferencia completo del modelo.Después de recibir los resultados, Claude debe \"observar\" los datos para extraer información relevante, razonar sobre cómo encajan las piezas y decidir qué hacer a continuación, todo ello mediante el procesamiento del lenguaje natural.Un flujo de trabajo de cinco herramientas significa cinco pases de inferencia más Claude analizando cada resultado, comparando valores y sintetizando conclusiones.Esto es lento y propenso a errores.\n\nNuestra solución\n\nLa llamada de herramientas programáticas permite a Claude orquestar herramientas a través de código en lugar de mediante viajes de ida y vuelta de API individuales.En lugar de que Claude solicite herramientas una a la vez y cada resultado se devuelva a su contexto, Claude escribe código que llama a múltiples herramientas, procesa sus resultados y controla qué información realmente ingresa a su ventana de contexto. Claude se destaca en la escritura de código y, al permitirle expresar la lógica de orquestación en Python en lugar de a través de invocaciones de herramientas de lenguaje natural, se obtiene un flujo de control más confiable y preciso.Los bucles, los condicionales, las transformaciones de datos y el manejo de errores están todos explícitos en el código y no implícitos en el razonamiento de Claude.\n\nEjemplo: control de cumplimiento presupuestario\n\nConsidere una tarea empresarial común: \"¿Qué miembros del equipo excedieron su presupuesto de viaje para el tercer trimestre?\"\n\nTienes tres herramientas disponibles:\n\n- get_team_members(departamento) - Devuelve la lista de miembros del equipo con ID y niveles\n\n- get_expenses(user_id, quarter): devuelve partidas de gastos para un usuario\n\n- get_budget_by_level(nivel): devuelve los límites de presupuesto para un nivel de empleado\n\nEnfoque tradicional:\n\n- Buscar miembros del equipo 20 personas.\n\n- Para cada persona, obtenga sus gastos del tercer trimestre con 20 llamadas de herramientas, cada una de las cuales devolverá entre 50 y 100 partidas (vuelos, hoteles, comidas, recibos).\n\n- Obtener límites de presupuesto por nivel de empleado\n\n- Todo esto entra en el contexto de Claude: más de 2000 partidas de gastos (50 KB+)\n\n- Claude suma manualmente los gastos de cada persona, busca su presupuesto y compara los gastos con los límites presupuestarios.\n\n- Más viajes de ida y vuelta al modelo, consumo de contexto significativo\n\nCon llamadas de herramientas programáticas:\n\nEn lugar de que el resultado de cada herramienta regrese a Claude, Claude escribe un script en Python que organiza todo el flujo de trabajo.El script se ejecuta en la herramienta de ejecución de código (un entorno de espacio aislado) y se detiene cuando necesita resultados de sus herramientas.Cuando devuelve resultados de herramientas a través de la API, el script los procesa en lugar de consumirlos el modelo.El guión continúa ejecutándose y Claude solo ve el resultado final.\n\n[[IMAGE_2|La llamada a herramientas programáticas permite a Claude orquestar herramientas a través de código en lugar de a través de recorridos de ida y vuelta de API individuales, lo que permite la ejecución de herramientas en paralelo.]]\n\nAsí es como se ve el código de orquestación de Claude para la tarea de cumplimiento presupuestario:\n\n```\nequipo = await get_team_members(\"ingeniería\")\n\n# Obtener presupuestos para cada nivel único\nniveles = lista(set(m[\"nivel\"] para m en el equipo))\npresupuesto_resultados = esperar asyncio.gather(*[\nget_budget_by_level(nivel) para nivel en niveles\n])\n\n# Crear un diccionario de búsqueda: {\"junior\": presupuesto1, \"senior\": presupuesto2, ...}\npresupuestos = {nivel: presupuesto por nivel, presupuesto en zip(niveles, presupuesto_resultados)}\n\n# Recuperar todos los gastos en paralelo\ngastos = esperar asyncio.gather(*[\nget_expenses(m[\"id\"], \"Q3\") para m en el equipo\n])\n\n# Encuentre empleados que excedieron su presupuesto de viaje\nsuperado = []\npara miembro, exp en zip (equipo, gastos):\npresupuesto = presupuestos[miembro[\"nivel\"]]\ntotal = suma(e[\"cantidad\"] para e en exp)\nsi total > presupuesto[\"limite_viaje\"]:\nsuperado.append({\n\"nombre\": miembro[\"nombre\"],\n\"gastado\": total,\n\"límite\": presupuesto[\"travel_limit\"]\n})\n\nprint(json.dumps(excedido))\n```\n\nEl contexto de Claude sólo recibe el resultado final: las dos o tres personas que excedieron su presupuesto.Las más de 2000 partidas, las sumas intermedias y las búsquedas de presupuesto no afectan el contexto de Claude, lo que reduce el consumo de 200 KB de datos de gastos sin procesar a solo 1 KB de resultados.\n\nLas ganancias de eficiencia son sustanciales:\n\n- Ahorro de tokens: al mantener los resultados intermedios fuera del contexto de Claude, PTC reduce drásticamente el consumo de tokens.El uso promedio cayó de 43.588 a 27.297 tokens, una reducción del 37% en tareas de investigación complejas.\n\n- Latencia reducida: cada ida y vuelta de API requiere inferencia del modelo (cientos de milisegundos a segundos).Cuando Claude organiza más de 20 llamadas a herramientas en un solo bloque de código, elimina más de 19 pases de inferencia.La API maneja la ejecución de la herramienta sin volver al modelo cada vez.\n\n- Precisión mejorada: al escribir una lógica de orquestación explícita, Claude comete menos errores que cuando hace malabarismos con los resultados de varias herramientas en lenguaje natural.La recuperación interna de conocimientos mejoró del 25,6% al 28,5%;Los puntos de referencia del GIA pasaron del 46,5% al ​​51,2%.\n\nLos flujos de trabajo de producción implican datos desordenados, lógica condicional y operaciones que deben escalarse.La llamada a herramientas programáticas le permite a Claude manejar esa complejidad mediante programación mientras mantiene su enfoque en resultados procesables en lugar del procesamiento de datos sin procesar.\n\nCómo funciona la llamada a herramientas programáticas\n\n1. Marcar herramientas como invocables desde el código\n\nAgregue code_execution a las herramientas y configure Allow_callers para que opten por herramientas para la ejecución programática: ```\n{\n\"herramientas\": [\n{\n\"tipo\": \"code_execution_20250825\",\n\"nombre\": \"código_ejecución\"\n},\n{\n\"nombre\": \"get_team_members\",\n\"description\": \"Obtener todos los miembros de un departamento...\",\n\"esquema_entrada\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # optar por la llamada a herramientas programáticas\n},\n{\n\"nombre\": \"obtener_gastos\",\n...\n},\n{\n\"nombre\": \"obtener_presupuesto_por_nivel\",\n...\n}\n]\n}\n```\n\nLa API convierte estas definiciones de herramientas en funciones de Python que Claude puede llamar.\n\n2. Claude escribe código de orquestación\n\nEn lugar de solicitar herramientas una por una, Claude genera código Python:\n\n```\n{\n\"tipo\": \"server_tool_use\",\n\"id\": \"srvtoolu_abc\",\n\"nombre\": \"código_ejecución\",\n\"entrada\": {\n\"code\": \"team = get_team_members('ingeniería')\\n...\" # el ejemplo de código anterior\n}\n}\n```\n\n3. Las herramientas se ejecutan sin afectar el contexto de Claude\n\nCuando el código llama a get_expenses(), recibe una solicitud de herramienta con un campo de llamada:\n\n```\n{\n\"tipo\": \"uso_herramienta\",\n\"id\": \"toolu_xyz\",\n\"nombre\": \"obtener_gastos\",\n\"input\": {\"user_id\": \"emp_123\", \"trimestre\": \"Q3\"},\n\"persona que llama\": {\n\"tipo\": \"code_execution_20250825\",\n\"tool_id\": \"srvtoolu_abc\"\n}\n}\n```\n\nUsted proporciona el resultado, que se procesa en el entorno de ejecución de código en lugar del contexto de Claude.Este ciclo de solicitud-respuesta se repite para cada llamada a herramienta en el código.\n\n4. Sólo el resultado final entra en contexto\n\nCuando el código termina de ejecutarse, solo se devuelven a Claude los resultados del código:\n\n```\n{\n\"tipo\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"contenido\": {\n\"stdout\": \"[{\\\"nombre\\\": \\\"Alice\\\", \\\"gastado\\\": 12500, \\\"límite\\\": 10000}....]\"\n}\n}\n```\n\nEsto es todo lo que ve Claude, no las más de 2000 partidas de gastos procesadas en el camino.\n\nCuándo utilizar las llamadas a herramientas programáticas\n\nLa llamada a herramientas programáticas agrega un paso de ejecución de código a su flujo de trabajo.Esta sobrecarga adicional vale la pena cuando el ahorro de tokens, las mejoras de latencia y las ganancias en precisión son sustanciales.\n\nMás beneficioso cuando:\n\n- Procesamiento de grandes conjuntos de datos donde solo se necesitan agregados o resúmenes\n\n- Ejecutar flujos de trabajo de varios pasos con tres o más llamadas de herramientas dependientes\n\n- Filtrar, ordenar o transformar los resultados de las herramientas antes de que Claude los vea.\n\n- Manejar tareas donde los datos intermedios no deberían influir en el razonamiento de Claude.\n\n- Ejecutar operaciones paralelas en muchos elementos (comprobar 50 puntos finales, por ejemplo)\n\nMenos beneficioso cuando:\n\n- Realizar invocaciones simples con una sola herramienta.\n\n- Trabajar en tareas donde Claude debería ver y razonar sobre todos los resultados intermedios.\n\n- Realizar búsquedas rápidas con pequeñas respuestas.\n\nEjemplos de uso de herramientas\n\nEl desafío\n\nJSON Schema se destaca en la definición de tipos de estructuras, campos obligatorios, enumeraciones permitidas, pero no puede expresar patrones de uso: cuándo incluir parámetros opcionales, qué combinaciones tienen sentido o qué convenciones espera su API.\n\nConsidere una API de ticket de soporte:\n\n```\n{\n\"nombre\": \"create_ticket\",\n\"esquema_entrada\": {\n\"propiedades\": {\n\"título\": {\"tipo\": \"cadena\"},\n\"prioridad\": {\"enum\": [\"baja\", \"media\", \"alta\", \"crítica\"]},\n\"etiquetas\": {\"tipo\": \"matriz\", \"elementos\": {\"tipo\": \"cadena\"}},\n\"reportero\": {\n\"tipo\": \"objeto\",\n\"propiedades\": {\n\"id\": {\"tipo\": \"cadena\"},\n\"nombre\": {\"tipo\": \"cadena\"},\n\"contacto\": {\n\"tipo\": \"objeto\",\n\"propiedades\": {\n\"correo electrónico\": {\"tipo\": \"cadena\"},\n\"teléfono\": {\"tipo\": \"cadena\"}\n}\n}\n}\n},\n\"fecha_de vencimiento\": {\"tipo\": \"cadena\"},\n\"escalada\": {\n\"tipo\": \"objeto\",\n\"propiedades\": {\n\"nivel\": {\"tipo\": \"entero\"},\n\"notify_manager\": {\"tipo\": \"booleano\"},\n\"sla_hours\": {\"tipo\": \"entero\"}\n}\n}\n},\n\"requerido\": [\"título\"]\n}\n}\n```\n\nEl esquema define lo que es válido, pero deja preguntas críticas sin respuesta:\n\n- Ambigüedad de formato: ¿la fecha de vencimiento debería usar \"2024-11-06\", \"6 de noviembre de 2024\" o \"2024-11-06T00:00:00Z\"?\n\n- Convenciones de identificación: ¿reporter.id es un UUID, \"USR-12345\" o simplemente \"12345\"?\n\n- Uso de estructura anidada: ¿Cuándo debería Claude completar reporter.contact?\n\n- Correlaciones de parámetros: ¿Cómo se relacionan escalation.level y escalation.sla_hours con la prioridad?\n\nEstas ambigüedades pueden provocar llamadas a herramientas con formato incorrecto y un uso inconsistente de parámetros.\n\nNuestra solución\n\nLos ejemplos de uso de herramientas le permiten proporcionar llamadas de herramientas de muestra directamente en sus definiciones de herramientas.En lugar de confiar únicamente en el esquema, le muestra a Claude patrones de uso concretos: ```\n{\n\"nombre\": \"create_ticket\",\n\"input_schema\": { /* mismo esquema que el anterior */ },\n\"ejemplos_entrada\": [\n{\n\"title\": \"La página de inicio de sesión devuelve un error 500\",\n\"prioridad\": \"crítica\",\n\"etiquetas\": [\"error\", \"autenticación\", \"producción\"],\n\"reportero\": {\n\"identificación\": \"USR-12345\",\n\"nombre\": \"Jane Smith\",\n\"contacto\": {\n\"correo electrónico\": \"jane@acme.com\",\n\"teléfono\": \"+1-555-0123\"\n}\n},\n\"fecha_de vencimiento\": \"2024-11-06\",\n\"escalada\": {\n\"nivel\": 2,\n\"notify_manager\": verdadero,\n\"horas_sla\": 4\n}\n},\n{\n\"title\": \"Añadir compatibilidad con el modo oscuro\",\n\"etiquetas\": [\"solicitud de función\", \"ui\"],\n\"reportero\": {\n\"identificación\": \"USR-67890\",\n\"nombre\": \"Alex Chen\"\n}\n},\n{\n\"title\": \"Actualizar la documentación de la API\"\n}\n]\n}\n```\n\nDe estos tres ejemplos, Claude aprende:\n\n- Convenciones de formato: las fechas usan AAAA-MM-DD, los ID de usuario siguen USR-XXXXX, las etiquetas usan kebab-case\n\n- Patrones de estructura anidada: cómo construir el objeto reportero con su objeto de contacto anidado\n\n- Correlaciones de parámetros opcionales: los errores críticos tienen información de contacto completa + escalamiento con SLA estrictos;las solicitudes de funciones tienen reportero pero no contacto/escalada;Las tareas internas solo tienen título.\n\nEn nuestras propias pruebas internas, los ejemplos de uso de herramientas mejoraron la precisión del 72 % al 90 % en el manejo de parámetros complejos.\n\nCuándo utilizar ejemplos de uso de herramientas\n\nLos ejemplos de uso de herramientas agregan tokens a las definiciones de herramientas, por lo que son más valiosos cuando las mejoras en la precisión superan el costo adicional.\n\nMás beneficioso cuando:\n\n- Estructuras anidadas complejas donde JSON válido no implica un uso correcto\n\n- Las herramientas con muchos parámetros opcionales y patrones de inclusión son importantes\n\n- API con convenciones específicas de dominio no capturadas en esquemas\n\n- Herramientas similares donde los ejemplos aclaran cuál usar (por ejemplo, create_ticket vs create_incident)\n\nMenos beneficioso cuando:\n\n- Herramientas simples de un solo parámetro con uso obvio\n\n- Formatos estándar como URL o correos electrónicos que Claude ya comprende.\n\n- Los problemas de validación se manejan mejor mediante restricciones del esquema JSON.\n\nMejores prácticas\n\nCrear agentes que tomen acciones en el mundo real significa manejar la escala, la complejidad y la precisión simultáneamente.Estas tres características trabajan juntas para resolver diferentes cuellos de botella en los flujos de trabajo de uso de herramientas.A continuación se explica cómo combinarlos de forma eficaz.\n\nCapa de características estratégicamente\n\nNo todos los agentes necesitan utilizar las tres funciones para una tarea determinada.Comience con su mayor cuello de botella:\n\n- Inflación de contexto debido a las definiciones de herramientas Herramienta de búsqueda\n\n- Grandes resultados intermedios contaminan el contexto Llamada a herramientas programáticas\n\n- Errores de parámetros y llamadas con formato incorrecto. Ejemplos de uso de herramientas.\n\nEste enfoque enfocado le permite abordar la restricción específica que limita el desempeño de su agente, en lugar de agregar complejidad desde el principio.\n\nLuego, coloque capas de funciones adicionales según sea necesario.Son complementarios: la herramienta de búsqueda de herramientas garantiza que se encuentren las herramientas adecuadas, la llamada a herramientas programáticas garantiza una ejecución eficiente y los ejemplos de uso de herramientas garantizan una invocación correcta.\n\nConfigure la herramienta de búsqueda para un mejor descubrimiento\n\nLa búsqueda de herramientas coincide con nombres y descripciones, por lo que las definiciones claras y descriptivas mejoran la precisión del descubrimiento.\n\n```\n// Bueno\n{\n\"nombre\": \"search_customer_orders\",\n\"description\": \"Busca pedidos de clientes por rango de fechas, estado o monto total. Devuelve detalles del pedido, incluidos artículos, envío e información de pago.\"\n}\n\n// Malo\n{\n\"nombre\": \"query_db_orders\",\n\"description\": \"Ejecutar consulta de orden\"\n}\n```\n\nAgregue una guía rápida del sistema para que Claude sepa qué está disponible:\n\n```\nTienes acceso a herramientas de mensajería de Slack, gestión de archivos de Google Drive,\nSeguimiento de tickets de Jira y operaciones de repositorio de GitHub.Utilice la herramienta de búsqueda\npara encontrar capacidades específicas.\n```\n\nMantenga siempre cargadas sus tres a cinco herramientas más utilizadas, posponga el resto.Esto equilibra el acceso inmediato para operaciones comunes con el descubrimiento bajo demanda para todo lo demás.\n\nConfigurar llamadas a herramientas programáticas para una ejecución correcta\n\nDado que Claude escribe código para analizar los resultados de las herramientas, los formatos de devolución del documento se muestran claramente.Esto ayuda a Claude a escribir la lógica de análisis correcta: ```\n{\n\"nombre\": \"obtener_pedidos\",\n\"description\": \"Recuperar pedidos de un cliente.\nDevoluciones:\nLista de objetos de pedido, cada uno de los cuales contiene:\n- id (cadena): identificador de pedido\n- total (flotante): total del pedido en USD\n- estado (cadena): uno de 'pendiente', 'enviado', 'entregado'\n- artículos (lista): conjunto de {sku, cantidad, precio}\n- creado_at (cadena): marca de tiempo ISO 8601\"\n}\n```\n\nConsulte a continuación las herramientas de suscripción que se benefician de la orquestación programática:\n\n- Herramientas que pueden ejecutarse en paralelo (operaciones independientes)\n\n- Operaciones seguras para reintentar (idempotente)\n\nConfigurar ejemplos de uso de herramientas para la precisión de los parámetros\n\nEjemplos de manualidades para lograr claridad conductual:\n\n- Utilice datos realistas (nombres reales de ciudades, precios plausibles, no \"cadenas\" ni \"valores\")\n\n- Muestre variedad con patrones de especificación mínima, parcial y completa.\n\n- Sea conciso: de 1 a 5 ejemplos por herramienta\n\n- Centrarse en la ambigüedad (solo agregue ejemplos donde el uso correcto no sea obvio en el esquema)\n\nEmpezando\n\nEstas funciones están disponibles en versión beta.Para habilitarlos, agregue el encabezado beta e incluya las herramientas que necesita:\n\n```\ncliente.beta.mensajes.create(\nbetas=[\"uso-de-herramientas-avanzada-2025-11-20\"],\nmodelo=\"claude-sonnet-4-5-20250929\",\ntokens_max=4096,\nherramientas=[\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nombre\": \"tool_search_tool_regex\"},\n{\"tipo\": \"code_execution_20250825\", \"nombre\": \"code_execution\"},\n# Tus herramientas con defer_loading, Allow_callers y input_examples\n]\n)\n```\n\nPara obtener documentación API detallada y ejemplos de SDK, consulte nuestro:\n\n- Documentación y libro de cocina para la herramienta de búsqueda de herramientas.\n\n- Documentación y libro de recetas para llamadas de herramientas programáticas\n\n- Documentación para ejemplos de uso de herramientas.\n\nEstas características hacen que el uso de herramientas pase de una simple llamada de función a una orquestación inteligente.A medida que los agentes abordan flujos de trabajo más complejos que abarcan docenas de herramientas y grandes conjuntos de datos, el descubrimiento dinámico, la ejecución eficiente y la invocación confiable se vuelven fundamentales.\n\nEstamos emocionados de ver lo que construyes.\n\nAgradecimientos\n\nEscrito por Bin Wu, con contribuciones de Adam Jones, Artur Renault, Henry Tay, Jake Noble, Nathan McCandlish, Noah Picard, Sam Jiang y el equipo de Claude Developer Platform.Este trabajo se basa en la investigación fundamental de Chris Gorgolewski, Daniel Jiang, Jeremy Fox y Mike Lambert.También nos inspiramos en todo el ecosistema de IA, incluido LLMVM de Joel Pobar, Code Mode de Cloudflare y Code Execution como MCP.Un agradecimiento especial a Andy Schumeister, Hamish Kerr, Keir Bradwell, Matt Bleifer y Molly Vorwerck por su apoyo.",
      "edited": false
    },
    "ukr": {
      "title": "Представляємо розширене використання інструментів на платформі Claude Developer Platform",
      "content": "Майбутнє агентів штучного інтелекту — це те, де моделі безперебійно працюватимуть із сотнями чи тисячами інструментів.Помічник IDE, який інтегрує операції git, маніпуляції з файлами, менеджери пакетів, інфраструктури тестування та конвеєри розгортання.Операційний координатор, який одночасно з’єднує Slack, GitHub, Google Drive, Jira, бази даних компанії та десятки серверів MCP.\n\nЩоб створювати ефективні агенти, їм потрібно працювати з необмеженими бібліотеками інструментів, не вставляючи кожне визначення в контекст заздалегідь.У нашій статті в блозі про використання коду за допомогою MCP обговорювалося, як результати інструментів і визначення іноді можуть споживати понад 50 000 токенів, перш ніж агент прочитає запит.Агенти повинні знаходити та завантажувати інструменти на вимогу, зберігаючи лише те, що стосується поточного завдання.\n\nАгентам також потрібна можливість викликати інструменти з коду.Під час використання інструментів виклику природної мови для кожного виклику потрібен повний перехід висновку, а проміжні результати накопичуються в контексті незалежно від того, корисні вони чи ні.Код природно підходить для логіки оркестровки, такої як цикли, умови та перетворення даних.Агентам потрібна гнучкість для вибору між виконанням коду та висновком на основі поставленого завдання.\n\nАгентам також необхідно навчитися правильному використанню інструментів на прикладах, а не лише на визначеннях схем.Схеми JSON визначають, що є структурно дійсним, але не можуть виражати шаблони використання: коли включати додаткові параметри, які комбінації мають сенс або які умовності очікує ваш API.\n\nСьогодні ми випускаємо три функції, які роблять це можливим:\n\n- Інструмент пошуку інструментів, який дозволяє Клоду використовувати інструменти пошуку для доступу до тисяч інструментів, не споживаючи контекстне вікно\n\n- Programmatic Tool Calling , що дозволяє Клоду викликати інструменти в середовищі виконання коду, зменшуючи вплив на контекстне вікно моделі\n\n- Приклади використання інструментів, які надають універсальний стандарт для демонстрації того, як ефективно використовувати певний інструмент\n\nПід час внутрішнього тестування ми виявили, що ці функції допомогли нам створювати речі, які були б неможливі за стандартних моделей використання інструментів.Наприклад, Claude для Excel використовує Programmatic Tool Calling, щоб читати та змінювати електронні таблиці з тисячами рядків, не перевантажуючи контекстне вікно моделі.\n\nВиходячи з нашого досвіду, ми вважаємо, що ці функції відкривають нові можливості для того, що ви можете створити з Claude.\n\nІнструмент пошуку інструментів\n\nВиклик\n\nВизначення інструментів MCP надають важливий контекст, але в міру того, як підключається більше серверів, ці маркери можуть додаватися.Розглянемо налаштування з п’яти серверів:\n\n- GitHub: 35 інструментів (~26 тис. токенів)\n\n- Slack: 11 інструментів (~21 тис. токенів)\n\n- Вартовий: 5 інструментів (~3K жетонів)\n\n- Grafana: 5 інструментів (~3K жетонів)\n\n- Splunk: 2 інструменти (~2K жетонів)\n\nЦе 58 інструментів, які споживають приблизно 55 тисяч токенів ще до початку розмови.Додайте більше серверів, таких як Jira (який використовує ~17 тисяч токенів), і ви швидко наблизитеся до понад 100 тисяч токенів.У Anthropic ми бачили, що визначення інструментів споживають 134 тисячі токенів до оптимізації.\n\nАле вартість жетонів — не єдина проблема.Найпоширенішими помилками є неправильний вибір інструменту та неправильні параметри, особливо коли інструменти мають схожі назви, як-от notification-send-user або notification-send-channel.\n\nНаше рішення\n\nЗамість того, щоб завантажувати всі визначення інструментів заздалегідь, Інструмент пошуку інструментів знаходить інструменти за вимогою.Клод бачить лише ті інструменти, які дійсно потрібні для виконання поточного завдання.\n\n[[IMAGE_1|Інструмент пошуку інструментів зберігає 191 300 токенів контексту порівняно з 122 800 у традиційному підході Клода.]]\n\nТрадиційний підхід:\n\n- Усі визначення інструментів завантажуються заздалегідь (~72K маркерів для 50+ інструментів MCP)\n\n- Історія розмов і системна підказка змагаються за місце, що залишилося\n\n- Загальне споживання контексту: ~77 тисяч токенів до початку будь-якої роботи\n\nЗа допомогою інструменту пошуку інструментів:\n\n- Тільки інструмент пошуку інструментів завантажується заздалегідь (~500 токенів)\n\n- Інструменти, виявлені за потребою (3-5 відповідних інструментів, ~3K маркерів)\n\n- Загальне споживання контексту: ~8,7 тис. токенів, зберігаючи 95% вікна контексту\n\nЦе означає зменшення використання маркерів на 85%, зберігаючи доступ до повної бібліотеки інструментів.Внутрішнє тестування показало значне підвищення точності оцінок MCP під час роботи з великими бібліотеками інструментів.Opus 4 покращився з 49% до 74%, а Opus 4.5 покращився з 79,5% до 88,1% з увімкненим інструментом пошуку інструментів.\n\nЯк працює інструмент пошуку інструментів Інструмент пошуку інструментів дозволяє Клоду динамічно знаходити інструменти замість того, щоб завантажувати всі визначення заздалегідь.Ви надаєте всі свої визначення інструментів API, але позначаєте інструменти за допомогою defer_loading: true, щоб зробити їх доступними за запитом.Відкладені інструменти спочатку не завантажуються в контекст Клода.Клод бачить лише сам інструмент пошуку інструментів, а також будь-які інструменти з defer_loading: false (ваші найважливіші інструменти, які часто використовуються).\n\nКоли Клоду потрібні певні можливості, він шукає відповідні інструменти.Інструмент пошуку інструментів повертає посилання на відповідні інструменти, які розширюються до повних визначень у контексті Клода.\n\nНаприклад, якщо Клоду потрібно взаємодіяти з GitHub, він шукає «github», і завантажуються лише github.createPullRequest і github.listIssues, а не інші понад 50 ваших інструментів із Slack, Jira та Google Drive.\n\nТаким чином, Клод отримує доступ до вашої повної бібліотеки інструментів, сплачуючи лише символічну вартість інструментів, які йому дійсно потрібні.\n\nПримітка щодо кешування підказок: Інструмент пошуку інструментів не порушує кешування підказок, оскільки відкладені інструменти повністю виключаються з початкової підказки.Вони додаються до контексту лише після того, як Клод їх шукає, тому ваші системні підказки та визначення основних інструментів залишаються кешованими.\n\nРеалізація:\n\n```\n{\n\"інструменти\": [\n// Включаємо інструмент пошуку інструментів (регулярний вираз, BM25 або спеціальний)\n{\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n\n// Позначити інструменти для виявлення на вимогу\n{\n\"ім'я\": \"github.createPullRequest\",\n\"description\": \"Створити запит на отримання\",\n\"вхідна_схема\": {...},\n\"defer_loading\": правда\n}\n// ... ще сотні відкладених інструментів із defer_loading: true\n]\n}\n```\n\nДля серверів MCP ви можете відкласти завантаження цілих серверів, залишаючи завантаженими певні інструменти, які часто використовуються:\n\n```\n{\n\"тип\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-диск\",\n\"default_config\": {\"defer_loading\": true}, # відкласти завантаження всього сервера\n\"конфігурації\": {\n\"пошук_файлів\": {\n\"defer_loading\": false\n} // Тримайте завантаженим інструмент, який найчастіше використовується\n}\n}\n```\n\nПлатформа Claude Developer Platform надає інструменти пошуку на основі регулярних виразів і BM25 із коробки, але ви також можете реалізувати спеціальні інструменти пошуку за допомогою вбудовування або інших стратегій.\n\nКоли використовувати інструмент пошуку інструментів\n\nЯк і будь-яке архітектурне рішення, увімкнення інструменту пошуку інструментів передбачає компроміси.Ця функція додає крок пошуку перед викликом інструменту, тому забезпечує найкращу рентабельність інвестицій, коли економія контексту та покращення точності переважують додаткову затримку.\n\nВикористовуйте його, коли:\n\n- Визначення інструментів, що споживають >10K токенів\n\n- Проблеми з точністю вибору інструменту\n\n- Створення систем на базі MCP з кількома серверами\n\n- доступні 10+ інструментів\n\nМенш корисно, коли:\n\n- Невелика бібліотека інструментів (<10 інструментів)\n\n- Усі інструменти, які часто використовуються під час кожного сеансу\n\n- Визначення інструментів є компактними\n\nПрограмний виклик інструментів\n\nВиклик\n\nТрадиційний виклик інструментів створює дві фундаментальні проблеми, оскільки робочі процеси стають складнішими:\n\n- Забруднення контексту проміжними результатами: коли Клод аналізує 10-мегабайтний файл журналу на предмет шаблонів помилок, увесь файл потрапляє у вікно контексту, навіть якщо Клоду потрібен лише підсумок частоти помилок.Під час отримання даних клієнтів у кількох таблицях кожен запис накопичується в контексті незалежно від релевантності.Ці проміжні результати споживають значні бюджети токенів і можуть повністю витіснити важливу інформацію з вікна контексту.\n\n- Накладні витрати на логічний висновок і ручний синтез: для кожного виклику інструмента потрібен повний проход логічного висновку моделі.Отримавши результати, Клод повинен «оглядати» дані, щоб отримати релевантну інформацію, міркувати про те, як частини поєднуються разом, і вирішити, що робити далі — і все це за допомогою обробки природної мови.Робочий процес із п’ятьма інструментами означає п’ять проходів висновків плюс Клод аналізує кожен результат, порівнює значення та синтезує висновки.Це повільно і схильне до помилок.\n\nНаше рішення\n\nПрограмний виклик інструментів дає змогу Клоду оркеструвати інструменти за допомогою коду, а не за допомогою окремих двосторонніх звернень API.Замість того, щоб Клод запитував інструменти по одному, повертаючи кожен результат до свого контексту, Клод пише код, який викликає кілька інструментів, обробляє їхні виходи та контролює, яка інформація фактично надходить у контекстне вікно. Клод чудово вміє писати код, і дозволяючи йому виражати логіку оркестровки в Python, а не через виклики інструментів природною мовою, ви отримуєте більш надійний і точний потік керування.Цикли, умови, перетворення даних і обробка помилок — усе це явно виражено в коді, а не приховано в міркуваннях Клода.\n\nПриклад: перевірка відповідності бюджету\n\nРозглянемо звичайне бізнес-завдання: «Хто з членів команди перевищив свій бюджет на відрядження за 3-й квартал?»\n\nУ вас є три інструменти:\n\n- get_team_members(department) - Повертає список членів команди з ідентифікаторами та рівнями\n\n- get_expenses(user_id, quarter) - Повертає позиції витрат для користувача\n\n- get_budget_by_level(level) - Повертає обмеження бюджету для рівня співробітника\n\nТрадиційний підхід:\n\n- Зберіть членів команди 20 осіб\n\n- Для кожної особи отримайте її витрати за 3 квартал 20 викликів інструментів, кожен повертає 50-100 рядків (авіаквитки, готелі, харчування, квитанції)\n\n- Отримайте обмеження бюджету за рівнем співробітника\n\n- Усе це входить у контекст Клода: понад 2000 статей витрат (50 КБ+)\n\n- Клод вручну підсумовує витрати кожної людини, шукає їхній бюджет, порівнює витрати з обмеженнями бюджету\n\n- Більше поворотів до моделі, значне споживання контексту\n\nЗ програмним викликом інструменту:\n\nЗамість того, щоб кожен результат інструменту повертався до Клода, Клод пише сценарій Python, який організовує весь робочий процес.Сценарій виконується в інструменті виконання коду (ізольоване середовище), призупиняючись, коли потрібні результати ваших інструментів.Коли ви повертаєте результати інструменту через API, вони обробляються сценарієм, а не споживаються моделлю.Сценарій продовжує виконуватися, і Клод бачить лише кінцевий результат.\n\n[[IMAGE_2|Програмний виклик інструментів дає змогу Клоду оркеструвати інструменти за допомогою коду, а не за допомогою окремих циклів API, що забезпечує паралельне виконання інструментів.]]\n\nОсь як виглядає оркестровий код Клода для завдання відповідності бюджету:\n\n```\nteam = await get_team_members(\"розробка\")\n\n# Отримати бюджети для кожного унікального рівня\nlevels = list(set(m[\"level\"] for m in team))\nbudget_results = await asyncio.gather(*[\nget_budget_by_level(level) для рівня в рівнях\n])\n\n# Створіть пошуковий словник: {\"молодший\": бюджет1, \"старший\": бюджет2, ...}\nбюджети = {рівень: бюджет для рівня, бюджет у zip(рівні, бюджет_результати)}\n\n# Отримати всі витрати паралельно\nвитрати = очікувати asyncio.gather(*[\nget_expenses(m[\"id\"], \"Q3\") для m у команді\n])\n\n# Знайдіть співробітників, які перевищили свій бюджет на відрядження\nперевищено = []\nдля члена, досвіду в zip(команда, витрати):\nбюджет = бюджети[учасник[\"рівень\"]]\ntotal = sum(e[\"amount\"] for e in exp)\nif total > budget[\"travel_limit\"]:\nперевищено.append({\n\"ім'я\": учасник[\"ім'я\"],\n\"витрачено\": всього,\n\"limit\": бюджет[\"travel_limit\"]\n})\n\nprint(json.dumps(exceeded))\n```\n\nКонтекст Клода отримує лише кінцевий результат: двоє-троє людей, які перевищили свій бюджет.Понад 2000 рядків-позицій, проміжні суми та пошук бюджету не впливають на контекст Клода, зменшуючи споживання з 200 КБ необроблених даних про витрати до лише 1 КБ результатів.\n\nПідвищення ефективності є значним:\n\n- Економія токенів: зберігаючи проміжні результати поза контекстом Клода, PTC значно зменшує споживання токенів.Середнє використання впало з 43 588 до 27 297 токенів, що на 37% менше для складних дослідницьких завдань.\n\n- Зменшена затримка: для кожного зворотного проходження API потрібне визначення моделі (від сотень мілісекунд до секунд).Коли Клод організовує понад 20 викликів інструментів в одному блоці коду, ви виключаєте 19+ проходів висновку.API обробляє виконання інструменту, не повертаючись кожного разу до моделі.\n\n- Покращена точність: створюючи чітку логіку оркестровки, Клод робить менше помилок, ніж під час жонглювання результатами кількох інструментів природною мовою.Внутрішній пошук знань покращився з 25,6% до 28,5%;Орієнтовні показники GIA з 46,5% до 51,2%.\n\nВиробничі робочі процеси містять безладні дані, умовну логіку та операції, які потребують масштабування.Programmatic Tool Calling дозволяє Claude впоратися з цією складністю програмним шляхом, зосереджуючись на ефективних результатах, а не на обробці необроблених даних.\n\nЯк працює Programmatic Tool Calling\n\n1. Позначте інструменти як викликані з коду\n\nДодайте code_execution до інструментів і встановіть allowed_callers для підключення інструментів для програмного виконання: ```\n{\n\"інструменти\": [\n{\n\"type\": \"code_execution_20250825\",\n\"ім'я\": \"виконання_коду\"\n},\n{\n\"name\": \"get_team_members\",\n\"description\": \"Отримати всіх членів відділу...\",\n\"вхідна_схема\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # підключення до програмного виклику інструменту\n},\n{\n\"name\": \"get_expenses\",\n...\n},\n{\n\"name\": \"get_budget_by_level\",\n...\n}\n]\n}\n```\n\nAPI перетворює ці визначення інструментів у функції Python, які може викликати Клод.\n\n2. Клод пише код оркестровки\n\nЗамість того, щоб запитувати інструменти по одному, Клод генерує код Python:\n\n```\n{\n\"type\": \"server_tool_use\",\n\"id\": \"srvtoolu_abc\",\n\"ім'я\": \"виконання_коду\",\n\"вхід\": {\n\"code\": \"team = get_team_members('engineering')\\n...\" # приклад коду вище\n}\n}\n```\n\n3. Інструменти виконуються, не зачіпаючи контекст Клода\n\nКоли код викликає get_expenses(), ви отримуєте запит інструменту з полем виклику:\n\n```\n{\n\"type\": \"tool_use\",\n\"id\": \"toolu_xyz\",\n\"name\": \"get_expenses\",\n\"input\": {\"user_id\": \"emp_123\", \"quarter\": \"Q3\"},\n\"дзвінок\": {\n\"type\": \"code_execution_20250825\",\n\"tool_id\": \"srvtoolu_abc\"\n}\n}\n```\n\nВи надаєте результат, який обробляється в середовищі виконання коду, а не в контексті Клода.Цей цикл запит-відповідь повторюється для кожного виклику інструменту в коді.\n\n4. Лише остаточний результат входить у контекст\n\nКоли код завершує роботу, Клоду повертаються лише результати коду:\n\n```\n{\n\"type\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"вміст\": {\n\"stdout\": \"[{\\\"ім'я\\\": \\\"Аліса\\\", \\\"витрачено\\\": 12500, \\\"ліміт\\\": 10000}...]\"\n}\n}\n```\n\nЦе все, що бачить Клод, а не понад 2000 статей витрат, оброблених на цьому шляху.\n\nКоли використовувати Programmatic Tool Calling\n\nProgrammatic Tool Calling додає крок виконання коду до вашого робочого процесу.Ці додаткові накладні витрати окупаються, коли економія маркерів, покращення затримки та підвищення точності є значними.\n\nНайбільш корисно, коли:\n\n- Обробка великих наборів даних, де вам потрібні лише агрегати або підсумки\n\n- Запуск багатоетапних робочих процесів із трьома або більше залежними викликами інструментів\n\n- Фільтрування, сортування або трансформація результатів інструментів до того, як їх побачить Клод\n\n- Виконання завдань, де проміжні дані не повинні впливати на міркування Клода\n\n- Виконання паралельних операцій з багатьма елементами (перевірка 50 кінцевих точок, наприклад)\n\nМенш корисно, коли:\n\n— Виконання простих викликів одним інструментом\n\n- Робота над завданнями, де Клод повинен бачити та міркувати про всі проміжні результати\n\n- Запуск швидкого пошуку з невеликими відповідями\n\nПриклади використання інструментів\n\nВиклик\n\nСхема JSON відмінно справляється з визначенням структурних типів, обов’язкових полів, дозволених переліків, але вона не може виражати шаблони використання: коли включати додаткові параметри, які комбінації мають сенс або які умовності очікує ваш API.\n\nРозглянемо API квитка підтримки:\n\n```\n{\n\"name\": \"create_ticket\",\n\"вхідна_схема\": {\n\"властивості\": {\n\"title\": {\"type\": \"string\"},\n\"priority\": {\"enum\": [\"низький\", \"середній\", \"високий\", \"критичний\"]},\n\"labels\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n\"репортер\": {\n\"type\": \"об'єкт\",\n\"властивості\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"контакт\": {\n\"type\": \"об'єкт\",\n\"властивості\": {\n\"email\": {\"type\": \"string\"},\n\"телефон\": {\"тип\": \"рядок\"}\n}\n}\n}\n},\n\"due_date\": {\"type\": \"string\"},\n\"ескалація\": {\n\"type\": \"об'єкт\",\n\"властивості\": {\n\"level\": {\"type\": \"integer\"},\n\"notify_manager\": {\"type\": \"boolean\"},\n\"sla_hours\": {\"type\": \"integer\"}\n}\n}\n},\n\"обов'язково\": [\"назва\"]\n}\n}\n```\n\nСхема визначає, що є дійсним, але залишає критичні запитання без відповіді:\n\n- Неоднозначність формату: чи має термін_виконання використовувати \"2024-11-06\", \"Nov 6, 2024\" або \"2024-11-06T00:00:00Z\"?\n\n- Умовні позначення ідентифікаторів: reporter.id є UUID, \"USR-12345\" чи просто \"12345\"?\n\n- Використання вкладеної структури: коли Клод повинен заповнити reporter.contact ?\n\n- Кореляції параметрів: як escalation.level і escalation.sla_hours пов’язані з пріоритетом?\n\nЦі неоднозначності можуть призвести до неправильно сформованих викликів інструментів і непослідовного використання параметрів.\n\nНаше рішення\n\nПриклади використання інструментів дозволяють надати зразки викликів інструментів безпосередньо у визначеннях інструментів.Замість того, щоб покладатися лише на схему, ви показуєте Клоду конкретні моделі використання: ```\n{\n\"name\": \"create_ticket\",\n\"input_schema\": { /* та сама схема, що й вище */ },\n\"input_examples\": [\n{\n\"title\": \"Сторінка входу повертає помилку 500\",\n\"priority\": \"критичний\",\n\"labels\": [\"bug\", \"authentication\", \"production\"],\n\"репортер\": {\n\"id\": \"USR-12345\",\n\"name\": \"Джейн Сміт\",\n\"контакт\": {\n\"електронна пошта\": \"jane@acme.com\",\n\"телефон\": \"+1-555-0123\"\n}\n},\n\"due_date\": \"2024-11-06\",\n\"ескалація\": {\n\"рівень\": 2,\n\"notify_manager\": правда,\n\"sla_hours\": 4\n}\n},\n{\n\"title\": \"Додати підтримку темного режиму\",\n\"labels\": [\"feature-request\", \"ui\"],\n\"репортер\": {\n\"id\": \"USR-67890\",\n\"ім'я\": \"Алекс Чен\"\n}\n},\n{\n\"title\": \"Оновити документацію API\"\n}\n]\n}\n```\n\nЗ цих трьох прикладів Клод дізнається:\n\n- Умовні позначення формату: у датах використовується РРРР-ММ-ДД, в ідентифікаторах користувачів – USR-XXXXX, у мітках – kebab-case.\n\n- Шаблони вкладеної структури: як побудувати об’єкт звіту з його вкладеним об’єктом контакту\n\n- Необов'язкові кореляції параметрів: критичні помилки мають повну контактну інформацію + ескалацію з жорсткими SLA;запити на функції мають репортера, але не мають контакту/ескалації;внутрішні завдання мають лише назву\n\nПід час нашого власного внутрішнього тестування приклади використання інструментів підвищили точність обробки складних параметрів із 72% до 90%.\n\nКоли використовувати інструмент. Приклади використання\n\nПриклади використання інструментів додають маркери до ваших визначень інструментів, тому вони є найбільш цінними, коли підвищення точності переважує додаткові витрати.\n\nНайбільш корисно, коли:\n\n- Складні вкладені структури, де дійсний JSON не передбачає правильного використання\n\n- Інструменти з багатьма необов'язковими параметрами та шаблонами включення мають значення\n\n- API із специфічними для домену угодами, які не враховані в схемах\n\n- Подібні інструменти, де приклади пояснюють, який з них використовувати (наприклад, create_ticket проти create_incident )\n\nМенш корисно, коли:\n\n- Прості інструменти з одним параметром із очевидним використанням\n\n- Стандартні формати, як-от URL-адреси чи електронні листи, які Клод уже розуміє\n\n- Питання перевірки краще обробляються обмеженнями схеми JSON\n\nКращі практики\n\nСтворення агентів, які виконують дії в реальному світі, означає водночас керування масштабом, складністю та точністю.Ці три функції працюють разом, щоб вирішити різні вузькі місця в робочих процесах використання інструментів.Ось як їх ефективно поєднати.\n\nШар має стратегічні особливості\n\nНе кожен агент повинен використовувати всі три функції для певного завдання.Почніть із найбільшого вузького місця:\n\n— Роздутість контексту з визначень інструментів Інструмент пошуку\n\n- Великі проміжні результати, що забруднюють контекст Програмний виклик інструменту\n\n- Помилки параметрів і некоректні виклики інструментів. Приклади використання\n\nЦей цілеспрямований підхід дає змогу вирішити конкретні обмеження, що обмежують продуктивність вашого агента, а не додавати складності заздалегідь.\n\nПотім за потреби нанесіть додаткові функції.Вони доповнюють один одного: Інструмент пошуку інструментів забезпечує пошук потрібних інструментів, програмний виклик інструментів забезпечує ефективне виконання, а приклади використання інструментів забезпечують правильний виклик.\n\nНалаштуйте інструмент пошуку інструментів для кращого пошуку\n\nПошук інструментів збігається з назвами та описами, тож чіткі описові визначення підвищують точність виявлення.\n\n```\n// Добре\n{\n\"name\": \"search_customer_orders\",\n\"description\": \"Пошук замовлень клієнтів за діапазоном дат, статусом або загальною сумою. Повертає деталі замовлення, включаючи елементи, інформацію про доставку та платіж.\"\n}\n\n// Погано\n{\n\"name\": \"query_db_orders\",\n\"description\": \"Виконати запит замовлення\"\n}\n```\n\nДодайте системні підказки, щоб Клод знав, що доступно:\n\n```\nВи маєте доступ до інструментів для обміну повідомленнями Slack, керування файлами Google Drive,\nВідстеження квитків Jira та операції зі сховищем GitHub.Скористайтеся інструментом пошуку\nщоб знайти конкретні можливості.\n```\n\nТримайте три-п’ять найбільш використовуваних інструментів завжди завантаженими, решту відкладіть.Це врівноважує миттєвий доступ для звичайних операцій із виявленням за вимогою для всього іншого.\n\nНалаштуйте Programmatic Tool Calling для правильного виконання\n\nОскільки Клод пише код для аналізу вихідних даних інструменту, чіткі формати повернення документа.Це допомагає Клоду написати правильну логіку аналізу: ```\n{\n\"name\": \"get_orders\",\n\"description\": \"Отримати замовлення для клієнта.\nПовернення:\nСписок об'єктів замовлення, кожен з яких містить:\n- id (str): ідентифікатор замовлення\n- total (float): загальна сума замовлення в доларах США\n- статус (str): один із «очікує», «відправлено», «доставлено»\n- елементи (список): масив {sku, quantity, price}\n- created_at (str): мітка часу ISO 8601\"\n}\n```\n\nНижче наведено інструменти підключення, які виграють від програмної оркестровки:\n\n- Інструменти, які можуть працювати паралельно (незалежні операції)\n\n- Операції, безпечні для повторної спроби (ідемпотентні)\n\nНалаштуйте приклади використання інструменту для точності параметрів\n\nПриклади ремесел для ясності поведінки:\n\n- Використовуйте реалістичні дані (справжні назви міст, правдоподібні ціни, а не \"рядок\" або \"значення\")\n\n- Показуйте різноманітність за допомогою мінімальних, часткових і повних шаблонів специфікацій\n\n- Будьте лаконічними: 1-5 прикладів на інструмент\n\n- Зосередьтеся на двозначності (лише додайте приклади, у яких правильне використання не є очевидним зі схеми)\n\nПочаток роботи\n\nЦі функції доступні в бета-версії.Щоб увімкнути їх, додайте бета-заголовок і включіть необхідні інструменти:\n\n```\nclient.beta.messages.create(\nbetas=[\"advanced-tool-use-2025-11-20\"],\nmodel=\"claude-sonnet-4-5-20250929\",\nmax_tokens=4096,\nінструменти=[\n{\"type\": \"tool_search_tool_regex_20251119\", \"name\": \"tool_search_tool_regex\"},\n{\"type\": \"code_execution_20250825\", \"name\": \"code_execution\"},\n# Ваші інструменти з defer_loading, allowed_callers і input_examples\n]\n)\n```\n\nДетальну документацію API і приклади SDK див.\n\n- Д окументація та кулінарна книга для Інструменту пошуку інструментів\n\n- Документація та кулінарна книга для Programmatic Tool Calling\n\n- Документація для прикладів використання інструментів\n\nЦі функції переміщують використання інструментів від простого виклику функції до інтелектуальної оркестровки.Оскільки агенти вирішують складніші робочі процеси, що охоплюють десятки інструментів і великі набори даних, динамічне виявлення, ефективне виконання та надійний виклик стають основоположними.\n\nМи раді бачити, що ви створюєте.\n\nПодяки\n\nНаписав Бін Ву за участі Адама Джонса, Артура Рено, Генрі Тея, Джейка Нобла, Натана МакКендліша, Ноа Пікарда, Сема Цзяна та команди Claude Developer Platform.Ця робота базується на фундаментальних дослідженнях Кріса Горголевскі, Деніела Цзяна, Джеремі Фокса та Майка Ламберта.Ми також черпали натхнення в екосистемі штучного інтелекту, включаючи LLMVM Джоела Побара, режим коду Cloudflare і виконання коду як MCP.Особлива подяка Енді Шумайстеру, Хемішу Керру, Кіру Бредвеллу, Метту Блейферу та Моллі Форверк за підтримку.",
      "edited": false
    },
    "pt": {
      "title": "Apresentando o uso de ferramentas avançadas na Claude Developer Platform",
      "content": "O futuro dos agentes de IA será aquele em que os modelos funcionarão perfeitamente em centenas ou milhares de ferramentas.Um assistente IDE que integra operações git, manipulação de arquivos, gerenciadores de pacotes, estruturas de teste e pipelines de implantação.Um coordenador de operações que conecta Slack, GitHub, Google Drive, Jira, bancos de dados de empresas e dezenas de servidores MCP simultaneamente.\n\nPara construir agentes eficazes, eles precisam trabalhar com bibliotecas de ferramentas ilimitadas sem colocar todas as definições no contexto antecipadamente.Nosso artigo do blog sobre o uso da execução de código com MCP discutiu como os resultados e definições da ferramenta às vezes podem consumir mais de 50.000 tokens antes que um agente leia uma solicitação.Os agentes devem descobrir e carregar ferramentas sob demanda, mantendo apenas o que for relevante para a tarefa atual.\n\nOs agentes também precisam da capacidade de chamar ferramentas a partir do código.Ao usar a chamada de ferramenta de linguagem natural, cada invocação requer uma passagem de inferência completa e os resultados intermediários se acumulam no contexto, sejam úteis ou não.O código é um ajuste natural para lógica de orquestração, como loops, condicionais e transformações de dados.Os agentes precisam de flexibilidade para escolher entre execução de código e inferência com base na tarefa em questão.\n\nOs agentes também precisam aprender o uso correto da ferramenta a partir de exemplos, não apenas de definições de esquema.Os esquemas JSON definem o que é estruturalmente válido, mas não podem expressar padrões de uso: quando incluir parâmetros opcionais, quais combinações fazem sentido ou quais convenções sua API espera.\n\nHoje, estamos lançando três recursos que tornam isso possível:\n\n- Ferramenta de busca de ferramentas, que permite que Claude use ferramentas de busca para acessar milhares de ferramentas sem consumir sua janela de contexto\n\n- Programmatic Tool Calling, que permite ao Claude invocar ferramentas em um ambiente de execução de código reduzindo o impacto na janela de contexto do modelo\n\n- Exemplos de uso de ferramentas, que fornecem um padrão universal para demonstrar como usar efetivamente uma determinada ferramenta\n\nEm testes internos, descobrimos que esses recursos nos ajudaram a construir coisas que não seriam possíveis com padrões convencionais de uso de ferramentas.Por exemplo, Claude for Excel usa Chamada de Ferramenta Programática para ler e modificar planilhas com milhares de linhas sem sobrecarregar a janela de contexto do modelo.\n\nCom base em nossa experiência, acreditamos que esses recursos abrem novas possibilidades para o que você pode construir com Claude.\n\nFerramenta de pesquisa de ferramentas\n\nO desafio\n\nAs definições da ferramenta MCP fornecem um contexto importante, mas à medida que mais servidores se conectam, esses tokens podem aumentar.Considere uma configuração de cinco servidores:\n\n- GitHub: 35 ferramentas (cerca de 26 mil tokens)\n\n- Slack: 11 ferramentas (~21 mil tokens)\n\n- Sentinela: 5 ferramentas (~3 mil tokens)\n\n- Grafana: 5 ferramentas (~3 mil tokens)\n\n- Splunk: 2 ferramentas (~2 mil tokens)\n\nSão 58 ferramentas consumindo aproximadamente 55 mil tokens antes mesmo de a conversa começar.Adicione mais servidores como o Jira (que sozinho usa aproximadamente 17 mil tokens) e você estará rapidamente se aproximando de mais de 100 mil tokens de sobrecarga.Na Anthropic, vimos definições de ferramentas consumirem 134 mil tokens antes da otimização.\n\nMas o custo do token não é o único problema.As falhas mais comuns são a seleção errada de ferramentas e parâmetros incorretos, especialmente quando as ferramentas têm nomes semelhantes, como notificação-envio-usuário vs.\n\nNossa solução\n\nEm vez de carregar todas as definições de ferramentas antecipadamente, a Ferramenta de pesquisa de ferramentas descobre ferramentas sob demanda.Claude só vê as ferramentas de que realmente precisa para a tarefa atual.\n\n[[IMAGE_1|A ferramenta de pesquisa preserva 191.300 tokens de contexto em comparação com 122.800 com a abordagem tradicional de Claude.]]\n\nAbordagem tradicional:\n\n- Todas as definições de ferramentas carregadas antecipadamente (cerca de 72 mil tokens para mais de 50 ferramentas MCP)\n\n- O histórico de conversas e o prompt do sistema competem pelo espaço restante\n\n- Consumo total de contexto: aproximadamente 77 mil tokens antes do início de qualquer trabalho\n\nCom a ferramenta de pesquisa de ferramentas:\n\n- Somente a ferramenta de pesquisa de ferramentas foi carregada antecipadamente (~500 tokens)\n\n- Ferramentas descobertas sob demanda conforme necessário (3 a 5 ferramentas relevantes, aproximadamente 3 mil tokens)\n\n- Consumo total de contexto: ~8,7 mil tokens, preservando 95% da janela de contexto\n\nIsso representa uma redução de 85% no uso de tokens, mantendo o acesso à sua biblioteca completa de ferramentas.Os testes internos mostraram melhorias significativas na precisão das avaliações do MCP ao trabalhar com grandes bibliotecas de ferramentas.O Opus 4 melhorou de 49% para 74%, e o Opus 4.5 melhorou de 79,5% para 88,1% com a ferramenta de busca de ferramentas habilitada.\n\nComo funciona a ferramenta de pesquisa de ferramentas A ferramenta de pesquisa de ferramentas permite que Claude descubra ferramentas dinamicamente em vez de carregar todas as definições antecipadamente.Você fornece todas as definições de ferramentas para a API, mas marca as ferramentas com defer_loading: true para torná-las detectáveis ​​sob demanda.As ferramentas adiadas não são carregadas inicialmente no contexto de Claude.Claude vê apenas a própria ferramenta de pesquisa de ferramentas e quaisquer ferramentas com defer_loading: false (suas ferramentas mais críticas e usadas com frequência).\n\nQuando Claude precisa de recursos específicos, ele procura ferramentas relevantes.A ferramenta de pesquisa de ferramentas retorna referências a ferramentas correspondentes, que são expandidas em definições completas no contexto de Claude.\n\nPor exemplo, se Claude precisar interagir com o GitHub, ele pesquisará \"github\" e apenas github.createPullRequest e github.listIssues serão carregados, e não suas outras mais de 50 ferramentas do Slack, Jira e Google Drive.\n\nDessa forma, Claude tem acesso à sua biblioteca completa de ferramentas, pagando apenas o custo do token pelas ferramentas de que realmente precisa.\n\nNota sobre cache de prompt: A ferramenta de pesquisa de ferramentas não interrompe o cache de prompt porque as ferramentas adiadas são totalmente excluídas do prompt inicial.Eles só são adicionados ao contexto depois que Claude os procura, para que o prompt do sistema e as definições da ferramenta principal permaneçam armazenáveis ​​em cache.\n\nImplementação:\n\n```\n{\n\"ferramentas\": [\n// Inclui uma ferramenta de busca de ferramentas (regex, BM25 ou customizada)\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nome\": \"tool_search_tool_regex\"},\n\n//Marca ferramentas para descoberta sob demanda\n{\n\"nome\": \"github.createPullRequest\",\n\"description\": \"Criar uma solicitação pull\",\n\"esquema_de entrada\": {...},\n\"defer_loading\": verdadeiro\n}\n// ... mais centenas de ferramentas adiadas com defer_loading: true\n]\n}\n```\n\nPara servidores MCP, você pode adiar o carregamento de servidores inteiros enquanto mantém carregadas ferramentas específicas de alto uso:\n\n```\n{\n\"tipo\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-drive\",\n\"default_config\": {\"defer_loading\": true}, # adia o carregamento de todo o servidor\n\"configurações\": {\n\"arquivos_de_pesquisa\": {\n\"defer_loading\": falso\n} //Mantém a ferramenta mais usada carregada\n}\n}\n```\n\nA Claude Developer Platform fornece ferramentas de pesquisa baseadas em regex e BM25 prontas para uso, mas você também pode implementar ferramentas de pesquisa personalizadas usando embeddings ou outras estratégias.\n\nQuando usar a ferramenta de pesquisa de ferramentas\n\nComo qualquer decisão arquitetônica, habilitar a ferramenta Tool Search envolve compensações.O recurso adiciona uma etapa de pesquisa antes da invocação da ferramenta, proporcionando o melhor ROI quando a economia de contexto e as melhorias na precisão superam a latência adicional.\n\nUse-o quando:\n\n- Definições de ferramentas consumindo >10 mil tokens\n\n- Enfrentando problemas de precisão na seleção de ferramentas\n\n- Construindo sistemas alimentados por MCP com vários servidores\n\n- Mais de 10 ferramentas disponíveis\n\nMenos benéfico quando:\n\n- Pequena biblioteca de ferramentas (<10 ferramentas)\n\n- Todas as ferramentas usadas com frequência em todas as sessões\n\n- As definições de ferramentas são compactas\n\nChamada de ferramenta programática\n\nO desafio\n\nA chamada tradicional de ferramentas cria dois problemas fundamentais à medida que os fluxos de trabalho se tornam mais complexos:\n\n- Poluição de contexto de resultados intermediários: quando Claude analisa um arquivo de log de 10 MB em busca de padrões de erros, o arquivo inteiro entra em sua janela de contexto, embora Claude precise apenas de um resumo das frequências de erros.Ao buscar dados de clientes em diversas tabelas, cada registro é acumulado no contexto, independentemente da relevância.Esses resultados intermediários consomem enormes orçamentos de tokens e podem tirar informações importantes totalmente da janela de contexto.\n\n- Sobrecarga de inferência e síntese manual: cada chamada de ferramenta requer uma passagem completa de inferência do modelo.Depois de receber os resultados, Claude deve “observar” os dados para extrair informações relevantes, raciocinar sobre como as peças se encaixam e decidir o que fazer a seguir – tudo por meio do processamento de linguagem natural.Um fluxo de trabalho de cinco ferramentas significa cinco passagens de inferência, além de Claude analisando cada resultado, comparando valores e sintetizando conclusões.Isso é lento e sujeito a erros.\n\nNossa solução\n\nA chamada de ferramenta programática permite que Claude orquestre ferramentas por meio de código, em vez de viagens de ida e volta de API individuais.Em vez de Claude solicitar uma ferramenta de cada vez, com cada resultado sendo retornado ao seu contexto, Claude escreve um código que chama diversas ferramentas, processa suas saídas e controla quais informações realmente entram na janela de contexto. Claude é excelente em escrever código e, ao permitir que ele expresse a lógica de orquestração em Python, em vez de invocar ferramentas de linguagem natural, você obtém um fluxo de controle mais confiável e preciso.Loops, condicionais, transformações de dados e tratamento de erros estão todos explícitos no código, e não implícitos no raciocínio de Claude.\n\nExemplo: verificação de conformidade orçamentária\n\nConsidere uma tarefa comercial comum: \"Quais membros da equipe excederam o orçamento de viagens do terceiro trimestre?\"\n\nVocê tem três ferramentas disponíveis:\n\n- get_team_members(department) – Retorna a lista de membros da equipe com IDs e níveis\n\n- get_expenses(user_id, quarter) – Retorna itens de linha de despesas para um usuário\n\n- get_budget_by_level(level) – Retorna os limites de orçamento para um nível de funcionário\n\nAbordagem tradicional:\n\n- Buscar membros da equipe 20 pessoas\n\n- Para cada pessoa, busque suas despesas do terceiro trimestre com 20 chamadas de ferramenta, cada uma retornando de 50 a 100 itens de linha (voos, hotéis, refeições, recibos)\n\n- Buscar limites de orçamento por nível de funcionário\n\n- Tudo isso entra no contexto de Claude: mais de 2.000 itens de linha de despesas (50 KB+)\n\n- Claude soma manualmente as despesas de cada pessoa, consulta o orçamento, compara as despesas com os limites orçamentários\n\n- Mais viagens de ida e volta ao modelo, consumo significativo de contexto\n\nCom chamada de ferramenta programática:\n\nEm vez de cada resultado da ferramenta retornar para Claude, Claude escreve um script Python que orquestra todo o fluxo de trabalho.O script é executado na ferramenta Code Execution (um ambiente em área restrita), pausando quando precisa de resultados de suas ferramentas.Quando você retorna resultados de ferramentas por meio da API, eles são processados ​​pelo script em vez de consumidos pelo modelo.O script continua em execução e Claude vê apenas o resultado final.\n\n[[IMAGE_2|A chamada de ferramenta programática permite que Claude orquestre ferramentas por meio de código, em vez de viagens de ida e volta de API individuais, permitindo a execução paralela de ferramentas.]]\n\nEsta é a aparência do código de orquestração de Claude para a tarefa de conformidade orçamentária:\n\n```\nequipe = aguarda get_team_members(\"engenharia\")\n\n# Busque orçamentos para cada nível único\nníveis = lista(set(m[\"nível\"] para m na equipe))\norçamento_resultados = aguardar asyncio.gather(*[\nget_budget_by_level(level) para nível em níveis\n])\n\n# Crie um dicionário de pesquisa: {\"junior\": budget1, \"senior\": budget2, ...}\norçamentos = {nível: orçamento por nível, orçamento em zip(níveis, orçamento_resultados)}\n\n#Busca todas as despesas em paralelo\ndespesas = aguardar asyncio.gather(*[\nget_expenses(m[\"id\"], \"Q3\") para m na equipe\n])\n\n# Encontre funcionários que excederam seu orçamento de viagens\nexcedido = []\npara membro, exp em zip(equipe, despesas):\norçamento = orçamentos[membro[\"nível\"]]\ntotal = soma(e[\"quantia\"] para e em exp)\nse total > orçamento[\"travel_limit\"]:\nexcedido.append({\n\"nome\": membro[\"nome\"],\n\"gasto\": total,\n\"limite\": orçamento[\"limite_viagem\"]\n})\n\nimprimir(json.dumps(excedido))\n```\n\nO contexto de Claude recebe apenas o resultado final: as duas a três pessoas que ultrapassaram o orçamento.Os mais de 2.000 itens de linha, as somas intermediárias e as pesquisas de orçamento não afetam o contexto de Claude, reduzindo o consumo de 200 KB de dados brutos de despesas para apenas 1 KB de resultados.\n\nOs ganhos de eficiência são substanciais:\n\n- Economia de tokens: Ao manter os resultados intermediários fora do contexto de Claude, a PTC reduz drasticamente o consumo de tokens.O uso médio caiu de 43.588 para 27.297 tokens, uma redução de 37% em tarefas complexas de pesquisa.\n\n- Latência reduzida: cada viagem de ida e volta da API requer inferência de modelo (centenas de milissegundos a segundos).Quando Claude orquestra mais de 20 chamadas de ferramenta em um único bloco de código, você elimina mais de 19 passagens de inferência.A API lida com a execução da ferramenta sem retornar ao modelo todas as vezes.\n\n- Precisão aprimorada: ao escrever lógica de orquestração explícita, Claude comete menos erros do que ao fazer malabarismos com vários resultados de ferramentas em linguagem natural.A recuperação de conhecimento interno melhorou de 25,6% para 28,5%;Referências GIA de 46,5% para 51,2%.\n\nOs fluxos de trabalho de produção envolvem dados confusos, lógica condicional e operações que precisam ser escalonadas.A chamada de ferramenta programática permite que Claude lide com essa complexidade de forma programática, mantendo o foco em resultados acionáveis, em vez de no processamento de dados brutos.\n\nComo funciona a chamada de ferramenta programática\n\n1. Marcar ferramentas como chamáveis a partir do código\n\nAdicione code_execution às ferramentas e defina Allow_callers como ferramentas opcionais para execução programática: ```\n{\n\"ferramentas\": [\n{\n\"tipo\": \"código_execução_20250825\",\n\"nome\": \"código_execução\"\n},\n{\n\"nome\": \"get_team_members\",\n\"description\": \"Obter todos os membros de um departamento...\",\n\"esquema_de entrada\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # opte pela chamada de ferramenta programática\n},\n{\n\"nome\": \"get_expenses\",\n...\n},\n{\n\"nome\": \"get_budget_by_level\",\n...\n}\n]\n}\n```\n\nA API converte essas definições de ferramentas em funções Python que Claude pode chamar.\n\n2. Claude escreve código de orquestração\n\nEm vez de solicitar uma ferramenta de cada vez, Claude gera código Python:\n\n```\n{\n\"tipo\": \"server_tool_use\",\n\"id\": \"srvtoolu_abc\",\n\"nome\": \"código_execução\",\n\"entrada\": {\n\"code\": \"team = get_team_members('engineering')\\n...\" # o exemplo de código acima\n}\n}\n```\n\n3. As ferramentas são executadas sem atingir o contexto de Claude\n\nQuando o código chama get_expenses(), você recebe uma solicitação de ferramenta com um campo de chamada:\n\n```\n{\n\"tipo\": \"uso_ferramenta\",\n\"id\": \"toolu_xyz\",\n\"nome\": \"get_expenses\",\n\"input\": {\"user_id\": \"emp_123\", \"trimestre\": \"Q3\"},\n\"chamador\": {\n\"tipo\": \"código_execução_20250825\",\n\"tool_id\": \"srvtoolu_abc\"\n}\n}\n```\n\nVocê fornece o resultado, que é processado no ambiente de execução de código, e não no contexto de Claude.Este ciclo de solicitação-resposta se repete para cada chamada de ferramenta no código.\n\n4. Somente o resultado final entra no contexto\n\nQuando a execução do código termina, apenas os resultados do código são retornados para Claude:\n\n```\n{\n\"tipo\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"conteúdo\": {\n\"stdout\": \"[{\\\"nome\\\": \\\"Alice\\\", \\\"gasto\\\": 12500, \\\"limite\\\": 10000}...]\"\n}\n}\n```\n\nIsso é tudo que Claude vê, e não os mais de 2.000 itens de despesas processados ao longo do caminho.\n\nQuando usar chamada de ferramenta programática\n\nA chamada de ferramenta programática adiciona uma etapa de execução de código ao seu fluxo de trabalho.Essa sobrecarga extra compensa quando a economia de tokens, as melhorias de latência e os ganhos de precisão são substanciais.\n\nMais benéfico quando:\n\n- Processamento de grandes conjuntos de dados onde você só precisa de agregados ou resumos\n\n- Execução de fluxos de trabalho de várias etapas com três ou mais chamadas de ferramentas dependentes\n\n- Filtrar, classificar ou transformar os resultados da ferramenta antes que Claude os veja\n\n- Lidar com tarefas onde dados intermediários não deveriam influenciar o raciocínio de Claude\n\n- Execução de operações paralelas em vários itens (verificação de 50 endpoints, por exemplo)\n\nMenos benéfico quando:\n\n- Fazendo invocações simples de ferramenta única\n\n- Trabalhar em tarefas onde Claude deveria ver e raciocinar sobre todos os resultados intermediários\n\n- Executando pesquisas rápidas com pequenas respostas\n\nExemplos de uso de ferramentas\n\nO desafio\n\nO esquema JSON é excelente na definição de tipos de estrutura, campos obrigatórios e enums permitidos, mas não pode expressar padrões de uso: quando incluir parâmetros opcionais, quais combinações fazem sentido ou quais convenções sua API espera.\n\nConsidere uma API de ticket de suporte:\n\n```\n{\n\"nome\": \"criar_ticket\",\n\"esquema_de entrada\": {\n\"propriedades\": {\n\"título\": {\"tipo\": \"string\"},\n\"prioridade\": {\"enum\": [\"baixo\", \"médio\", \"alto\", \"crítico\"]},\n\"labels\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n\"repórter\": {\n\"tipo\": \"objeto\",\n\"propriedades\": {\n\"id\": {\"tipo\": \"string\"},\n\"nome\": {\"tipo\": \"string\"},\n\"contato\": {\n\"tipo\": \"objeto\",\n\"propriedades\": {\n\"e-mail\": {\"tipo\": \"string\"},\n\"telefone\": {\"tipo\": \"string\"}\n}\n}\n}\n},\n\"data_de vencimento\": {\"tipo\": \"string\"},\n\"escalada\": {\n\"tipo\": \"objeto\",\n\"propriedades\": {\n\"nível\": {\"tipo\": \"inteiro\"},\n\"notify_manager\": {\"type\": \"boolean\"},\n\"sla_hours\": {\"type\": \"inteiro\"}\n}\n}\n},\n\"obrigatório\": [\"título\"]\n}\n}\n```\n\nO esquema define o que é válido, mas deixa questões críticas sem resposta:\n\n- Ambigüidade de formato: a data_de vencimento deve usar \"2024-11-06\", \"Nov 6, 2024\" ou \"2024-11-06T00:00:00Z\"?\n\n- Convenções de ID: reporter.id é um UUID, \"USR-12345\" ou apenas \"12345\"?\n\n- Uso de estrutura aninhada: quando Claude deve preencher reporter.contact ?\n\n- Correlações de parâmetros: como escalation.level e escalation.sla_hours se relacionam com a prioridade?\n\nEssas ambigüidades podem levar a chamadas de ferramentas malformadas e ao uso inconsistente de parâmetros.\n\nNossa solução\n\nOs Exemplos de uso de ferramentas permitem fornecer amostras de chamadas de ferramentas diretamente nas definições de ferramentas.Em vez de confiar apenas no esquema, você mostra padrões de uso concretos a Claude: ```\n{\n\"nome\": \"criar_ticket\",\n\"input_schema\": { /* mesmo esquema acima */ },\n\"input_examples\": [\n{\n\"title\": \"A página de login retorna erro 500\",\n\"prioridade\": \"crítico\",\n\"labels\": [\"bug\", \"autenticação\", \"produção\"],\n\"repórter\": {\n\"id\": \"USR-12345\",\n\"nome\": \"Jane Smith\",\n\"contato\": {\n\"e-mail\": \"jane@acme.com\",\n\"telefone\": \"+1-555-0123\"\n}\n},\n\"data_de vencimento\": \"06/11/2024\",\n\"escalada\": {\n\"nível\": 2,\n\"notify_manager\": verdadeiro,\n\"sla_horas\": 4\n}\n},\n{\n\"title\": \"Adicionar suporte ao modo escuro\",\n\"rótulos\": [\"solicitação de recurso\", \"ui\"],\n\"repórter\": {\n\"id\": \"USR-67890\",\n\"nome\": \"Alex Chen\"\n}\n},\n{\n\"title\": \"Atualizar documentação da API\"\n}\n]\n}\n```\n\nA partir desses três exemplos, Claude aprende:\n\n- Convenções de formato: as datas usam AAAA-MM-DD, os IDs de usuário seguem USR-XXXXX, os rótulos usam kebab-case\n\n- Padrões de estrutura aninhada: como construir o objeto repórter com seu objeto de contato aninhado\n\n- Correlações de parâmetros opcionais: Bugs críticos têm informações de contato completas + escalonamento com SLAs rígidos;solicitações de recursos têm relator, mas não têm contato/escalonamento;tarefas internas têm apenas título\n\nEm nossos próprios testes internos, exemplos de uso de ferramentas melhoraram a precisão de 72% para 90% no tratamento de parâmetros complexos.\n\nQuando usar exemplos de uso de ferramentas\n\nExemplos de uso de ferramentas adicionam tokens às definições de ferramentas, portanto, eles são mais valiosos quando as melhorias na precisão superam o custo adicional.\n\nMais benéfico quando:\n\n- Estruturas aninhadas complexas onde JSON válido não implica uso correto\n\n- Ferramentas com muitos parâmetros opcionais e padrões de inclusão são importantes\n\n- APIs com convenções específicas de domínio não capturadas em esquemas\n\n- Ferramentas semelhantes onde os exemplos esclarecem qual usar (por exemplo, create_ticket vs create_incident )\n\nMenos benéfico quando:\n\n- Ferramentas simples de parâmetro único com uso óbvio\n\n- Formatos padrão como URLs ou e-mails que Claude já entende\n\n- Preocupações de validação melhor tratadas pelas restrições do esquema JSON\n\nMelhores práticas\n\nConstruir agentes que realizam ações no mundo real significa lidar com escala, complexidade e precisão simultaneamente.Esses três recursos trabalham juntos para resolver diferentes gargalos nos fluxos de trabalho de uso de ferramentas.Veja como combiná-los de forma eficaz.\n\nCamada de recursos estrategicamente\n\nNem todo agente precisa usar todos os três recursos para uma determinada tarefa.Comece com seu maior gargalo:\n\n- Inchaço de contexto das definições de ferramentas Ferramenta de pesquisa de ferramentas\n\n- Grandes resultados intermediários contexto poluente Chamada de ferramenta programática\n\n- Erros de parâmetro e chamadas malformadas Exemplos de uso de ferramentas\n\nEssa abordagem focada permite que você resolva a restrição específica que limita o desempenho do seu agente, em vez de adicionar complexidade antecipadamente.\n\nEm seguida, coloque recursos adicionais conforme necessário.Eles são complementares: a ferramenta de pesquisa de ferramentas garante que as ferramentas certas sejam encontradas, a chamada programática de ferramentas garante uma execução eficiente e os exemplos de uso de ferramentas garantem a invocação correta.\n\nConfigure a ferramenta de pesquisa de ferramentas para uma melhor descoberta\n\nA pesquisa de ferramentas corresponde a nomes e descrições, portanto, definições claras e descritivas melhoram a precisão da descoberta.\n\n```\n//Bom\n{\n\"nome\": \"search_customer_orders\",\n\"description\": \"Pesquise pedidos de clientes por intervalo de datas, status ou valor total. Retorna detalhes do pedido, incluindo itens, frete e informações de pagamento.\"\n}\n\n// Ruim\n{\n\"nome\": \"query_db_orders\",\n\"description\": \"Executar consulta de pedido\"\n}\n```\n\nAdicione orientação imediata do sistema para que Claude saiba o que está disponível:\n\n```\nVocê tem acesso a ferramentas de mensagens do Slack, gerenciamento de arquivos do Google Drive,\nRastreamento de tickets Jira e operações de repositório GitHub.Utilize a ferramenta de busca\npara encontrar capacidades específicas.\n```\n\nMantenha suas três a cinco ferramentas mais usadas sempre carregadas, adie o resto.Isso equilibra o acesso imediato para operações comuns com a descoberta sob demanda para todo o resto.\n\nConfigure a chamada de ferramenta programática para execução correta\n\nComo Claude escreve código para analisar os resultados da ferramenta, documente os formatos de retorno com clareza.Isso ajuda Claude a escrever a lógica de análise correta: ```\n{\n\"nome\": \"get_orders\",\n\"description\": \"Recuperar pedidos de um cliente.\nRetorna:\nLista de objetos de pedido, cada um contendo:\n- id (str): identificador do pedido\n- total (float): total do pedido em USD\n- status (str): Um entre 'pendente', 'enviado', 'entregue'\n- itens (lista): Matriz de {sku, quantidade, preço}\n- criado_at (str): carimbo de data/hora ISO 8601\"\n}\n```\n\nVeja abaixo as ferramentas opcionais que se beneficiam da orquestração programática:\n\n- Ferramentas que podem funcionar em paralelo (operações independentes)\n\n- Operações seguras para tentar novamente (idempotentes)\n\nConfigurar exemplos de uso de ferramentas para precisão de parâmetros\n\nCrie exemplos para clareza comportamental:\n\n- Use dados realistas (nomes reais de cidades, preços plausíveis, não \"string\" ou \"valor\")\n\n- Mostre variedade com padrões de especificações mínimas, parciais e completas\n\n- Seja conciso: 1 a 5 exemplos por ferramenta\n\n- Concentre-se na ambiguidade (adicione apenas exemplos onde o uso correto não seja óbvio no esquema)\n\nPrimeiros passos\n\nEsses recursos estão disponíveis na versão beta.Para ativá-los, adicione o cabeçalho beta e inclua as ferramentas necessárias:\n\n```\ncliente.beta.messages.create(\nbetas = [\"uso de ferramenta avançada-2025-11-20\"],\nmodelo = \"claude-sonnet-4-5-20250929\",\nmax_tokens=4096,\nferramentas=[\n{\"tipo\": \"tool_search_tool_regex_20251119\", \"nome\": \"tool_search_tool_regex\"},\n{\"tipo\": \"code_execution_20250825\", \"nome\": \"code_execution\"},\n# Suas ferramentas com defer_loading, Allow_callers e input_examples\n]\n)\n```\n\nPara obter documentação detalhada da API e exemplos de SDK, consulte:\n\n- D ocumentação e livro de receitas para a ferramenta Tool Search\n\n- Documentação e livro de receitas para chamada de ferramenta programática\n\n- Documentação para exemplos de uso de ferramentas\n\nEsses recursos movem o uso da ferramenta de uma simples chamada de função para uma orquestração inteligente.À medida que os agentes lidam com fluxos de trabalho mais complexos, abrangendo dezenas de ferramentas e grandes conjuntos de dados, a descoberta dinâmica, a execução eficiente e a invocação confiável tornam-se fundamentais.\n\nEstamos entusiasmados para ver o que você constrói.\n\nAgradecimentos\n\nEscrito por Bin Wu, com contribuições de Adam Jones, Artur Renault, Henry Tay, Jake Noble, Nathan McCandlish, Noah Picard, Sam Jiang e a equipe da Claude Developer Platform.Este trabalho baseia-se na pesquisa fundamental de Chris Gorgolewski, Daniel Jiang, Jeremy Fox e Mike Lambert.Também nos inspiramos em todo o ecossistema de IA, incluindo LLMVM de Joel Pobar, Code Mode da Cloudflare e Code Execution como MCP.Agradecimentos especiais a Andy Schumeister, Hamish Kerr, Keir Bradwell, Matt Bleifer e Molly Vorwerck pelo apoio.",
      "edited": false
    },
    "zh": {
      "title": "介绍 Claude 开发者平台上的高级工具使用",
      "content": "人工智能代理的未来是模型可以跨数百或数千种工具无缝工作。集成了 git 操作、文件操作、包管理器、测试框架和部署管道的 IDE 助手。一个运营协调器，可同时连接 Slack、GitHub、Google Drive、Jira、公司数据库和数十台 MCP 服务器。\n\n为了构建有效的代理，他们需要使用无限的工具库，而不需要预先将每个定义填充到上下文中。我们关于使用 MCP 执行代码的博客文章讨论了工具结果和定义有时如何在代理读取请求之前消耗 50,000 多个令牌。代理应该按需发现和加载工具，只保留与当前任务相关的工具。\n\n代理还需要能够从代码调用工具。使用自然语言工具调用时，每次调用都需要完整的推理过程，中间结果会在上下文中堆积，无论它们是否有用。代码非常适合编排逻辑，例如循环、条件和数据转换。代理需要根据手头的任务灵活地在代码执行和推理之间进行选择。\n\n代理还需要从示例中学习正确的工具用法，而不仅仅是模式定义。JSON 模式定义了结构上有效的内容，但无法表达使用模式：何时包含可选参数、哪些组合有意义，或者您的 API 期望什么约定。\n\n今天，我们发布了三项使这成为可能的功能：\n\n- 工具搜索工具，允许 Claude 使用搜索工具访问数千种工具，而无需消耗其上下文窗口\n\n- 编程工具调用，允许 Claude 在代码执行环境中调用工具，减少对模型上下文窗口的影响\n\n- 工具使用示例，提供了演示如何有效使用给定工具的通用标准\n\n在内部测试中，我们发现这些功能帮助我们构建了传统工具使用模式无法实现的东西。例如，Claude for Excel 使用编程工具调用来读取和修改具有数千行的电子表格，而不会使模型的上下文窗口超载。\n\n根据我们的经验，我们相信这些功能为您与 Claude 一起构建内容开辟了新的可能性。\n\n工具搜索工具\n\n挑战\n\nMCP 工具定义提供了重要的上下文，但随着更多服务器连接，这些令牌会不断增加。考虑五台服务器的设置：\n\n- GitHub：35 个工具（约 26K 代币）\n\n- Slack：11 个工具（约 21K 代币）\n\n- Sentry：5 个工具（~3K 代币）\n\n- Grafana：5 个工具（~3K 代币）\n\n- Splunk：2 个工具（~2K 代币）\n\n在对话开始之前，这 58 个工具消耗了大约 55K 令牌。添加更多像 Jira 这样的服务器（仅使用约 17K 令牌），您很快就会接近 100K+ 令牌开销。在 Anthropic，我们看到工具定义在优化之前消耗了 134K 令牌。\n\n但代币成本并不是唯一的问题。最常见的故障是错误的工具选择和不正确的参数，尤其是当工具具有类似名称（例如 notification-send-user 与 notification-send-channel ）时。\n\n我们的解决方案\n\n工具搜索工具不是预先加载所有工具定义，而是按需发现工具。Claude 只看到当前任务实际需要的工具。\n\n[[IMAGE_1|工具搜索工具保留了 191,300 个上下文标记，而 Claude 的传统方法保留了 122,800 个。]]\n\n传统方法：\n\n- 预先加载所有工具定义（50 多个 MCP 工具约 72K 令牌）\n\n- 对话历史和系统提示争夺剩余空间\n\n- 总上下文消耗：在任何工作开始之前约 77K 令牌\n\n使用工具搜索工具：\n\n- 仅预先加载工具搜索工具（约 500 个令牌）\n\n- 根据需要按需发现工具（3-5 个相关工具，约 3K 代币）\n\n- 总上下文消耗：~8.7K 令牌，保留 95% 的上下文窗口\n\n这意味着令牌使用量减少了 85%，同时保持对完整工具库的访问。内部测试表明，使用大型工具库时，MCP 评估的准确性显着提高。启用工具搜索工具后，Opus 4 从 49% 提高到 74%，Opus 4.5 从 79.5% 提高到 88.1%。\n\n工具搜索工具的工作原理 工具搜索工具可让 Claude 动态发现工具，而不是预先加载所有定义。您向 API 提供所有工具定义，但使用 defer_loading: true 标记工具，以便按需发现它们。延迟工具最初不会加载到 Claude 的上下文中。Claude 只能看到工具搜索工具本身以及带有 defer_loading: false 的任何工具（您最关键、最常用的工具）。\n\n当 Claude 需要特定功能时，它会搜索相关工具。工具搜索工具返回对匹配工具的引用，这些工​​具在 Claude 的上下文中扩展为完整的定义。\n\n例如，如果 Claude 需要与 GitHub 交互，它会搜索“github”，并且仅加载 github.createPullRequest 和 github.listIssues，而不加载来自 Slack、Jira 和 Google Drive 的其他 50 多个工具。\n\n这样，Claude 就可以访问您的完整工具库，而只需支付其实际需要的工具的代币成本。\n\n提示缓存注意：工具搜索工具不会破坏提示缓存，因为延迟工具完全从初始提示中排除。它们仅在 Claude 搜索后才会添加到上下文中，因此您的系统提示和核心工具定义仍然可缓存。\n\n实施：\n\n````\n{\n“工具”：[\n// 包含工具搜索工具（正则表达式、BM25 或自定义）\n{“类型”：“tool_search_tool_regex_20251119”，“名称”：“tool_search_tool_regex”}，\n\n// 标记用于按需发现的工具\n{\n\"name\": \"github.createPullRequest\",\n\"description\": \"创建拉取请求\",\n“输入模式”：{...}，\n“延迟加载”：正确\n}\n// ... 数百个带有 defer_loading: true 的延迟工具\n]\n}\n````\n\n对于 MCP 服务器，您可以推迟加载整个服务器，同时保持加载特定的高使用率工具：\n\n````\n{\n“类型”：“mcp_toolset”，\n\"mcp_server_name\": \"谷歌驱动器\",\n\"default_config\": {\"defer_loading\": true}, # 延迟加载整个服务器\n“配置”：{\n“搜索文件”：{\n“延迟加载”：假\n} // 保持最常用的工具加载\n}\n}\n````\n\nClaude 开发者平台提供开箱即用的基于正则表达式和基于 BM25 的搜索工具，但您也可以使用嵌入或其他策略来实现自定义搜索工具。\n\n何时使用工具搜索工具\n\n与任何架构决策一样，启用工具搜索工具需要权衡。该功能在工具调用之前添加了一个搜索步骤，因此当上下文节省和准确性改进超过额外的延迟时，它可以提供最佳的投资回报率。\n\n在以下情况下使用它：\n\n- 消耗 >10K 代币的工具定义\n\n- 遇到工具选择准确性问题\n\n- 使用多个服务器构建 MCP 驱动的系统\n\n- 10 多个可用工具\n\n在以下情况下效果较差：\n\n- 小型工具库（<10 个工具）\n\n- 每个会话中经常使用的所有工具\n\n- 工具定义紧凑\n\n程序化工具调用\n\n挑战\n\n随着工作流程变得更加复杂，传统的工具调用会产生两个基本问题：\n\n- 中间结果的上下文污染：当 Claude 分析 10MB 日志文件中的错误模式时，整个文件都会进入其上下文窗口，即使 Claude 只需要错误频率的摘要。当跨多个表获取客户数据时，每条记录都会在上下文中累积，无论相关性如何。这些中间结果消耗大量的代币预算，并且可以将重要信息完全推出上下文窗口。\n\n- 推理开销和手动综合：每个工具调用都需要完整的模型推理过程。收到结果后，克劳德必须“观察”数据以提取相关信息，推理各个部分如何组合在一起，并通过自然语言处理决定下一步该做什么。五工具工作流程意味着五次推理过程加上 Claude 解析每个结果、比较值并综合结论。这既缓慢又容易出错。\n\n我们的解决方案\n\n编程工具调用使 Claude 能够通过代码而不是通过单独的 API 往返来编排工具。Claude 不是每次请求一个工具并将每个结果返回到其上下文，而是编写调用多个工具、处理其输出并控制实际进入其上下文窗口的信息的代码。 Claude 擅长编写代码，通过让它用 Python 表达编排逻辑，而不是通过自然语言工具调用，您可以获得更可靠、更精确的控制流。循环、条件、数据转换和错误处理在代码中都是显式的，而不是在 Claude 的推理中隐式的。\n\n示例：预算合规性检查\n\n考虑一个常见的业务任务：“哪些团队成员超出了第三季度的差旅预算？”\n\n您可以使用三种工具：\n\n- get_team_members(department) - 返回带有 ID 和级别的团队成员列表\n\n- get_expenses(user_id,quarter) - 返回用户的费用行项目\n\n- get_budget_by_level(level) - 返回员工级别的预算限制\n\n传统方法：\n\n- 获取团队成员20人\n\n- 对于每个人，获取他们的第三季度支出 20 个工具调用，每个返回 50-100 个行项目（航班、酒店、餐饮、收据）\n\n- 按员工级别获取预算限制\n\n- 所有这些都进入 Claude 的上下文：2,000 多个费用行项目 (50 KB+)\n\n- 克劳德手动汇总每个人的费用，查找他们的预算，将费用与预算限制进行比较\n\n- 模型的往返次数更多，上下文消耗显着\n\n通过编程工具调用：\n\nClaude 没有将每个工具结果返回给 Claude，而是编写了一个 Python 脚本来协调整个工作流程。该脚本在代码执行工具（沙盒环境）中运行，在需要工具的结果时暂停。当您通过 API 返回工具结果时，它们将由脚本处理，而不是由模型使用。脚本继续执行，克劳德只看到最终的输出。\n\n[[IMAGE_2|编程工具调用使 Claude 能够通过代码而不是通过单独的 API 往返来编排工具，从而允许并行工具执行。]]\n\n以下是克劳德针对预算合规任务的编排代码：\n\n````\n团队=等待 get_team_members(“工程”)\n\n# 获取每个独特级别的预算\n级别 = list(set(m[\"level\"] for m in team))\nBudget_results = 等待 asyncio.gather(*[\nget_budget_by_level(level) 获取级别中的级别\n]）\n\n# 创建一个查找字典: {\"junior\":budget1, \"senior\":budget2, ...}\n预算 = {级别：级别预算，zip 中的预算(levels,budget_results)}\n\n# 并行获取所有费用\n费用 = 等待 asyncio.gather(*[\n团队中 m 的 get_expenses(m[\"id\"], \"Q3\")\n]）\n\n# 查找超出差旅预算的员工\n超出=[]\n对于会员，exp in zip（团队，费用）：\n预算 = 预算[成员[\"级别\"]]\n总计 = sum(e[\"金额\"] for e in exp)\n如果总计 > 预算[“travel_limit”]：\n超出.append({\n“姓名”：成员[“姓名”]，\n“花费”：总计，\n“限制”：预算[“旅行限制”]\n})\n\nprint(json.dumps(超出))\n````\n\n克劳德的上下文只收到最终结果：超出预算的两到三个人。2,000 多个行项目、中间金额和预算查找不会影响 Claude 的上下文，从而将消耗量从 200KB 的原始费用数据减少到仅 1KB 的结果。\n\n效率提升是巨大的：\n\n- 节省代币：通过将中间结果排除在 Claude 的上下文之外，PTC 极大地减少了代币消耗。平均使用量从 43,588 个令牌下降到 27,297 个令牌，复杂研究任务减少了 37%。\n\n- 减少延迟：每个 API 往返都需要模型推理（数百毫秒到秒）。当 Claude 在单个代码块中协调 20 多个工具调用时，您可以消除 19 多个推理过程。API 处理工具执行，而无需每次都返回模型。\n\n- 提高准确性：通过编写明确的编排逻辑，Claude 比用自然语言处理多个工具结果时犯的错误更少。内部知识检索从25.6%提高到28.5%；GIA 基准从 46.5% 降至 51.2%。\n\n生产工作流程涉及混乱的数据、条件逻辑和需要扩展的操作。编程工具调用让 Claude 以编程方式处理这种复杂性，同时将重点放在可操作的结果而不是原始数据处理上。\n\n编程工具调用的工作原理\n\n1. 将工具标记为可从代码调用\n\n将 code_execution 添加到工具中，并将 allowed_callers 设置为选择加入工具以进行编程执行： ````\n{\n“工具”：[\n{\n“类型”：“code_execution_20250825”，\n“名称”：“代码执行”\n},\n{\n“名称”：“获取团队成员”，\n\"description\": \"获取部门的所有成员...\",\n“输入模式”：{...}，\n\"allowed_callers\": [\"code_execution_20250825\"] # 选择以编程方式调用工具\n},\n{\n“名称”：“获取费用”，\n...\n},\n{\n“名称”：“按级别获取预算”，\n...\n}\n]\n}\n````\n\nAPI 将这些工具定义转换为 Claude 可以调用的 Python 函数。\n\n2.Claude编写编排代码\n\nClaude 不是一次请求一个工具，而是生成 Python 代码：\n\n````\n{\n“类型”：“服务器工具使用”，\n“id”：“srvtoolu_abc”，\n“名称”：“代码执行”，\n“输入”：{\n\"code\": \"team = get_team_members('engineering')\\n...\" # 上面的代码示例\n}\n}\n````\n\n3. 工具在不影响 Claude 上下文的情况下执行\n\n当代码调用 get_expenses() 时，您会收到带有调用者字段的工具请求：\n\n````\n{\n“类型”：“工具使用”，\n“id”：“toolu_xyz”，\n“名称”：“获取费用”，\n\"input\": {\"user_id\": \"emp_123\", \"quarter\": \"Q3\"},\n“来电者”：{\n“类型”：“code_execution_20250825”，\n“tool_id”：“srvtoolu_abc”\n}\n}\n````\n\n您提供结果，该结果在代码执行环境而不是 Claude 的上下文中进行处理。对于代码中的每个工具调用，都会重复此请求-响应循环。\n\n4.只有最终输出才进入上下文\n\n当代码运行完毕后，只将代码的结果返回给Claude：\n\n````\n{\n“类型”：“代码执行工具结果”，\n\"tool_use_id\": \"srvtoolu_abc\",\n“内容”：{\n\"stdout\": \"[{\\\"name\\\": \\\"Alice\\\", \\\"spent\\\": 12500, \\\"limit\\\": 10000}...]\"\n}\n}\n````\n\n这就是 Claude 看到的全部内容，而不是一路上处理的 2000 多个费用行项目。\n\n何时使用编程工具调用\n\n编程工具调用向您的工作流程添加了代码执行步骤。当令牌节省、延迟改进和准确性提升显着时，这种额外的开销就会得到回报。\n\n在以下情况下最有益：\n\n- 处理只需要聚合或摘要的大型数据集\n\n- 通过三个或更多相关工具调用运行多步骤工作流程\n\n- 在克劳德看到工具结果之前对其进行过滤、排序或转换\n\n- 处理中间数据不应影响克劳德推理的任务\n\n- 跨多个项目运行并行操作（例如，检查 50 个端点）\n\n在以下情况下效果较差：\n\n- 进行简单的单一工具调用\n\n- 从事克劳德应该看到并推理所有中间结果的任务\n\n- 以较小的响应运行快速查找\n\n工具使用示例\n\n挑战\n\nJSON Schema 擅长定义结构类型、必填字段、允许的枚举，但它无法表达使用模式：何时包含可选参数、哪些组合有意义，或者您的 API 期望什么约定。\n\n考虑一个支持票证 API：\n\n````\n{\n“名称”：“创建票”，\n“输入模式”：{\n“属性”：{\n“标题”：{“类型”：“字符串”}，\n“优先级”：{“enum”：[“低”，“中”，“高”，“关键”]}，\n“标签”：{“类型”：“数组”，“项目”：{“类型”：“字符串”}}，\n“记者”：{\n“类型”：“对象”，\n“属性”：{\n“id”：{“类型”：“字符串”}，\n“名称”：{“类型”：“字符串”}，\n“联系方式”：{\n“类型”：“对象”，\n“属性”：{\n“电子邮件”：{“类型”：“字符串”}，\n“电话”：{“类型”：“字符串”}\n}\n}\n}\n},\n“到期日期”：{“类型”：“字符串”}，\n“升级”：{\n“类型”：“对象”，\n“属性”：{\n“级别”：{“类型”：“整数”}，\n\"notify_manager\": {\"type\": \"boolean\"},\n“sla_hours”：{“类型”：“整数”}\n}\n}\n},\n“必需”：[“标题”]\n}\n}\n````\n\n该模式定义了什么是有效的，但没有回答关键问题：\n\n- 格式不明确： due_date 应该使用“2024-11-06”、“2024 年 11 月 6 日”还是“2024-11-06T00:00:00Z”？\n\n- ID 约定：reporter.id 是 UUID、“USR-12345”还是只是“12345”？\n\n- 嵌套结构的使用：Claude 应该何时填充reporter.contact？\n\n- 参数相关性：escalation.level 和 escalation.sla_hours 与优先级有何关系？\n\n这些歧义可能导致格式错误的工具调用和不一致的参数使用。\n\n我们的解决方案\n\n工具使用示例让您可以直接在工具定义中提供示例工具调用。您不是仅仅依赖于模式，而是向 Claude 展示了具体的使用模式： ````\n{\n“名称”：“创建票”，\n\"input_schema\": { /* 与上面相同的模式 */ },\n“输入示例”：[\n{\n\"title\": \"登录页面返回500错误\",\n“优先级”：“关键”，\n\"labels\": [\"bug\", \"认证\", \"生产\"],\n“记者”：{\n“id”：“USR-12345”，\n“姓名”：“简·史密斯”，\n“联系方式”：{\n“电子邮件”：“jane@acme.com”，\n“电话”：“+1-555-0123”\n}\n},\n“到期日期”：“2024-11-06”，\n“升级”：{\n“级别”：2，\n“notify_manager”：正确，\n“sla_小时”：4\n}\n},\n{\n\"title\": \"添加深色模式支持\",\n“标签”：[“功能请求”，“ui”]，\n“记者”：{\n“id”：“USR-67890”，\n“姓名”：“亚历克斯·陈”\n}\n},\n{\n\"title\": \"更新API文档\"\n}\n]\n}\n````\n\n从这三个例子中，克劳德了解到：\n\n- 格式约定：日期使用 YYYY-MM-DD，用户 ID 遵循 USR-XXXXX，标签使用短横线大小写\n\n- 嵌套结构模式：如何使用嵌套的联系对象构造报告者对象\n\n- 可选参数相关性：关键错误具有完整的联系信息 + 具有严格 SLA 的升级；功能请求有记者但没有联系/升级；内部任务只有标题\n\n在我们自己的内部测试中，工具使用示例将复杂参数处理的准确性从 72% 提高到 90%。\n\n何时使用工具使用示例\n\n工具使用示例将标记添加到您的工具定义中，因此当准确性改进超过额外成本时，它们是最有价值的。\n\n在以下情况下最有益：\n\n- 复杂的嵌套结构，其中有效的 JSON 并不意味着正确的用法\n\n- 具有许多可选参数和包含模式的工具很重要\n\n- 具有特定领域约定的 API 未在模式中捕获\n\n- 类似的工具，其中的示例阐明了要使用哪一个（例如， create_ticket 与 create_incident ）\n\n在以下情况下效果较差：\n\n- 简单的单参数工具，用法一目了然\n\n- Claude 已经理解的标准格式，如 URL 或电子邮件\n\n- JSON Schema 约束可以更好地处理验证问题\n\n最佳实践\n\n构建采取现实世界行动的代理意味着同时处理规模、复杂性和精度。这三个功能共同解决工具使用工作流程中的不同瓶颈。以下是如何有效地将它们结合起来。\n\n战略性地分层特征\n\n并非每个代理都需要使用所有三个功能来完成给定的任务。从你最大的瓶颈开始：\n\n- 工具定义中的上下文膨胀工具搜索工具\n\n- 大量中间结果污染上下文编程工具调用\n\n- 参数错误和格式错误的调用工具使用示例\n\n这种集中的方法可以让您解决限制代理性能的特定约束，而不是预先增加复杂性。\n\n然后根据需要分层附加功能。它们是互补的：工具搜索工具确保找到正确的工具，编程工具调用确保高效执行，工具使用示例确保正确调用。\n\n设置工具搜索工具以更好地发现\n\n工具搜索与名称和描述相匹配，因此清晰的描述性定义可以提高发现的准确性。\n\n````\n// 好\n{\n“名称”：“搜索客户订单”，\n\"description\": \"按日期范围、状态或总金额搜索客户订单。返回订单详细信息，包括商品、运输和付款信息。\"\n}\n\n// 不好\n{\n“名称”：“query_db_orders”，\n\"description\": \"执行订单查询\"\n}\n````\n\n添加系统提示指导，以便 Claude 知道可用的内容：\n\n````\n您可以使用 Slack 消息传递、Google Drive 文件管理等工具\nJira 票证跟踪和 GitHub 存储库操作。使用工具搜索\n寻找特定的能力。\n````\n\n始终加载三到五个最常用的工具，推迟其余的。这可以平衡常见操作的即时访问与其他所有内容的按需发现。\n\n设置编程工具调用以正确执行\n\n由于 Claude 编写代码来解析工具输出，因此文档返回格式清晰。这有助于 Claude 编写正确的解析逻辑： ````\n{\n“名称”：“获取订单”，\n\"description\": \"检索客户的订单。\n返回：\n订单对象列表，每个对象包含：\n- id (str): 订单标识符\n- 总计（浮点数）：订单总计（美元）\n- 状态 (str)：“待处理”、“已发货”、“已交付”之一\n- 项目（列表）：{sku，数量，价格}的数组\n-created_at（str）：ISO 8601 时间戳”\n}\n````\n\n请参阅下文，了解受益于程序化编排的选择加入工具：\n\n- 可以并行运行的工具（独立操作）\n\n- 操作可以安全重试（幂等）\n\n设置工具使用示例以确保参数准确性\n\n行为清晰的工艺示例：\n\n- 使用真实的数据（真实的城市名称、合理的价格，而不是“字符串”或“值”）\n\n- 以最小、部分和完整规格模式显示多样性\n\n- 保持简洁：每个工具 1-5 个示例\n\n- 关注歧义（仅添加模式中正确用法不明显的示例）\n\n开始使用\n\n这些功能在测试版中可用。要启用它们，请添加 beta 标头并包含您需要的工具：\n\n````\n客户端.beta.messages.create(\nbetas=[\"高级工具使用-2025-11-20\"],\n模型=“克劳德-sonnet-4-5-20250929”，\n最大令牌=4096，\n工具=[\n{“类型”：“tool_search_tool_regex_20251119”，“名称”：“tool_search_tool_regex”}，\n{“类型”：“code_execution_20250825”，“名称”：“code_execution”}，\n# 您的工具包含 defer_loading、allowed_callers 和 input_examples\n]\n）\n````\n\n有关详细的 API 文档和 SDK 示例，请参阅我们的：\n\n- 工具搜索工具的文档和食谱\n\n- 编程工具调用的文档和食谱\n\n- 工具使用示例文档\n\n这些功能将工具的使用从简单的函数调用转向智能编排。随着代理处理涉及数十种工具和大型数据集的更复杂的工作流程，动态发现、高效执行和可靠调用成为基础。\n\n我们很高兴看到您所构建的内容。\n\n致谢\n\n由 Bin Wu 编写，Adam Jones、Artur Renault、Henry Tay、Jake Noble、Nathan McCandlish、Noah Picard、Sam Jiang 和 Claude 开发者平台团队的贡献。这项工作建立在 Chris Gorgolewski、Daniel Jiang、Jeremy Fox 和 Mike Lambert 的基础研究的基础上。我们还从整个 AI 生态系统中汲取灵感，包括 Joel Pobar 的 LLMVM、Cloudflare 的代码模式和 MCP 代码执行。特别感谢 Andy Schumeister、Hamish Kerr、Keir Bradwell、Matt Bleifer 和 Molly Vorwerck 的支持。",
      "edited": false
    },
    "hi": {
      "title": "क्लाउड डेवलपर प्लेटफ़ॉर्म पर उन्नत टूल उपयोग का परिचय",
      "content": "एआई एजेंटों का भविष्य वह है जहां मॉडल सैकड़ों या हजारों उपकरणों पर निर्बाध रूप से काम करते हैं।एक आईडीई सहायक जो गिट संचालन, फ़ाइल हेरफेर, पैकेज प्रबंधक, परीक्षण ढांचे और तैनाती पाइपलाइनों को एकीकृत करता है।एक संचालन समन्वयक जो स्लैक, गिटहब, गूगल ड्राइव, जीरा, कंपनी डेटाबेस और दर्जनों एमसीपी सर्वरों को एक साथ जोड़ता है।\n\nप्रभावी एजेंट बनाने के लिए, उन्हें हर परिभाषा को पहले से संदर्भ में डाले बिना असीमित टूल लाइब्रेरी के साथ काम करने की आवश्यकता है।एमसीपी के साथ कोड निष्पादन का उपयोग करने पर हमारे ब्लॉग लेख में चर्चा की गई है कि एजेंट के अनुरोध को पढ़ने से पहले टूल परिणाम और परिभाषाएँ कभी-कभी 50,000+ टोकन का उपभोग कैसे कर सकती हैं।एजेंटों को केवल वर्तमान कार्य के लिए प्रासंगिक टूल को ध्यान में रखते हुए ऑन-डिमांड टूल की खोज और लोड करना चाहिए।\n\nएजेंटों को कोड से टूल कॉल करने की क्षमता की भी आवश्यकता होती है।प्राकृतिक भाषा टूल कॉलिंग का उपयोग करते समय, प्रत्येक आह्वान के लिए पूर्ण अनुमान पास की आवश्यकता होती है, और मध्यवर्ती परिणाम संदर्भ में ढेर हो जाते हैं, चाहे वे उपयोगी हों या नहीं।कोड ऑर्केस्ट्रेशन लॉजिक, जैसे लूप, कंडीशनल और डेटा ट्रांसफ़ॉर्मेशन के लिए स्वाभाविक रूप से फिट है।एजेंटों को कार्य के आधार पर कोड निष्पादन और अनुमान के बीच चयन करने की लचीलेपन की आवश्यकता होती है।\n\nएजेंटों को केवल स्कीमा परिभाषाओं से ही नहीं, बल्कि उदाहरणों से भी उपकरण का सही उपयोग सीखने की जरूरत है।JSON स्कीमा परिभाषित करते हैं कि संरचनात्मक रूप से क्या मान्य है, लेकिन उपयोग पैटर्न को व्यक्त नहीं कर सकते: वैकल्पिक पैरामीटर कब शामिल करना है, कौन सा संयोजन समझ में आता है, या आपका एपीआई किन सम्मेलनों की अपेक्षा करता है।\n\nआज, हम तीन सुविधाएँ जारी कर रहे हैं जो इसे संभव बनाती हैं:\n\n- टूल सर्च टूल, जो क्लाउड को अपनी संदर्भ विंडो का उपभोग किए बिना हजारों टूल तक पहुंचने के लिए खोज टूल का उपयोग करने की अनुमति देता है\n\n- प्रोग्रामेटिक टूल कॉलिंग, जो क्लाउड को मॉडल के संदर्भ विंडो पर प्रभाव को कम करने वाले कोड निष्पादन वातावरण में टूल को लागू करने की अनुमति देता है\n\n- टूल उपयोग उदाहरण, जो किसी दिए गए टूल का प्रभावी ढंग से उपयोग करने के तरीके को प्रदर्शित करने के लिए एक सार्वभौमिक मानक प्रदान करता है\n\nआंतरिक परीक्षण में, हमने पाया है कि इन सुविधाओं ने हमें ऐसी चीजें बनाने में मदद की है जो पारंपरिक उपकरण उपयोग पैटर्न के साथ संभव नहीं होती।उदाहरण के लिए, एक्सेल के लिए क्लाउड मॉडल की संदर्भ विंडो को ओवरलोड किए बिना हजारों पंक्तियों वाली स्प्रेडशीट को पढ़ने और संशोधित करने के लिए प्रोग्रामेटिक टूल कॉलिंग का उपयोग करता है।\n\nहमारे अनुभव के आधार पर, हमारा मानना ​​है कि ये सुविधाएँ क्लाउड के साथ आप जो कुछ भी बना सकते हैं उसके लिए नई संभावनाएँ खोलती हैं।\n\nउपकरण खोज उपकरण\n\nचुनौती\n\nएमसीपी टूल परिभाषाएँ महत्वपूर्ण संदर्भ प्रदान करती हैं, लेकिन जैसे-जैसे अधिक सर्वर जुड़ते हैं, वे टोकन जुड़ सकते हैं।पाँच-सर्वर सेटअप पर विचार करें:\n\n- GitHub: 35 उपकरण (~26K टोकन)\n\n- स्लैक: 11 टूल्स (~21K टोकन)\n\n- संतरी: 5 उपकरण (~3K टोकन)\n\n- ग्राफाना: 5 उपकरण (~3K टोकन)\n\n- स्प्लंक: 2 उपकरण (~2K टोकन)\n\nबातचीत शुरू होने से पहले ही 58 टूल लगभग 55K टोकन का उपभोग कर रहे हैं।जिरा जैसे और सर्वर जोड़ें (जो अकेले ~17K टोकन का उपयोग करता है) और आप तेजी से 100K+ टोकन ओवरहेड के करीब पहुंच रहे हैं।एंथ्रोपिक में, हमने देखा है कि टूल परिभाषाएँ अनुकूलन से पहले 134K टोकन का उपभोग करती हैं।\n\nलेकिन टोकन लागत ही एकमात्र मुद्दा नहीं है।सबसे आम विफलताएं गलत टूल चयन और गलत पैरामीटर हैं, खासकर जब टूल के समान नाम होते हैं जैसे अधिसूचना-भेजें-उपयोगकर्ता बनाम अधिसूचना-भेजें-चैनल।\n\nहमारा समाधान\n\nसभी टूल परिभाषाओं को पहले से लोड करने के बजाय, टूल सर्च टूल ऑन-डिमांड टूल खोजता है।क्लाउड केवल उन उपकरणों को देखता है जिनकी उसे वर्तमान कार्य के लिए वास्तव में आवश्यकता होती है।\n\n[[IMAGE_1|टूल सर्च टूल क्लाउड के पारंपरिक दृष्टिकोण के 122,800 की तुलना में संदर्भ के 191,300 टोकन सुरक्षित रखता है।]]\n\nपारंपरिक दृष्टिकोण:\n\n- सभी टूल परिभाषाएँ अग्रिम रूप से लोड की गईं (50+ MCP टूल के लिए ~72K टोकन)\n\n- वार्तालाप इतिहास और सिस्टम प्रॉम्प्ट शेष स्थान के लिए प्रतिस्पर्धा करते हैं\n\n- कुल संदर्भ खपत: कोई भी कार्य शुरू होने से पहले ~77K टोकन\n\nटूल सर्च टूल के साथ:\n\n- केवल टूल सर्च टूल अग्रिम रूप से लोड किया गया (~500 टोकन)\n\n- आवश्यकतानुसार ऑन-डिमांड खोजे गए उपकरण (3-5 प्रासंगिक उपकरण, ~3K टोकन)\n\n- कुल संदर्भ खपत: ~8.7K टोकन, 95% संदर्भ विंडो को संरक्षित करना\n\nयह आपकी संपूर्ण टूल लाइब्रेरी तक पहुंच बनाए रखते हुए टोकन उपयोग में 85% की कमी दर्शाता है।बड़े उपकरण पुस्तकालयों के साथ काम करते समय आंतरिक परीक्षण ने एमसीपी मूल्यांकन पर महत्वपूर्ण सटीकता में सुधार दिखाया।टूल सर्च टूल सक्षम होने पर ओपस 4 49% से 74% तक सुधरा, और ओपस 4.5 79.5% से सुधरकर 88.1% हो गया।\n\nटूल सर्च टूल कैसे काम करता है टूल सर्च टूल क्लाउड को सभी परिभाषाओं को पहले से लोड करने के बजाय गतिशील रूप से टूल खोजने की सुविधा देता है।आप एपीआई को अपनी सभी टूल परिभाषाएँ प्रदान करते हैं, लेकिन टूल को ऑन-डिमांड खोजने योग्य बनाने के लिए defer_loading: true के साथ चिह्नित करते हैं।प्रारंभ में विलंबित उपकरण क्लाउड के संदर्भ में लोड नहीं किए गए हैं।क्लाउड केवल टूल सर्च टूल और defer_loading: false (आपके सबसे महत्वपूर्ण, अक्सर उपयोग किए जाने वाले टूल) वाले किसी भी टूल को देखता है।\n\nजब क्लाउड को विशिष्ट क्षमताओं की आवश्यकता होती है, तो वह प्रासंगिक टूल की खोज करता है।टूल सर्च टूल मिलान करने वाले टूल के संदर्भ लौटाता है, जो क्लाउड के संदर्भ में पूर्ण परिभाषाओं में विस्तारित हो जाते हैं।\n\nउदाहरण के लिए, यदि क्लाउड को GitHub के साथ इंटरैक्ट करने की आवश्यकता है, तो वह \"github\" खोजता है और केवल github.createPullRequest और github.listIssues लोड होते हैं-स्लैक, जिरा और Google ड्राइव से आपके अन्य 50+ टूल नहीं।\n\nइस तरह, क्लाउड को आपकी पूरी टूल लाइब्रेरी तक पहुंच प्राप्त हो जाती है, जबकि उसे वास्तव में आवश्यक टूल के लिए केवल टोकन लागत का भुगतान करना पड़ता है।\n\nप्रॉम्प्ट कैशिंग नोट: टूल सर्च टूल प्रॉम्प्ट कैशिंग को नहीं तोड़ता है क्योंकि विलंबित टूल को प्रारंभिक प्रॉम्प्ट से पूरी तरह से बाहर रखा गया है।क्लाउड द्वारा उनकी खोज करने के बाद ही उन्हें संदर्भ में जोड़ा जाता है, इसलिए आपके सिस्टम प्रॉम्प्ट और कोर टूल परिभाषाएँ कैश करने योग्य बनी रहती हैं।\n\nकार्यान्वयन:\n\n```\n{\n\"उपकरण\": [\n// एक टूल सर्च टूल शामिल करें (रेगेक्स, बीएम25, या कस्टम)\n{\"प्रकार\": \"टूल_सर्च_टूल_रेगेक्स_20251119\", \"नाम\": \"टूल_सर्च_टूल_रेगेक्स\"},\n\n// ऑन-डिमांड खोज के लिए उपकरण चिह्नित करें\n{\n\"नाम\": \"github.createPullRequest\",\n\"विवरण\": \"एक पुल अनुरोध बनाएँ\",\n\"इनपुट_स्कीमा\": {...},\n\"defer_loading\": सत्य\n}\n// ... defer_loading के साथ सैकड़ों और स्थगित उपकरण: सत्य\n]\n}\n```\n\nएमसीपी सर्वरों के लिए, आप विशिष्ट उच्च-उपयोग टूल लोड रखते हुए संपूर्ण सर्वर लोड करना स्थगित कर सकते हैं:\n\n```\n{\n\"प्रकार\": \"mcp_toolset\",\n\"mcp_server_name\": \"google-drive\",\n\"default_config\": {\"defer_loading\": true}, # संपूर्ण सर्वर को लोड करना स्थगित करें\n\"कॉन्फ़िगरेशन\": {\n\"खोज_फ़ाइलें\": {\n\"defer_loading\": गलत\n} // सर्वाधिक उपयोग किये जाने वाले टूल को लोड रखें\n}\n}\n```\n\nक्लाउड डेवलपर प्लेटफ़ॉर्म रेगेक्स-आधारित और BM25-आधारित खोज टूल को बॉक्स से बाहर प्रदान करता है, लेकिन आप एम्बेडिंग या अन्य रणनीतियों का उपयोग करके कस्टम खोज टूल भी लागू कर सकते हैं।\n\nटूल सर्च टूल का उपयोग कब करें\n\nकिसी भी वास्तुशिल्प निर्णय की तरह, टूल सर्च टूल को सक्षम करने में ट्रेड-ऑफ़ शामिल होता है।टूल इनवोकेशन से पहले यह सुविधा एक खोज चरण जोड़ती है, इसलिए जब संदर्भ बचत और सटीकता में सुधार अतिरिक्त विलंबता से अधिक हो जाता है तो यह सर्वोत्तम आरओआई प्रदान करता है।\n\nइसका उपयोग तब करें जब:\n\n- टूल परिभाषाएँ >10K टोकन का उपभोग करती हैं\n\n- उपकरण चयन सटीकता संबंधी समस्याओं का अनुभव करना\n\n- कई सर्वरों के साथ एमसीपी-संचालित सिस्टम का निर्माण\n\n- 10+ उपकरण उपलब्ध हैं\n\nकम लाभकारी जब:\n\n- छोटी टूल लाइब्रेरी (<10 टूल)\n\n- प्रत्येक सत्र में बार-बार उपयोग किए जाने वाले सभी उपकरण\n\n- टूल परिभाषाएँ संक्षिप्त हैं\n\nप्रोग्रामेटिक टूल कॉलिंग\n\nचुनौती\n\nपारंपरिक टूल कॉलिंग दो मूलभूत समस्याएं पैदा करती है क्योंकि वर्कफ़्लो अधिक जटिल हो जाता है:\n\n- मध्यवर्ती परिणामों से संदर्भ प्रदूषण: जब क्लाउड त्रुटि पैटर्न के लिए 10 एमबी लॉग फ़ाइल का विश्लेषण करता है, तो पूरी फ़ाइल इसकी संदर्भ विंडो में प्रवेश करती है, भले ही क्लाउड को केवल त्रुटि आवृत्तियों के सारांश की आवश्यकता होती है।कई तालिकाओं में ग्राहक डेटा लाते समय, प्रत्येक रिकॉर्ड प्रासंगिकता की परवाह किए बिना संदर्भ में जमा होता है।ये मध्यवर्ती परिणाम बड़े पैमाने पर टोकन बजट का उपभोग करते हैं और महत्वपूर्ण जानकारी को संदर्भ विंडो से पूरी तरह बाहर धकेल सकते हैं।\n\n- अनुमान ओवरहेड और मैन्युअल संश्लेषण: प्रत्येक टूल कॉल के लिए पूर्ण मॉडल अनुमान पास की आवश्यकता होती है।परिणाम प्राप्त करने के बाद, क्लाउड को प्रासंगिक जानकारी निकालने के लिए डेटा पर \"आँख\" लगानी होगी, टुकड़े एक साथ कैसे फिट होते हैं इसके बारे में तर्क करना होगा, और प्राकृतिक भाषा प्रसंस्करण के माध्यम से आगे क्या करना है यह तय करना होगा।पांच टूल वर्कफ़्लो का अर्थ है पांच अनुमान पास करना और साथ ही क्लाउड द्वारा प्रत्येक परिणाम को पार्स करना, मूल्यों की तुलना करना और निष्कर्षों को संश्लेषित करना।यह धीमा और त्रुटि-प्रवण दोनों है।\n\nहमारा समाधान\n\nप्रोग्रामेटिक टूल कॉलिंग क्लाउड को व्यक्तिगत एपीआई राउंड-ट्रिप के बजाय कोड के माध्यम से टूल को व्यवस्थित करने में सक्षम बनाती है।क्लाउड द्वारा प्रत्येक परिणाम को उसके संदर्भ में लौटाए जाने के साथ एक समय में एक टूल का अनुरोध करने के बजाय, क्लाउड कोड लिखता है जो कई टूल को कॉल करता है, उनके आउटपुट को संसाधित करता है, और नियंत्रित करता है कि कौन सी जानकारी वास्तव में इसकी संदर्भ विंडो में प्रवेश करती है। क्लाउड कोड लिखने में उत्कृष्ट है और इसे प्राकृतिक भाषा टूल इनवोकेशन के बजाय पायथन में ऑर्केस्ट्रेशन तर्क व्यक्त करने की अनुमति देकर, आपको अधिक विश्वसनीय, सटीक नियंत्रण प्रवाह मिलता है।लूप्स, कंडीशनल्स, डेटा ट्रांसफॉर्मेशन और एरर हैंडलिंग सभी क्लाउड के तर्क में निहित होने के बजाय कोड में स्पष्ट हैं।\n\nउदाहरण: बजट अनुपालन जाँच\n\nएक सामान्य व्यावसायिक कार्य पर विचार करें: \"किस टीम के सदस्यों ने अपने Q3 यात्रा बजट को पार कर लिया?\"\n\nआपके पास तीन उपकरण उपलब्ध हैं:\n\n- get_team_members(विभाग) - आईडी और स्तरों के साथ टीम सदस्य सूची लौटाता है\n\n- get_expenses(user_id, तिमाही) - उपयोगकर्ता के लिए व्यय लाइन आइटम लौटाता है\n\n- get_budget_by_level(level) - कर्मचारी स्तर के लिए बजट सीमा लौटाता है\n\nपारंपरिक दृष्टिकोण:\n\n- टीम के सदस्यों को 20 लोगों को लाएं\n\n- प्रत्येक व्यक्ति के लिए, उनके Q3 खर्चों के लिए 20 टूल कॉल प्राप्त करें, प्रत्येक में 50-100 लाइन आइटम (उड़ानें, होटल, भोजन, रसीदें) हों।\n\n- कर्मचारी स्तर के अनुसार बजट सीमा प्राप्त करें\n\n- यह सब क्लाउड के संदर्भ में शामिल है: 2,000+ व्यय पंक्ति आइटम (50 KB+)\n\n- क्लाउड मैन्युअल रूप से प्रत्येक व्यक्ति के खर्चों का योग करता है, उनके बजट को देखता है, बजट सीमाओं के विरुद्ध खर्चों की तुलना करता है\n\n- मॉडल के लिए अधिक राउंड-ट्रिप, महत्वपूर्ण संदर्भ खपत\n\nप्रोग्रामेटिक टूल कॉलिंग के साथ:\n\nप्रत्येक टूल परिणाम क्लाउड पर लौटने के बजाय, क्लाउड एक पायथन स्क्रिप्ट लिखता है जो संपूर्ण वर्कफ़्लो को व्यवस्थित करता है।स्क्रिप्ट कोड एक्ज़ीक्यूशन टूल (एक सैंडबॉक्स्ड वातावरण) में चलती है, जब इसे आपके टूल से परिणामों की आवश्यकता होती है तो रुक जाती है।जब आप एपीआई के माध्यम से टूल परिणाम लौटाते हैं, तो उन्हें मॉडल द्वारा उपभोग किए जाने के बजाय स्क्रिप्ट द्वारा संसाधित किया जाता है।स्क्रिप्ट क्रियान्वित होती रहती है और क्लाउड केवल अंतिम आउटपुट देखता है।\n\n[[IMAGE_2|प्रोग्रामेटिक टूल कॉलिंग क्लाउड को अलग-अलग एपीआई राउंड-ट्रिप्स के बजाय कोड के माध्यम से टूल को ऑर्केस्ट्रेट करने में सक्षम बनाता है, जिससे समानांतर टूल निष्पादन की अनुमति मिलती है।]]\n\nबजट अनुपालन कार्य के लिए क्लाउड का ऑर्केस्ट्रेशन कोड इस प्रकार दिखता है:\n\n```\nटीम = प्रतीक्षा करें get_team_members(\"इंजीनियरिंग\")\n\n# प्रत्येक अद्वितीय स्तर के लिए बजट प्राप्त करें\nस्तर = सूची(सेट(एम[\"स्तर\"] टीम में एम के लिए))\nबजट_परिणाम = प्रतीक्षा करें asyncio.gather(*[\nस्तरों में स्तर के लिए get_budget_by_level(level)।\n])\n\n# एक लुकअप डिक्शनरी बनाएं: {\"जूनियर\": बजट1, \"सीनियर\": बजट2, ...}\nबजट = {स्तर: स्तर के लिए बजट, ज़िप में बजट(स्तर, बजट_परिणाम)}\n\n# सभी खर्चों को समानांतर रूप से प्राप्त करें\nव्यय = asyncio.gather की प्रतीक्षा करें(*[\nटीम में एम के लिए get_expenses(m[\"id\"], \"Q3\")\n])\n\n# ऐसे कर्मचारियों को ढूंढें जिन्होंने अपने यात्रा बजट को पार कर लिया है\nपार हो गया = []\nसदस्य के लिए, ज़िप में क्स्प (टीम, व्यय):\nबजट = बजट[सदस्य[\"स्तर\"]]\nकुल = योग(ई[\"राशि\"] ई के लिए ऍक्स्प में)\nयदि कुल > बजट[\"यात्रा_सीमा\"]:\nअधिक.जोड़ें({\n\"नाम\": सदस्य[\"नाम\"],\n\"खर्च\": कुल,\n\"सीमा\": बजट[\"यात्रा_सीमा\"]\n})\n\nप्रिंट(json.dumps(पार हो गया))\n```\n\nक्लाउड के संदर्भ से केवल अंतिम परिणाम प्राप्त होता है: दो से तीन लोग जिन्होंने अपना बजट पार कर लिया।2,000 से अधिक लाइन आइटम, मध्यवर्ती रकम और बजट लुकअप क्लाउड के संदर्भ को प्रभावित नहीं करते हैं, जिससे खपत 200KB कच्चे व्यय डेटा से घटकर केवल 1KB परिणाम रह जाती है।\n\nदक्षता लाभ पर्याप्त हैं:\n\n- टोकन बचत: मध्यवर्ती परिणामों को क्लाउड के संदर्भ से बाहर रखकर, पीटीसी नाटकीय रूप से टोकन खपत को कम कर देता है।औसत उपयोग 43,588 से घटकर 27,297 टोकन हो गया, जो जटिल अनुसंधान कार्यों पर 37% की कमी है।\n\n- कम विलंबता: प्रत्येक एपीआई राउंड-ट्रिप के लिए मॉडल अनुमान (सैकड़ों मिलीसेकंड से सेकंड) की आवश्यकता होती है।जब क्लाउड एक एकल कोड ब्लॉक में 20+ टूल कॉल को व्यवस्थित करता है, तो आप 19+ अनुमान पास को हटा देते हैं।एपीआई हर बार मॉडल पर वापस आए बिना टूल निष्पादन को संभालता है।\n\n- बेहतर सटीकता: स्पष्ट ऑर्केस्ट्रेशन तर्क लिखकर, क्लाउड प्राकृतिक भाषा में एकाधिक टूल परिणामों को संयोजित करने की तुलना में कम त्रुटियां करता है।आंतरिक ज्ञान पुनर्प्राप्ति 25.6% से बढ़कर 28.5% हो गई;जीआईए बेंचमार्क 46.5% से 51.2% तक।\n\nउत्पादन वर्कफ़्लो में गड़बड़ डेटा, सशर्त तर्क और संचालन शामिल होते हैं जिन्हें स्केल करने की आवश्यकता होती है।प्रोग्रामेटिक टूल कॉलिंग क्लाउड को कच्चे डेटा प्रोसेसिंग के बजाय कार्रवाई योग्य परिणामों पर अपना ध्यान केंद्रित करते हुए उस जटिलता को प्रोग्रामेटिक रूप से संभालने की सुविधा देता है।\n\nप्रोग्रामेटिक टूल कॉलिंग कैसे काम करती है\n\n1. टूल को कोड से कॉल करने योग्य के रूप में चिह्नित करें\n\nटूल में कोड_एक्ज़ीक्यूशन जोड़ें, और प्रोग्रामेटिक निष्पादन के लिए ऑप्ट-इन टूल में अनुमति_कॉलर्स सेट करें: ```\n{\n\"उपकरण\": [\n{\n\"प्रकार\": \"code_execution_20250825\",\n\"नाम\": \"कोड_निष्पादन\"\n},\n{\n\"नाम\": \"get_team_members\",\n\"विवरण\": \"विभाग के सभी सदस्यों को प्राप्त करें...\",\n\"इनपुट_स्कीमा\": {...},\n\"allowed_callers\": [\"code_execution_20250825\"] # प्रोग्रामेटिक टूल कॉलिंग के लिए ऑप्ट-इन करें\n},\n{\n\"नाम\": \"get_expenses\",\n...\n},\n{\n\"नाम\": \"get_budget_by_level\",\n...\n}\n]\n}\n```\n\nएपीआई इन टूल परिभाषाओं को पायथन फ़ंक्शंस में परिवर्तित करता है जिन्हें क्लाउड कॉल कर सकता है।\n\n2. क्लाउड ऑर्केस्ट्रेशन कोड लिखता है\n\nएक समय में एक उपकरण का अनुरोध करने के बजाय, क्लाउड पायथन कोड उत्पन्न करता है:\n\n```\n{\n\"प्रकार\": \"सर्वर_टूल_उपयोग\",\n\"आईडी\": \"srvtoolu_abc\",\n\"नाम\": \"कोड_निष्पादन\",\n\"इनपुट\": {\n\"कोड\": \"टीम = get_team_members('इंजीनियरिंग')\\n...\" # उपरोक्त कोड उदाहरण\n}\n}\n```\n\n3. उपकरण क्लाउड के संदर्भ से टकराए बिना निष्पादित होते हैं\n\nजब कोड get_expenses() को कॉल करता है, तो आपको कॉलर फ़ील्ड के साथ एक टूल अनुरोध प्राप्त होता है:\n\n```\n{\n\"प्रकार\": \"टूल_यूज़\",\n\"आईडी\": \"टूलू_xyz\",\n\"नाम\": \"get_expenses\",\n\"इनपुट\": {\"user_id\": \"emp_123\", \"तिमाही\": \"Q3\"},\n\"कॉलर\": {\n\"प्रकार\": \"code_execution_20250825\",\n\"टूल_आईडी\": \"srvtoolu_abc\"\n}\n}\n```\n\nआप परिणाम प्रदान करते हैं, जिसे क्लाउड के संदर्भ के बजाय कोड निष्पादन वातावरण में संसाधित किया जाता है।यह अनुरोध-प्रतिक्रिया चक्र कोड में प्रत्येक टूल कॉल के लिए दोहराता है।\n\n4. केवल अंतिम आउटपुट ही संदर्भ में प्रवेश करता है\n\nजब कोड चलना समाप्त हो जाता है, तो केवल कोड के परिणाम क्लाउड को लौटाए जाते हैं:\n\n```\n{\n\"प्रकार\": \"code_execution_tool_result\",\n\"tool_use_id\": \"srvtoolu_abc\",\n\"सामग्री\": {\n\"स्टडआउट\": \"[{\\\"नाम\\\": \"ऐलिस\\\", \"खर्च\\\": 12500, \"सीमा\\\": 10000}...]\"\n}\n}\n```\n\nक्लाउड यही सब देखता है, न कि रास्ते में संसाधित की गई 2000 से अधिक व्यय पंक्ति की वस्तुएँ।\n\nप्रोग्रामेटिक टूल कॉलिंग का उपयोग कब करें\n\nप्रोग्रामेटिक टूल कॉलिंग आपके वर्कफ़्लो में एक कोड निष्पादन चरण जोड़ता है।यह अतिरिक्त ओवरहेड तब फायदेमंद होता है जब टोकन बचत, विलंबता सुधार और सटीकता लाभ पर्याप्त होते हैं।\n\nसबसे अधिक लाभकारी जब:\n\n- बड़े डेटासेट को संसाधित करना जहां आपको केवल समुच्चय या सारांश की आवश्यकता होती है\n\n- तीन या अधिक निर्भर टूल कॉल के साथ मल्टी-स्टेप वर्कफ़्लो चलाना\n\n- क्लाउड द्वारा देखे जाने से पहले टूल परिणामों को फ़िल्टर करना, सॉर्ट करना या रूपांतरित करना\n\n- ऐसे कार्यों को संभालना जहां मध्यवर्ती डेटा क्लाउड के तर्क को प्रभावित नहीं करना चाहिए\n\n- कई वस्तुओं पर समानांतर संचालन चलाना (उदाहरण के लिए 50 समापन बिंदुओं की जाँच करना)\n\nकम लाभकारी जब:\n\n- सरल एकल-उपकरण मंगलाचरण बनाना\n\n- उन कार्यों पर काम करना जहां क्लाउड को सभी मध्यवर्ती परिणामों को देखना और तर्क करना चाहिए\n\n- छोटी प्रतिक्रियाओं के साथ त्वरित लुकअप चलाना\n\nउपकरण उपयोग के उदाहरण\n\nचुनौती\n\nJSON स्कीमा संरचना-प्रकार, आवश्यक फ़ील्ड, अनुमत एनम को परिभाषित करने में उत्कृष्टता प्राप्त करती है - लेकिन यह उपयोग पैटर्न को व्यक्त नहीं कर सकती है: वैकल्पिक पैरामीटर कब शामिल करना है, कौन सा संयोजन समझ में आता है, या आपका एपीआई किन सम्मेलनों की अपेक्षा करता है।\n\nएक समर्थन टिकट एपीआई पर विचार करें:\n\n```\n{\n\"नाम\": \"create_ticket\",\n\"इनपुट_स्कीमा\": {\n\"गुण\": {\n\"शीर्षक\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"प्राथमिकता\": {\"एनम\": [\"निम्न\", \"मध्यम\", \"उच्च\", \"महत्वपूर्ण\"]},\n\"लेबल\": {\"प्रकार\": \"सरणी\", \"आइटम\": {\"प्रकार\": \"स्ट्रिंग\"}},\n\"रिपोर्टर\": {\n\"प्रकार\": \"ऑब्जेक्ट\",\n\"गुण\": {\n\"आईडी\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"नाम\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"संपर्क करें\": {\n\"प्रकार\": \"ऑब्जेक्ट\",\n\"गुण\": {\n\"ईमेल\": {\"प्रकार\": \"स्ट्रिंग\"},\n\"फ़ोन\": {\"प्रकार\": \"स्ट्रिंग\"}\n}\n}\n}\n},\n\"due_date\": {\"type\": \"string\"},\n\"वृद्धि\": {\n\"प्रकार\": \"ऑब्जेक्ट\",\n\"गुण\": {\n\"स्तर\": {\"प्रकार\": \"पूर्णांक\"},\n\"notify_manager\": {\"type\": \"boolean\"},\n\"sla_hours\": {\"type\": \"integer\"}\n}\n}\n},\n\"आवश्यक\": [\"शीर्षक\"]\n}\n}\n```\n\nस्कीमा परिभाषित करती है कि क्या मान्य है, लेकिन महत्वपूर्ण प्रश्नों को अनुत्तरित छोड़ देता है:\n\n- प्रारूप अस्पष्टता: क्या ड्यू_डेट में \"2024-11-06\", \"नवंबर 6, 2024\", या \"2024-11-06T00:00:00Z\" का उपयोग किया जाना चाहिए?\n\n- आईडी परंपराएं: क्या रिपोर्टर.आईडी एक यूयूआईडी है, \"यूएसआर-12345\", या सिर्फ \"12345\"?\n\n- नेस्टेड संरचना का उपयोग: क्लाउड को रिपोर्टर.संपर्क को कब पॉप्युलेट करना चाहिए?\n\n- पैरामीटर सहसंबंध: एस्केलेशन.लेवल और एस्केलेशन.sla_hours प्राथमिकता से कैसे संबंधित हैं?\n\nये अस्पष्टताएं विकृत टूल कॉल और असंगत पैरामीटर उपयोग का कारण बन सकती हैं।\n\nहमारा समाधान\n\nटूल उपयोग उदाहरण आपको सीधे अपनी टूल परिभाषाओं में नमूना टूल कॉल प्रदान करने देते हैं।केवल स्कीमा पर निर्भर रहने के बजाय, आप क्लाउड कंक्रीट उपयोग पैटर्न दिखाते हैं: ```\n{\n\"नाम\": \"create_ticket\",\n\"input_schema\": {/* उपरोक्त जैसा ही स्कीमा */ },\n\"इनपुट_उदाहरण\": [\n{\n\"शीर्षक\": \"लॉगिन पेज 500 त्रुटि देता है\",\n\"प्राथमिकता\": \"महत्वपूर्ण\",\n\"लेबल\": [\"बग\", \"प्रमाणीकरण\", \"उत्पादन\"],\n\"रिपोर्टर\": {\n\"आईडी\": \"यूएसआर-12345\",\n\"नाम\": \"जेन स्मिथ\",\n\"संपर्क करें\": {\n\"ईमेल\": \"jane@acme.com\",\n\"फ़ोन\": \"+1-555-0123\"\n}\n},\n\"नियत तिथि\": \"2024-11-06\",\n\"वृद्धि\": {\n\"स्तर\": 2,\n\"सूचित_प्रबंधक\": सत्य,\n\"sla_hours\": 4\n}\n},\n{\n\"शीर्षक\": \"डार्क मोड समर्थन जोड़ें\",\n\"लेबल\": [\"फ़ीचर-अनुरोध\", \"यूआई\"],\n\"रिपोर्टर\": {\n\"आईडी\": \"यूएसआर-67890\",\n\"नाम\": \"एलेक्स चेन\"\n}\n},\n{\n\"शीर्षक\": \"एपीआई दस्तावेज़ अपडेट करें\"\n}\n]\n}\n```\n\nइन तीन उदाहरणों से, क्लाउड सीखता है:\n\n- प्रारूप परंपराएँ: दिनांक YYYY-MM-DD का उपयोग करते हैं, उपयोगकर्ता आईडी USR-XXXXX का पालन करते हैं, लेबल कबाब-केस का उपयोग करते हैं\n\n- नेस्टेड संरचना पैटर्न: नेस्टेड संपर्क ऑब्जेक्ट के साथ रिपोर्टर ऑब्जेक्ट का निर्माण कैसे करें\n\n- वैकल्पिक पैरामीटर सहसंबंध: गंभीर बग में पूर्ण संपर्क जानकारी + सख्त एसएलए के साथ वृद्धि होती है;फीचर अनुरोधों में रिपोर्टर है लेकिन कोई संपर्क/एस्केलेशन नहीं है;आंतरिक कार्यों का केवल शीर्षक होता है\n\nहमारे अपने आंतरिक परीक्षण में, उपकरण उपयोग के उदाहरणों ने जटिल पैरामीटर हैंडलिंग पर सटीकता को 72% से 90% तक सुधार दिया।\n\nटूल का उपयोग कब करें उदाहरण उपयोग करें\n\nटूल उपयोग उदाहरण आपकी टूल परिभाषाओं में टोकन जोड़ते हैं, इसलिए जब सटीकता में सुधार अतिरिक्त लागत से अधिक हो जाता है तो वे सबसे मूल्यवान होते हैं।\n\nसबसे अधिक लाभकारी जब:\n\n- जटिल नेस्टेड संरचनाएं जहां वैध JSON सही उपयोग का संकेत नहीं देता है\n\n- कई वैकल्पिक मापदंडों और समावेशन पैटर्न वाले उपकरण मायने रखते हैं\n\n- डोमेन-विशिष्ट सम्मेलनों वाले एपीआई स्कीमा में कैप्चर नहीं किए गए हैं\n\n- समान उपकरण जहां उदाहरण स्पष्ट करते हैं कि किसका उपयोग करना है (उदाहरण के लिए, create_ticket बनाम create_incident )\n\nकम लाभकारी जब:\n\n- स्पष्ट उपयोग के साथ सरल एकल-पैरामीटर उपकरण\n\n- यूआरएल या ईमेल जैसे मानक प्रारूप जिन्हें क्लाउड पहले से ही समझता है\n\n- सत्यापन संबंधी चिंताओं को JSON स्कीमा बाधाओं द्वारा बेहतर ढंग से नियंत्रित किया जाता है\n\nसर्वोत्तम प्रथाएँ\n\nबिल्डिंग एजेंट जो वास्तविक दुनिया की कार्रवाई करते हैं, उनका अर्थ है पैमाने, जटिलता और सटीकता को एक साथ संभालना।उपकरण उपयोग वर्कफ़्लो में विभिन्न बाधाओं को हल करने के लिए ये तीन सुविधाएँ एक साथ काम करती हैं।यहां उन्हें प्रभावी ढंग से संयोजित करने का तरीका बताया गया है।\n\nपरत रणनीतिक रूप से सुविधाएँ\n\nप्रत्येक एजेंट को किसी दिए गए कार्य के लिए सभी तीन सुविधाओं का उपयोग करने की आवश्यकता नहीं है।अपनी सबसे बड़ी अड़चन से शुरुआत करें:\n\n- टूल परिभाषाओं टूल सर्च टूल से संदर्भ ब्लोट\n\n- बड़े मध्यवर्ती परिणाम संदर्भ को प्रदूषित करते हैं प्रोग्रामेटिक टूल कॉलिंग\n\n- पैरामीटर त्रुटियां और विकृत कॉल टूल उपयोग उदाहरण\n\nयह केंद्रित दृष्टिकोण आपको पहले से ही जटिलता जोड़ने के बजाय, आपके एजेंट के प्रदर्शन को सीमित करने वाली विशिष्ट बाधा को संबोधित करने देता है।\n\nफिर आवश्यकतानुसार अतिरिक्त सुविधाएँ जोड़ें।वे पूरक हैं: टूल सर्च टूल सुनिश्चित करता है कि सही टूल मिलें, प्रोग्रामेटिक टूल कॉलिंग कुशल निष्पादन सुनिश्चित करता है, और टूल उपयोग उदाहरण सही आह्वान सुनिश्चित करते हैं।\n\nबेहतर खोज के लिए टूल सर्च टूल सेट करें\n\nटूल खोज नामों और विवरणों से मेल खाती है, इसलिए स्पष्ट, वर्णनात्मक परिभाषाएं खोज सटीकता में सुधार करती हैं।\n\n```\n// अच्छा\n{\n\"नाम\": \"खोज_ग्राहक_आदेश\",\n\"विवरण\": \"तिथि सीमा, स्थिति या कुल राशि के आधार पर ग्राहक के ऑर्डर खोजें। आइटम, शिपिंग और भुगतान जानकारी सहित ऑर्डर विवरण लौटाता है।\"\n}\n\n// ख़राब\n{\n\"नाम\": \"query_db_orders\",\n\"विवरण\": \"आदेश क्वेरी निष्पादित करें\"\n}\n```\n\nसिस्टम प्रॉम्प्ट मार्गदर्शन जोड़ें ताकि क्लाउड को पता चले कि क्या उपलब्ध है:\n\n```\nआपके पास स्लैक मैसेजिंग, Google ड्राइव फ़ाइल प्रबंधन, के लिए टूल तक पहुंच है।\nजीरा टिकट ट्रैकिंग, और GitHub रिपॉजिटरी संचालन।खोज टूल का उपयोग करें\nविशिष्ट क्षमताओं को खोजने के लिए.\n```\n\nअपने तीन से पांच सबसे अधिक उपयोग किए जाने वाले उपकरणों को हमेशा लोड रखें, बाकी को स्थगित कर दें।यह अन्य सभी चीज़ों के लिए ऑन-डिमांड खोज के साथ सामान्य परिचालनों के लिए तत्काल पहुंच को संतुलित करता है।\n\nसही निष्पादन के लिए प्रोग्रामेटिक टूल कॉलिंग सेट करें\n\nचूंकि क्लाउड टूल आउटपुट को पार्स करने के लिए कोड लिखता है, दस्तावेज़ रिटर्न प्रारूप स्पष्ट रूप से होता है।इससे क्लाउड को सही पार्सिंग तर्क लिखने में मदद मिलती है: ```\n{\n\"नाम\": \"get_orders\",\n\"विवरण\": \"किसी ग्राहक के लिए ऑर्डर पुनर्प्राप्त करें।\nरिटर्न:\nऑर्डर ऑब्जेक्ट की सूची, प्रत्येक में शामिल हैं:\n- आईडी (str): ऑर्डर पहचानकर्ता\n- कुल (फ्लोट): कुल ऑर्डर USD में\n- स्थिति (str): 'लंबित', 'भेजा गया', 'वितरित' में से एक\n- आइटम (सूची): {sku, मात्रा, मूल्य} की सरणी\n- create_at (str): आईएसओ 8601 टाइमस्टैम्प\"\n}\n```\n\nप्रोग्रामेटिक ऑर्केस्ट्रेशन से लाभ उठाने वाले ऑप्ट-इन टूल के लिए नीचे देखें:\n\n- उपकरण जो समानांतर में चल सकते हैं (स्वतंत्र संचालन)\n\n- पुनः प्रयास करने के लिए संचालन सुरक्षित (बेवकूफ)\n\nपैरामीटर सटीकता के लिए टूल उपयोग उदाहरण सेट करें\n\nव्यवहारिक स्पष्टता के लिए शिल्प उदाहरण:\n\n- यथार्थवादी डेटा का उपयोग करें (वास्तविक शहर के नाम, उचित कीमतें, \"स्ट्रिंग\" या \"मूल्य\" नहीं)\n\n- न्यूनतम, आंशिक और पूर्ण विनिर्देश पैटर्न के साथ विविधता दिखाएं\n\n- इसे संक्षिप्त रखें: प्रति टूल 1-5 उदाहरण\n\n- अस्पष्टता पर ध्यान दें (केवल ऐसे उदाहरण जोड़ें जहां स्कीमा से सही उपयोग स्पष्ट न हो)\n\nआरंभ करना\n\nये सुविधाएं बीटा में उपलब्ध हैं.उन्हें सक्षम करने के लिए, बीटा हेडर जोड़ें और आवश्यक उपकरण शामिल करें:\n\n```\nclient.beta.messages.create(\nbetas=[\"उन्नत-उपकरण-उपयोग-2025-11-20\"],\nमॉडल = \"क्लाउड-सॉनेट-4-5-20250929\",\nmax_tokens=4096,\nउपकरण=[\n{\"प्रकार\": \"टूल_सर्च_टूल_रेगेक्स_20251119\", \"नाम\": \"टूल_सर्च_टूल_रेगेक्स\"},\n{\"प्रकार\": \"code_execution_20250825\", \"नाम\": \"code_execution\"},\n# आपके टूल defer_loading, स्वीकृत_कॉलर्स और इनपुट_examples के साथ\n]\n)\n```\n\nविस्तृत एपीआई दस्तावेज़ीकरण और एसडीके उदाहरणों के लिए, हमारा देखें:\n\n- टूल सर्च टूल के लिए डी डॉक्यूमेंटेशन और कुकबुक\n\n- प्रोग्रामेटिक टूल कॉलिंग के लिए दस्तावेज़ीकरण और कुकबुक\n\n- उपकरण उपयोग उदाहरणों के लिए दस्तावेज़ीकरण\n\nये सुविधाएँ टूल के उपयोग को सरल फ़ंक्शन कॉलिंग से बुद्धिमान ऑर्केस्ट्रेशन की ओर ले जाती हैं।जैसे-जैसे एजेंट दर्जनों उपकरणों और बड़े डेटासेटों में फैले अधिक जटिल वर्कफ़्लो से निपटते हैं, गतिशील खोज, कुशल निष्पादन और विश्वसनीय आह्वान मूलभूत बन जाते हैं।\n\nहम यह देखने के लिए उत्साहित हैं कि आप क्या बनाते हैं।\n\nआभार\n\nबिन वू द्वारा लिखित, एडम जोन्स, आर्टूर रेनॉल्ट, हेनरी टे, जेक नोबल, नाथन मैककैंडलिश, नूह पिकार्ड, सैम जियांग और क्लाउड डेवलपर प्लेटफ़ॉर्म टीम के योगदान के साथ।यह कार्य क्रिस गोर्गोलेव्स्की, डैनियल जियांग, जेरेमी फॉक्स और माइक लैम्बर्ट के मूलभूत शोध पर आधारित है।हमने एआई पारिस्थितिकी तंत्र से भी प्रेरणा ली, जिसमें जोएल पोबार के एलएलएमवीएम, क्लाउडफ्लेयर के कोड मोड और एमसीपी के रूप में कोड निष्पादन शामिल हैं।एंडी शूमिस्टर, हामिश केर, कीर ब्रैडवेल, मैट ब्लेइफ़र और मौली वोरवर्क को उनके समर्थन के लिए विशेष धन्यवाद।",
      "edited": false
    }
  },
  "metadata": {
    "tags": [
      "Anthropic",
      "MCP",
      "Tooling"
    ]
  }
}
